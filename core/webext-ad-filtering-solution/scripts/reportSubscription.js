/*
 * This file is part of eyeo's Web Extension Ad Blocking Toolkit (EWE),
 * Copyright (C) 2006-present eyeo GmbH
 *
 * EWE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * EWE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with EWE.  If not, see <http://www.gnu.org/licenses/>.
 */
import {writeFile} from "fs/promises";
import path from "path";
import {asDNR} from "../core/lib/dnr/index.js";
import {parse, FilterParsingError} from "../core/lib/filters/index.js";

// keeps all data per subscriptionId
export let reports = new Map(); // subscriptionId -> subscriptionReport

export function setUpCounter(subsId) {
  reports.set(subsId, {
    filterCounter: {},
    totalsCounter: {
      modifyHeaders: 0,
      allow: 0,
      allowAllRequests: 0,
      redirect: 0,
      block: 0,
      allTypes: 0
    },
    maxCounter: {
      modifyHeaders: 0,
      allow: 0,
      allowAllRequests: 0,
      redirect: 0,
      block: 0
    },
    contentFilterCounter: 0,
    urlFilterCounter: 0
  });
}

export async function writeSubsReport(subsId, reportFileAbs) {
  let subsReportContent =
    "Filter\t" +
    "Number of rules of the modifyHeaders type\t" +
    "Number of rules of the allow type\t" +
    "Number of rules of the allowAllRequests type\t" +
    "Number of rules of the redirect type\t" +
    "Number of rules of the block type\t" +
    "Total number of rules generated by this filter" +
    "\n";

  const report = reports.get(subsId);
  for (let [filterText, values] of Object.entries(report.filterCounter)) {
    const valuesCsv = filterText + "\t" + Object.values(values).join("\t") + "\n";
    subsReportContent = subsReportContent.concat(valuesCsv);
  }
  await writeFile(reportFileAbs, subsReportContent);
}

export async function writeReportSummary(repDir) {
  const reportSummaryFileAbs = path.join(repDir, "_reportSummary.csv");
  // write the header
  let content =
    "Subscription ID\t" +
    "Total of modifyHeaders rules\t" +
    "Total of allow rules\t" +
    "Total of allowAllRequests rules\t" +
    "Total of redirect rules\t" +
    "Total of block rules\t" +
    "Total of rules of all types\t" +
    "Maximum number of modifyHeaders rules generated by a single filter\t" +
    "Maximum number of allow rules generated by a single filter\t" +
    "Maximum number of allowAllRequest rules generated by a single filter\t" +
    "Maximum number of redirect rules generated by a single filter\t" +
    "Maximum number of block rules generated by a single filter\t" +
    "Content Filters\t" +
    "URL Filters" +
    "\n";

  for (let [subId, report] of reports.entries()) {
    const info = [subId].concat(
      Object.values(report.totalsCounter),
      Object.values(report.maxCounter),
      report.contentFilterCounter,
      report.urlFilterCounter
    );
    content = content.concat(info.join("\t") + "\n");
  }
  await writeFile(reportSummaryFileAbs, content);
}

export function accountForRule(rule, filterText, subsId) {
  const report = reports.get(subsId);
  // if it's the first this time that this filter appears
  if (!report.filterCounter[filterText]) {
    report.filterCounter[filterText] = {
      modifyHeaders: 0,
      allow: 0,
      allowAllRequests: 0,
      redirect: 0,
      block: 0,
      total: 0
    };
  }

  // increment the counters of the specific filter
  report.filterCounter[filterText][rule.action.type] += 1;
  report.filterCounter[filterText].total += 1;

  // increment the totals of the whole subscription
  report.totalsCounter[rule.action.type] += 1;
  report.totalsCounter.allTypes += 1;

  // possibly update the max value for
  // that type of rule inside the subscription
  //
  // compare the current max value for that type of rule
  // with the ammount of rules of that type for the current filter
  report.maxCounter[rule.action.type] = Math.max(
    report.maxCounter[rule.action.type],
    report.filterCounter[filterText][rule.action.type]
  );
}

// substitute the default convert function from adblockpluscore
// with a custom one that does the same thing + allow us to
// count the content/url filters while the filters are parsed
async function customConvert(text, outputfile) {
  const result = parse(text);
  const report = this.reports.get(this.subsId);
  if (result instanceof FilterParsingError) {
    if (text && text[0] !== "!") {
      if (this.generateReport) {
        report.contentFilterCounter++;
      }
    }
    return result;
  }
  if (this.generateReport) {
    report.urlFilterCounter++;
  }
  return await asDNR.call(this, result, outputfile);
}

export let customCreateConverter = options => customConvert.bind({
  ...options,
  // ensure a callback to verify RegExp when needed
  // By default regex are not supported.
  isRegexSupported: options.isRegexSupported || (() => false),
  // ensure a callback to modify a DNR rule when needed
  modifyRule: options.modifyRule || ((rule, context) => rule)
});
