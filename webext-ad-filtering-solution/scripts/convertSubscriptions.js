#!/usr/bin/env node
/*
 * This file is part of eyeo's Web Extension Ad Blocking Toolkit (EWE),
 * Copyright (C) 2006-present eyeo GmbH
 *
 * EWE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * EWE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with EWE.  If not, see <http://www.gnu.org/licenses/>.
 */

// the path is relative to adblockpluscore
import {OUTPUT_DIR as inputDir}
  from "./fetchSubscriptions.js";
import {processFile} from "../core/scripts/text2dnr.js";
import {parseFilterList} from "../core/lib/filters/lists.js";
import fs from "fs";
import {readFile} from "fs/promises";
import path from "path";
import yargs from "yargs";
import {hideBin} from "yargs/helpers";
import {
  setUpCounter,
  writeSubsReport,
  writeReportSummary,
  accountForRule,
  customCreateConverter,
  reports
} from "./reportSubscription.js";
import {isMain} from "./utils.js";
import {filename as customSubscriptionsFilename} from "./mergeSubscriptions.js";

const outputDir = path.join("scriptsOutput", "rulesets");
const reportDir = path.join("scriptsOutput", "report");

let highestRuleId = 1;

function generateRuleId() {
  return highestRuleId++;
}

async function convert(inDir, outDir,
                       generateReport = false, repDir = reportDir,
                       recommendedSubscriptions = customSubscriptionsFilename,
                       spaces = 2) {
  let files = fs.readdirSync(inDir);
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, {recursive: true});
  }
  if (generateReport && !fs.existsSync(repDir)) {
    fs.mkdirSync(repDir, {recursive: true});
  }

  if (!fs.existsSync(recommendedSubscriptions)) {
    throw new Error(`${recommendedSubscriptions} does not exist.`);
  }

  let customSubscriptions =
    JSON.parse(await fs.promises.readFile(recommendedSubscriptions));

  let reportFileAbs;
  let subsId = "";

  for (let inFile of files) {
    let inFileAbs = path.join(inDir, inFile);
    let outFileAbs = path.join(outDir, path.parse(inFile).base);
    reportFileAbs = path.join(repDir, path.parse(inFile).base);
    subsId = path.parse(inFile).base;
    console.log(`Converting ${inFileAbs} to ${outFileAbs} ...`);

    let converter = customCreateConverter({
      subsId,
      reports,
      generateReport,
      isRegexSupported: () => true,
      modifyRule(rule, context) {
        rule["id"] = generateRuleId();
        if (generateReport) {
          accountForRule(rule, context.text, subsId);
        }
        return rule;
      }
    });

    if (generateReport) {
      setUpCounter(subsId);
    }

    let fileContent = await readFile(inFileAbs, {encoding: "utf-8"});
    let {error, lines, params} = await parseFilterList(fileContent);
    if (error) {
      throw new Error(error);
    }

    if (params.diffurl || params.expires) {
      // iterate over all custom subscriptions and add the diffurl and expires
      // properties to the subscription whose id matches subsId
      for (let customSubscription of customSubscriptions) {
        if (customSubscription.id === subsId) {
          if (params.diffurl) {
            customSubscription.diff_url = params.diffurl;
          }
          if (params.expires) {
            customSubscription.expires = params.expires;
          }
          break;
        }
      }
    }

    await processFile(converter, lines, outFileAbs, spaces);
    if (generateReport) {
      await writeSubsReport(subsId, reportFileAbs);
    }
  }

  await fs.promises.writeFile(recommendedSubscriptions,
                              JSON.stringify(customSubscriptions, null, 2));

  if (generateReport) {
    await writeReportSummary(repDir);
  }
}

async function main() {
  const args = yargs(hideBin(process.argv))
    .option("input", {
      alias: "i",
      type: "string",
      requiresArg: true,
      description: "Input directory"
    })
    .option("output", {
      alias: "o",
      type: "string",
      requiresArg: true,
      description: "Output directory"
    })
    .option("report", {
      alias: "r",
      boolean: true,
      description: "Generate a report in csv format with info about the rulesets generated"
    })
    .option("report-output", {
      alias: "O",
      type: "string",
      requiresArg: true,
      description: "Output directory for the report generated by the --report option"
    })
    .option("recommended-subscriptions", {
      alias: "s",
      type: "string",
      requiresArg: true,
      description: "Path to the recommended subscriptions. The default is 'scriptsOutput/custom-mv3-subscriptions.json'"
    })
    .option("pretty-print", {
      alias: "p",
      boolean: true,
      description: "Pretty-print JSON files"
    })
    .parse();

  let inDir = args.input || inputDir;
  let outDir = args.output || outputDir;
  let repDir = args.reportOutput || reportDir;
  let generateReport = args.report || false;
  let recommendedSubscriptions =
    args.recommendedSubscriptions || customSubscriptionsFilename;
  let spaces = args.prettyPrint ? 2 : 0;
  await convert(inDir, outDir, generateReport,
                repDir, recommendedSubscriptions, spaces);
}

if (isMain(import.meta.url)) {
  main().catch(err => {
    console.error(err);
    process.exit(1);
  });
}

export {outputDir};
export {convert};
