/*
 * This file is part of eyeo's mlaf module (@eyeo/mlaf),
 * Copyright (C) 2006-present eyeo GmbH
 *
 * @eyeo/mlaf is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * @eyeo/mlaf is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with @eyeo/mlaf.  If not, see <http://www.gnu.org/licenses/>.
 */
const WHITESPACE_PATTERN=/\s+/g;const PUNCTUATION_PATTERN=/[\xA0!"\\'()*,-./:;?&[\]^_`{|}~“”]/g;const RGB_PATTERN=/rgb\((\d+), (\d+), (\d+)\)/;const RGBA_PATTERN=/rgba\((\d+), (\d+), (\d+), (\d+)\)/;const ORIGIN_PATTERN=/(\d*?\.?\d*)px (\d*?\.?\d*)px/;const PIXEL_PATTERN=/(\d*?\.?\d*)px/;const DOT_PATTERN=/\./g;const BRACKETS_PATTERN=/^\[|\]$/g;const SLASH_PATTERN=/\//g;const WORD_INDEX=Object.fromEntries([..." abcdefghijklmnopqrstuvwxyz1234567890:;/?!=+.,()[]-`*_|~"].map(((e,t)=>[e,t+1])));class FeatureNormalizer{constructor(e){this.normalizers=[];e.forEach((e=>{if(Array.isArray(e)){let[t,r]=e;this.normalizers.push(new t(r))}else{this.normalizers.push(new e)}}))}normalize(e,t){this.normalizers.forEach((r=>{e=r.normalize(e,t)}));return e}}class StringNormalizer{normalize(e){throw new Error("Not implemented.")}}class Lowercase extends StringNormalizer{normalize(e){return e.toLowerCase()}}class StripWhitespace extends StringNormalizer{normalize(e){return e.trim()}}class CollapseWhitespace extends StringNormalizer{normalize(e){return e.replace(WHITESPACE_PATTERN," ")}}class StripAndCollapseWhitespace extends StringNormalizer{normalize(e){return e.replace(WHITESPACE_PATTERN," ").trim()}}class RemovePunctuation extends StringNormalizer{normalize(e){return e.replace(PUNCTUATION_PATTERN,"")}}class ReplacePunctuation extends StringNormalizer{normalize(e){return e.replace(PUNCTUATION_PATTERN," ")}}class ReplaceStr extends StringNormalizer{constructor(e){super();this.pairs=e}normalize(e){if(e){this.pairs.forEach((t=>{e=e.split(t[0]).join(t[1])}))}return e}}class LastCSSClassNormalizer extends StringNormalizer{normalize(e){return e.split(" ").pop()}}class VectorNormalizer{normalize(e){throw new Error("Not implemented.")}}class FloatNormalizer extends VectorNormalizer{normalize(e){return[parseFloat(e)||0]}}class SequenceNormalizer extends VectorNormalizer{constructor(e){super();this.maxLen=e}normalize(e){let t=[...e.toLowerCase()].slice(-this.maxLen).map((e=>e in WORD_INDEX?WORD_INDEX[e]:1));return t.length>=this.maxLen?t:t.concat(new Array(this.maxLen-t.length).fill(0))}}class OneHotVectorNormalizer extends VectorNormalizer{constructor(e){super();const t=e.length;this.empty=new Array(t).fill(0);let r=0;this.categoryMap=e.reduce(((e,t)=>{let s=[...this.empty];s[r++]=1;e[t]=s;return e}),{})}normalize(e){return this.categoryMap[e]||this.empty}}class FontSizeNormalizer extends VectorNormalizer{normalize(e){return[parseFloat(e)||0]}}class ColorNormalizer extends VectorNormalizer{constructor(e){super();this.maxLen=e}normalize(e){let t=[0,0,0,0];const r=e.match(RGB_PATTERN);if(r){r.shift();t=r.map((e=>parseFloat(e)||0));t.push(0)}else{const r=e.match(RGBA_PATTERN);if(r){r.shift();t=r.map((e=>parseFloat(e)||0))}}return t.slice(0,this.maxLen)}}class PixelNormalizer extends VectorNormalizer{normalize(e){const t=e.match(PIXEL_PATTERN);if(t)return[parseFloat(t[1])||0];return[0]}}class OriginNormalizer extends VectorNormalizer{normalize(e){const t=e.match(ORIGIN_PATTERN);if(t){t.shift();return t.map((e=>parseFloat(e)||0))}return[0,0]}}class NodeChildrenLenNormalizer{normalize(e){if(Array.isArray(e))return[e.length];return[0]}}const URL_MARKERS=["http","data","blob","ftp:"];class MetaURLPartsNormalizer{normalize(e,t){if(!e)return[0,0,0,0,0,0,0,0,0];const r=1;const s=URL_MARKERS.includes(e.slice(0,4).toLowerCase())?1:0;if(!s)return[r,s,0,0,e.length,0,0,0,0];let o;try{o=new URL(e)}catch(t){return[r,s,0,0,e.length,0,0,0,0]}const a=o.hostname.includes(t["domain"])?0:1;const i=o.username+o.password+o.hostname+(o.port?o.port:"");const n=o.pathname==="/"?"":o.pathname;const l=Array.from(o.searchParams);const c=i.length;const p=n.length;const h=l.flat().join("").length;const u=i?o.hostname.split(".").length:0;const m=n.split("/").filter(Boolean).length;const f=l.length;return[r,s,a,c,p,h,u,m,f]}}class URLPartsNormalizer{constructor(e){this.maxLen=e;this.maxPartsLen=this.maxLen/3;this.replacePunctuation=new ReplacePunctuation}normalize(e,t){let r;const s=URL_MARKERS.includes(e.slice(0,4).toLowerCase())?1:0;if(!s)return e.substring(0,this.maxLen).trim();try{r=new URL(e)}catch(t){return e.substring(0,this.maxLen).trim()}const o=r.hostname.replace(BRACKETS_PATTERN,"");const a=[r.username,r.password,o.replace(DOT_PATTERN," "),r.port].filter(Boolean).join(" ").slice(0,this.maxPartsLen).trim();const i=r.pathname.replace(SLASH_PATTERN," ").slice(0,2*this.maxPartsLen-a.length).trim();const n=r.search.substring(1).split("&").map((e=>e.split("=")[0].trim())).join(" ").slice(0,3*this.maxPartsLen-a.length-i.length).trim();return[[a,i].join(" ").trim(),n].join(" ").trim()}}class MetaContentNormalizer{normalize(e,t){let r=0;let s=0;if(e){r=e.length;s=e.split(" ").length}return[r,s]}}class FeaturePreProcessor{constructor(e){this.preprocesors=[];for(let t of e)this.preprocesors.push(new t)}process(e,t){this.preprocesors.forEach((t=>e=t.process(e)));return e}}class EmptyPreProcessor{process(e,t){if(!e)return new Map;return e}}class CSSSelectorPreProcessor{process(e,t){if(!e||!(typeof e==="string"||e instanceof String))return new Map;return e.split(";").reduce(((e,t)=>{const[r,s]=t.split(":");if(r&&s&&!(r in e))e[r.trim()]=s.trim();return e}),{})}}function createFeatureGroups(e){let t=[];let r=[];for(let t of e)t.groupName=Object.keys(t)[2];for(let s of e){if(s.scope==="graph"&&s.include)t.push(new FeatureGroup(s.groupName,s[s.groupName]));else if(s.scope==="node"&&s.include)r.push(new FeatureGroup(s.groupName,s[s.groupName]))}return[r,t]}const Preprocessor2Class={empty:EmptyPreProcessor,css_selector:CSSSelectorPreProcessor};const Normalizers2Class={lower:Lowercase,strip_whitespace:StripWhitespace,collapse_whitespace:CollapseWhitespace,strip_and_collapse_whitespace:StripAndCollapseWhitespace,remove_punctuation:RemovePunctuation,replace_punctuation:ReplacePunctuation,sequence:SequenceNormalizer,one_hot_vector:OneHotVectorNormalizer,font_size:FontSizeNormalizer,color:ColorNormalizer,pixel:PixelNormalizer,origin:OriginNormalizer,children_len:NodeChildrenLenNormalizer,replace_str:ReplaceStr,meta_url:MetaURLPartsNormalizer,url_parts:URLPartsNormalizer,meta_content:MetaContentNormalizer,css_class:LastCSSClassNormalizer,float:FloatNormalizer};const splitWithEmpty=(e,t)=>{const r=e.split(t);if(r[0]===""&&r.length===1)return[];return r};class Feature{constructor(e,t){this.name=e;this.dim=t.dim;this.altNames=splitWithEmpty(e,"^");this.path=[];if(t.path)this.path=splitWithEmpty(t.path,"^");let r=[];if(!Object.prototype.hasOwnProperty.call(t,"normalizers")){r.push(Normalizers2Class.empty)}else{for(const e in t.normalizers){const s=t.normalizers[e];if(typeof s==="string"||s instanceof String){r.push(Normalizers2Class[s])}else if(typeof s==="object"&&s!==null){const e=Object.keys(s)[0];r.push([Normalizers2Class[e],Object.values(s[e])[0]])}}}this.normalizer=new FeatureNormalizer(r)}getName(e){if(this.altNames&&Object.keys(e).length>0){for(let t of this.altNames){if(t in e)return t}}return this.name}extractValues(e,t){let r=e;this.path.forEach((e=>{if(e in r)r=r[e]}));const s=this.getName(r);const o=s in r?r[s]:"";const a=this.normalizer.normalize(o||"",t);if(a.length!==this.dim)throw new Error("Feature dimensionality mismatch");return a}}class FeatureGroup{constructor(e,t){this.name=e;this.path=splitWithEmpty(t.path,"/");this.prep=this.initPreprocessing(t);this.features=this.initFeatures(t.features)}initPreprocessing(e){let t=[];if(!Object.prototype.hasOwnProperty.call(e,"prep")){t.push(Preprocessor2Class.empty)}else{for(let r of e.prep)t.push(Preprocessor2Class[r])}return new FeaturePreProcessor(t)}initFeatures(e){let t=[];for(const r of e){const e=Object.keys(r)[0];const s=r[e];if(!Object.prototype.hasOwnProperty.call(s,"names")){t.push(new Feature(e,s));continue}for(const e of s.names)t.push(new Feature(e,s))}return t}extractValues(e,t){let r=e;this.path.forEach((e=>{if(e in r)r=r[e]}));r=this.prep.process(r,t);if(typeof r!=="object"||Array.isArray(r)||r===null){throw new Error(`path ${this.path}, value ${r}, expected ${typeof{}}, got ${r}`)}let s=[];this.features.forEach((e=>s.push(...e.extractValues(r,t))));return s}}const URL_DATA_ATTRS=["src","href","xlink:href"];const zeros=(e,t,r=0)=>Array.from(new Array(t),(t=>Array(e).fill(r)));const get=(e,t,r)=>t in e?e[t]:r;class Graph{constructor(e){this.numNodes=0;this.root=e["obj"]["graph"];this.domain=e["obj"]["domain"];this.graphAttributes={domain:e["obj"]["domain"]};this.featureGroups=e["nodeFeatureGroups"];this.graphFeatureGroups=e["graphFeatureGroups"];this.cutoff=e["cutoff"]}getData(){this.setNodeAttributes();let e=zeros(this.numNodes,this.numNodes);let t=[];let r=[];let s=[[this.root,{}]];let o=this.cutoff;while(s.length&&--o>=0){let r;let[o,a]=s.pop();this._updateFeatures(o,this.featureGroups,t);if(a&&Object.keys(a).length>0)this._updateEdges(o,a,e);[a,r]=[o,o["children"]];for(let e=r.length-1;e>=0;e--)s.push([r[e],a])}this._updateFeatures(this.graphAttributes,this.graphFeatureGroups,r);return this._formatData(e,t,r)}setNodeAttributes(){let e=[[this.root,{}]];let t=this.cutoff;while(e.length&&--t>=0){let t;let[r,s]=e.pop();this._setNodeAttributes(r,s);[s,t]=[r,r["children"]];for(let r=t.length-1;r>=0;r--)e.push([t[r],s])}}_setNodeAttributes(e,t){e["node_id"]=this.numNodes++;e["dom"]=this.domain;e["parent_id"]=get(t,"node_id",0);e["siblings"]=get(t,"children",[]).length;e["level"]=get(t,"level",-1)+1;let r=get(e,"attributes",{});let s=get(t,"attributes",{});URL_DATA_ATTRS.forEach((o=>{let a=`${o}_level`;if(this._hasAttribute(o,r)){e["attributes"][a]=0}else if(this._hasAttribute(o,s)){e["attributes"][o]=s[o];e["attributes"][a]=s[a]+1;if("requestType"in t)e["requestType"]=t["requestType"]}}))}_hasAttribute(e,t){return e in t&&t[e]}_updateFeatures(e,t,r){let s=[];t.forEach((t=>s.push(...t.extractValues(e,{domain:this.domain}).map((e=>Math.round(e*100)/100||0)))));r.push(s)}_updateEdges(e,t,r){r[t["node_id"]][e["node_id"]]=1;r[e["node_id"]][t["node_id"]]=1}_formatData(e,t,r){if(e.length>t.length)this._cutEdges(e,t.length);if(this.graphFeatureGroups.length>0)return[e,t,r];return[e,t]}_cutEdges(e,t){e=e.slice(0,t);e.forEach(((e,r,s)=>{s[r]=e.slice(0,t)}))}}class ML{constructor(e){this.tfjs=e;this._preprocessingFunctions=new Map([["cast",e.cast],["stack",e.stack],["unstack",e.unstack],["localPooling",this._localPoolingMap.bind(this)],["padAdjacency",this._padTensorAdjacency.bind(this)],["padFeatures",this._padTensorFeatures.bind(this)]])}_padTensorAdjacency(e,t){return e.pad([[0,0],[0,t-e.shape[1]],[0,t-e.shape[2]]])}_localPoolingMap(e){return e.map((e=>this._localPooling(e)))}_localPooling(e){let t=e.add(this.tfjs.eye(e.shape[0]));let r=this.tfjs.pow(this.tfjs.sum(t,1),-.5);r=r.where(this.tfjs.isFinite(r),this.tfjs.zeros(r.shape));let s=r.mul(this.tfjs.eye(t.shape[0]));let o=s.dot(t).dot(s);return o}_padTensorFeatures(e,t){return e.pad([[0,0],[0,t-e.shape[1]],[0,0]])}createTensors(e,t){let[r,s]=e;let o=[{data:[r],preprocess:[{funcName:"padAdjacency",args:t}]},{data:[s],preprocess:[{funcName:"padFeatures",args:t}]}];let a=this.tfjs.tidy((()=>o.map((e=>{let t=this.tfjs.tensor(e.data);if(e.preprocess){for(let r of e.preprocess){t=this._preprocessingFunctions.get(r.funcName)(t,r.args)}}return t}))));return a}}const DEFAULT_GRAPH_CUTOFF=500;async function inference(e,t,r,s,o="."){return domToGraph(r,s).then((e=>preprocessGraph(r,e,o))).then((s=>predict(e,t,r,s))).then((e=>digestPrediction(e)))}async function domToGraph(e,t,r=false){return new Promise(((s,o)=>{if(!e||!t)return o();let a=e.config;let i=a.cutoff||e.topology.graphml.nodes||DEFAULT_GRAPH_CUTOFF;a=a.filter((e=>e.include));for(let e of a)e.groupName=Object.keys(e)[2];let n=(e,t,r,s)=>{if(r==="attributes"&&typeof e.attributes[s]!=="undefined")t.attributes[s]=e.attributes[s].value;else if(r==="style"&&e.style[s])t.attributes.style[s]=e.style[s];else if(r==="css")t.cssSelectors=getComputedStyle(e).cssText||""};let l=e=>{if(r&&!e.clientWidth&&!e.clientHeight)return;i-=1;if(i<0)return;let t={tag:e.tagName,width:e.clientWidth,height:e.clientHeight,attributes:{style:{}},children:[]};for(let r of a){for(let s of r[r.groupName].features){for(let[o,a]of Object.entries(s)){if("names"in a){for(let s of a.names){for(let o of s.split("^"))n(e,t,r.groupName,o)}}else{n(e,t,r.groupName,o)}}}}if(e.children){for(let r of e.children){let e=l(r);if(e)t.children.push(e)}}return t};let c=l(t);s(c)}))}async function preprocessGraph(e,t,r="."){return new Promise(((s,o)=>{if(!e||!t)return o();let a=e.config;let i=a.cutoff||e.topology.graphml.nodes||DEFAULT_GRAPH_CUTOFF;let[n,l]=createFeatureGroups(a);let c={nodeFeatureGroups:n,graphFeatureGroups:l,obj:{domain:r,graph:t},cutoff:i};let p=new Graph(c);let h=p.getData();s(h)}))}async function predict(e,t,r,s){return new Promise(((o,a)=>{if(!r||!e||!t||!s)return a();let i=r.config;let n=i.cutoff||r.topology.graphml.nodes||DEFAULT_GRAPH_CUTOFF;let l=new ML(e);let c=l.createTensors(s,n);let p=t.execute(c);p.data().then((e=>{o(e)})).catch((e=>{a(e)})).finally((()=>{p.dispose();for(let e of c)e.dispose()}))}))}async function digestPrediction(e){return new Promise(((t,r)=>{e=Array.from(e);if(!e||!Array.isArray(e)||!e.some((e=>e>0))||e.length<2)return r();let s=e.reduce(((e,t)=>e+t),0);e=e.map((e=>e/s));t(e[1]>e[0])}))}async function loadBundledModel(e,t){if(!t)return Promise.reject("model not found");return e.loadGraphModel({load(){let e={modelTopology:t.topology.modelTopology||{},signature:t.topology.signature||{},weightsManifest:t.topology.weightsManifest||[],weightSpecs:t.topology.weightsManifest.map((e=>e.weights))[0]||[],weightData:concatWeights(t.weights.map((e=>Uint8Array.from(atob(e.shard),(e=>e.charCodeAt(0))))))||[]};return e}})}async function loadModel(e,t){return e.loadGraphModel(t)}function concatWeights(e){let t=0;e.forEach((e=>{t+=e.byteLength}));let r=new Uint8Array(t);let s=0;e.forEach((e=>{r.set(new Uint8Array(e),s);s+=e.byteLength}));return r.buffer}export{digestPrediction,domToGraph,inference,loadBundledModel,loadModel,predict,preprocessGraph};
