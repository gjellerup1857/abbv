/*
 * This file is part of eyeo's mlaf module (@eyeo/mlaf),
 * Copyright (C) 2006-present eyeo GmbH
 *
 * @eyeo/mlaf is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * @eyeo/mlaf is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with @eyeo/mlaf.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The following npm packages may be included in this file:
 *
 * - tfjs
 * - tfjs-backend-cpu
 * - tfjs-backend-webgl
 * - tfjs-converter
 * - tfjs-core
 * - tfjs-data
 * - tfjs-layers
 *
 * These packages contain the following information about the license:
 *
 *  * @license
 *  * Copyright 2018-2022 Google LLC. All Rights Reserved.
 *  * Licensed under the Apache License, Version 2.0 (the "License");
 *  * you may not use this file except in compliance with the License.
 *  * You may obtain a copy of the License at
 *  *
 *  * http://www.apache.org/licenses/LICENSE-2.0
 *  *
 *  * Unless required by applicable law or agreed to in writing, software
 *  * distributed under the License is distributed on an "AS IS" BASIS,
 *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  * See the License for the specific language governing permissions and
 *  * limitations under the License.
 *  * =============================================================================
 */
function _mergeNamespaces(e,t){t.forEach((function(t){t&&typeof t!=="string"&&!Array.isArray(t)&&Object.keys(t).forEach((function(n){if(n!=="default"&&!(n in e)){var r=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,r.get?r:{enumerable:true,get:function(){return t[n]}})}}))}));return Object.freeze(e)}const EPSILON_FLOAT32$1=1e-7;const EPSILON_FLOAT16$1=1e-4;class DataStorage{constructor(e,t){this.backend=e;this.dataMover=t;this.data=new WeakMap;this.dataIdsCount=0}get(e){if(!this.data.has(e)){this.dataMover.moveData(this.backend,e)}return this.data.get(e)}set(e,t){this.dataIdsCount++;this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){this.dataIdsCount--;return this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class KernelBackend{refCount(e){return notYetImplemented("refCount")}incRef(e){return notYetImplemented("incRef")}timerAvailable(){return true}time(e){return notYetImplemented("time")}read(e){return notYetImplemented("read")}readSync(e){return notYetImplemented("readSync")}readToGPU(e,t){return notYetImplemented("readToGPU")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(e,t){return notYetImplemented("disposeData")}write(e,t,n){return notYetImplemented("write")}move(e,t,n,r,a){return notYetImplemented("move")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32$1:EPSILON_FLOAT16$1}dispose(){return notYetImplemented("dispose")}}function nearestLargerEven(e){return e%2===0?e:e+1}function sum$2(e){let t=0;for(let n=0;n<e.length;n++){t+=e[n]}return t}function assert(e,t){if(!e){throw new Error(typeof t==="string"?t:t())}}function assertShapesMatch(e,t,n=""){assert(arraysEqual(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function assertNonNull(e){assert(e!=null,(()=>`The input to the tensor constructor must be a non-null value.`))}function flatten(e,t=[],n=false){if(t==null){t=[]}if(Array.isArray(e)||isTypedArray(e)&&!n){for(let r=0;r<e.length;++r){flatten(e[r],t,n)}}else{t.push(e)}return t}function sizeFromShape(e){if(e.length===0){return 1}let t=e[0];for(let n=1;n<e.length;n++){t*=e[n]}return t}function arraysEqual(e,t){if(e===t){return true}if(e==null||t==null){return false}if(e.length!==t.length){return false}for(let n=0;n<e.length;n++){if(e[n]!==t[n]){return false}}return true}function isInt(e){return e%1===0}function sizeToSquarishShape(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function rightPad(e,t){if(t<=e.length){return e}return e+" ".repeat(t-e.length)}function repeatedTry(e,t=(e=>0),n){return new Promise(((r,a)=>{let s=0;const o=()=>{if(e()){r();return}s++;const i=t(s);if(n!=null&&s>=n){a();return}setTimeout(o,i)};o()}))}function inferFromImplicitShape(e,t){let n=1;let r=-1;for(let t=0;t<e.length;++t){if(e[t]>=0){n*=e[t]}else if(e[t]===-1){if(r!==-1){throw Error(`Shapes can only have 1 implicit size. `+`Found -1 at dim ${r} and dim ${t}`)}r=t}else if(e[t]<0){throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`)}}if(r===-1){if(t>0&&t!==n){throw Error(`Size(${t}) must match the product of shape ${e}`)}return e}if(n===0){throw Error(`Cannot infer the missing size in [${e}] when `+`there are 0 elements`)}if(t%n!==0){throw Error(`The implicit shape can't be a fractional number. `+`Got ${t} / ${n}`)}const a=e.slice();a[r]=t/n;return a}function parseAxisParam(e,t){const n=t.length;e=e==null?t.map(((e,t)=>t)):[].concat(e);assert(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but `+`got axis ${e}`));assert(e.every((e=>isInt(e))),(()=>`All values in axis param must be integers but `+`got axis ${e}`));return e.map((e=>e<0?n+e:e))}function squeezeShape(e,t){const n=[];const r=[];const a=t!=null&&Array.isArray(t)&&t.length===0;const s=t==null||a?null:parseAxisParam(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(s!=null){if(s[o]===t&&e[t]!==1){throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`)}if((s[o]==null||s[o]>t)&&e[t]===1){n.push(e[t]);r.push(t)}if(s[o]<=t){o++}}if(e[t]!==1){n.push(e[t]);r.push(t)}}return{newShape:n,keptDims:r}}function getTypedArrayFromDType(e,t){let n=null;if(e==null||e==="float32"){n=new Float32Array(t)}else if(e==="int32"){n=new Int32Array(t)}else if(e==="bool"){n=new Uint8Array(t)}else{throw new Error(`Unknown data type ${e}`)}return n}function getArrayFromDType(e,t){let n=null;if(e==null||e==="float32"){n=new Float32Array(t)}else if(e==="int32"){n=new Int32Array(t)}else if(e==="bool"){n=new Uint8Array(t)}else if(e==="string"){n=new Array(t)}else{throw new Error(`Unknown data type ${e}`)}return n}function isValidDtype(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function hasEncodingLoss(e,t){if(t==="complex64"){return false}if(t==="float32"&&e!=="complex64"){return false}if(t==="int32"&&e!=="float32"&&e!=="complex64"){return false}if(t==="bool"&&e==="bool"){return false}return true}function isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function bytesPerElement(e){if(e==="float32"||e==="int32"){return 4}else if(e==="complex64"){return 8}else if(e==="bool"){return 1}else{throw new Error(`Unknown dtype ${e}`)}}function bytesFromStringArray(e){if(e==null){return 0}let t=0;e.forEach((e=>t+=e.length));return t}function isNumber(e){return typeof e==="number"}function inferDtype(e){if(Array.isArray(e)){return inferDtype(e[0])}if(e instanceof Float32Array){return"float32"}else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray){return"int32"}else if(isNumber(e)){return"float32"}else if(isString(e)){return"string"}else if(isBoolean(e)){return"bool"}return"float32"}function isFunction(e){return!!(e&&e.constructor&&e.call&&e.apply)}function nearestDivisor(e,t){for(let n=t;n<e;++n){if(e%n===0){return n}}return e}function computeStrides(e){const t=e.length;if(t<2){return[]}const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r){n[r]=n[r+1]*e[r+1]}return n}function createNestedArray(e,t,n,r=false){const a=new Array;if(t.length===1){const s=t[0]*(r?2:1);for(let t=0;t<s;t++){a[t]=n[e+t]}}else{const s=t[0];const o=t.slice(1);const i=o.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++){a[t]=createNestedArray(e+t*i,o,n,r)}}return a}function toNestedArray(e,t,n=false){if(e.length===0){return t[0]}const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(r===0){return[]}if(r!==t.length){throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`)}return createNestedArray(0,e,t,n)}function makeOnesTypedArray(e,t){const n=makeZerosTypedArray(e,t);for(let e=0;e<n.length;e++){n[e]=1}return n}function makeZerosTypedArray(e,t){if(t==null||t==="float32"||t==="complex64"){return new Float32Array(e)}else if(t==="int32"){return new Int32Array(e)}else if(t==="bool"){return new Uint8Array(e)}else{throw new Error(`Unknown data type ${t}`)}}function assertNonNegativeIntegerDimensions(e){e.forEach((t=>{assert(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got `+`shape [${e}].`))}))}function locToIndex(e,t,n){if(t===0){return 0}else if(t===1){return e[0]}let r=e[e.length-1];for(let t=0;t<e.length-1;++t){r+=n[t]*e[t]}return r}function indexToLoc(e,t,n){if(t===0){return[]}else if(t===1){return[e]}const r=new Array(t);for(let t=0;t<r.length-1;++t){r[t]=Math.floor(e/n[t]);e-=r[t]*n[t]}r[r.length-1]=e;return r}function isPromise(e){return e&&e.then&&typeof e.then==="function"}const TENSORFLOWJS_FLAGS_PREFIX="tfjsflags";class Environment{constructor(e){this.global=e;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=getQueryParams;this.populateURLFlags()}setPlatform(e,t){if(this.platform!=null){if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.warn(`Platform ${this.platformName} has already been set. `+`Overwriting the platform with ${e}.`)}}this.platformName=e;this.platform=t}registerFlag(e,t,n){this.flagRegistry[e]={evaluationFn:t,setHook:n};if(this.urlFlags[e]!=null){const t=this.urlFlags[e];if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.warn(`Setting feature override from URL ${e}: ${t}.`)}this.set(e,t)}}async getAsync(e){if(e in this.flags){return this.flags[e]}this.flags[e]=await this.evaluateFlag(e);return this.flags[e]}get(e){if(e in this.flags){return this.flags[e]}const t=this.evaluateFlag(e);if(isPromise(t)){throw new Error(`Flag ${e} cannot be synchronously evaluated. `+`Please use getAsync() instead.`)}this.flags[e]=t;return this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null){throw new Error(`Cannot set flag ${e} as it has not been registered.`)}this.flags[e]=t;if(this.flagRegistry[e].setHook!=null){this.flagRegistry[e].setHook(t)}}evaluateFlag(e){if(this.flagRegistry[e]==null){throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`)}return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={};this.urlFlags={};this.populateURLFlags()}populateURLFlags(){if(typeof this.global==="undefined"||typeof this.global.location==="undefined"||typeof this.global.location.search==="undefined"){return}const e=this.getQueryParams(this.global.location.search);if(TENSORFLOWJS_FLAGS_PREFIX in e){const t=e[TENSORFLOWJS_FLAGS_PREFIX].split(",");t.forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=parseValue(t,n)}))}}}function getQueryParams(e){const t={};e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>{decodeParam(t,n[0],n[1]);return n.join("=")}));return t}function decodeParam(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function env(){return ENV$3}let ENV$3=null;function setEnvironmentGlobal(e){ENV$3=e}let globalNameSpace;function getGlobalNamespace(){if(globalNameSpace==null){let e;if(typeof window!=="undefined"){e=window}else if(typeof global!=="undefined"){e=global}else if(typeof process!=="undefined"){e=process}else if(typeof self!=="undefined"){e=self}else{throw new Error("Could not find a global object")}globalNameSpace=e}return globalNameSpace}function getGlobalMap(){const e=getGlobalNamespace();if(e._tfGlobals==null){e._tfGlobals=new Map}return e._tfGlobals}function getGlobal(e,t){const n=getGlobalMap();if(n.has(e)){return n.get(e)}else{const r=t();n.set(e,r);return n.get(e)}}const Abs="Abs";const Add="Add";const BatchMatMul="BatchMatMul";const Bincount="Bincount";const Cast="Cast";const Complex="Complex";const ComplexAbs="ComplexAbs";const Concat="Concat";const Conv2DBackpropFilter="Conv2DBackpropFilter";const Conv2DBackpropInput="Conv2DBackpropInput";const DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter";const DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput";const RealDiv="RealDiv";const Equal="Equal";const Exp="Exp";const ExpandDims="ExpandDims";const FFT="FFT";const GatherV2="GatherV2";const Greater="Greater";const Identity="Identity";const IsFinite="IsFinite";const Log="Log";const Log1p="Log1p";const LogicalAnd="LogicalAnd";const Max="Max";const Maximum="Maximum";const Mean="Mean";const Minimum="Minimum";const Multiply="Multiply";const Neg="Neg";const NotEqual="NotEqual";const OneHot="OneHot";const Pack="Pack";const PadV2="PadV2";const Pow="Pow";const Prod="Prod";const Range="Range";const Real="Real";const Relu="Relu";const Reshape="Reshape";const Reverse="Reverse";const Select="Select";const Slice="Slice";const Sigmoid="Sigmoid";const Sum="Sum";const SquaredDifference="SquaredDifference";const Sub="Sub";const Tile="Tile";const Unpack="Unpack";const ZerosLike="ZerosLike";const _FusedMatMul="_FusedMatMul";function warn(...e){if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.warn(...e)}}function log$1(...e){if(!(env().getBool("IS_TEST")||env().getBool("PROD"))){console.log(...e)}}const kernelRegistry=getGlobal("kernelRegistry",(()=>new Map));const gradRegistry=getGlobal("gradRegistry",(()=>new Map));function getKernel(e,t){const n=makeKey(e,t);return kernelRegistry.get(n)}function getGradient(e){return gradRegistry.get(e)}function getKernelsForBackend(e){const t=kernelRegistry.entries();const n=[];while(true){const{done:r,value:a}=t.next();if(r){break}const[s,o]=a;const[i]=s.split("_");if(i===e){n.push(o)}}return n}function registerKernel(e){const{kernelName:t,backendName:n}=e;const r=makeKey(t,n);if(kernelRegistry.has(r)){warn(`The kernel '${t}' for backend `+`'${n}' is already registered`)}kernelRegistry.set(r,e)}function makeKey(e,t){return`${t}_${e}`}var commonjsGlobal=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};var long=Long$1;var wasm=null;try{wasm=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function Long$1(e,t,n){this.low=e|0;this.high=t|0;this.unsigned=!!n}Long$1.prototype.__isLong__;Object.defineProperty(Long$1.prototype,"__isLong__",{value:true});function isLong(e){return(e&&e["__isLong__"])===true}Long$1.isLong=isLong;var INT_CACHE={};var UINT_CACHE={};function fromInt(e,t){var n,r,a;if(t){e>>>=0;if(a=0<=e&&e<256){r=UINT_CACHE[e];if(r)return r}n=fromBits(e,(e|0)<0?-1:0,true);if(a)UINT_CACHE[e]=n;return n}else{e|=0;if(a=-128<=e&&e<128){r=INT_CACHE[e];if(r)return r}n=fromBits(e,e<0?-1:0,false);if(a)INT_CACHE[e]=n;return n}}Long$1.fromInt=fromInt;function fromNumber(e,t){if(isNaN(e))return t?UZERO:ZERO;if(t){if(e<0)return UZERO;if(e>=TWO_PWR_64_DBL)return MAX_UNSIGNED_VALUE}else{if(e<=-TWO_PWR_63_DBL)return MIN_VALUE;if(e+1>=TWO_PWR_63_DBL)return MAX_VALUE}if(e<0)return fromNumber(-e,t).neg();return fromBits(e%TWO_PWR_32_DBL|0,e/TWO_PWR_32_DBL|0,t)}Long$1.fromNumber=fromNumber;function fromBits(e,t,n){return new Long$1(e,t,n)}Long$1.fromBits=fromBits;var pow_dbl=Math.pow;function fromString(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return ZERO;if(typeof t==="number"){n=t,t=false}else{t=!!t}n=n||10;if(n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");else if(r===0){return fromString(e.substring(1),t,n).neg()}var a=fromNumber(pow_dbl(n,8));var s=ZERO;for(var o=0;o<e.length;o+=8){var i=Math.min(8,e.length-o),u=parseInt(e.substring(o,o+i),n);if(i<8){var l=fromNumber(pow_dbl(n,i));s=s.mul(l).add(fromNumber(u))}else{s=s.mul(a);s=s.add(fromNumber(u))}}s.unsigned=t;return s}Long$1.fromString=fromString;function fromValue(e,t){if(typeof e==="number")return fromNumber(e,t);if(typeof e==="string")return fromString(e,t);return fromBits(e.low,e.high,typeof t==="boolean"?t:e.unsigned)}Long$1.fromValue=fromValue;var TWO_PWR_16_DBL=1<<16;var TWO_PWR_24_DBL=1<<24;var TWO_PWR_32_DBL=TWO_PWR_16_DBL*TWO_PWR_16_DBL;var TWO_PWR_64_DBL=TWO_PWR_32_DBL*TWO_PWR_32_DBL;var TWO_PWR_63_DBL=TWO_PWR_64_DBL/2;var TWO_PWR_24=fromInt(TWO_PWR_24_DBL);var ZERO=fromInt(0);Long$1.ZERO=ZERO;var UZERO=fromInt(0,true);Long$1.UZERO=UZERO;var ONE=fromInt(1);Long$1.ONE=ONE;var UONE=fromInt(1,true);Long$1.UONE=UONE;var NEG_ONE=fromInt(-1);Long$1.NEG_ONE=NEG_ONE;var MAX_VALUE=fromBits(4294967295|0,2147483647|0,false);Long$1.MAX_VALUE=MAX_VALUE;var MAX_UNSIGNED_VALUE=fromBits(4294967295|0,4294967295|0,true);Long$1.MAX_UNSIGNED_VALUE=MAX_UNSIGNED_VALUE;var MIN_VALUE=fromBits(0,2147483648|0,false);Long$1.MIN_VALUE=MIN_VALUE;var LongPrototype=Long$1.prototype;LongPrototype.toInt=function e(){return this.unsigned?this.low>>>0:this.low};LongPrototype.toNumber=function e(){if(this.unsigned)return(this.high>>>0)*TWO_PWR_32_DBL+(this.low>>>0);return this.high*TWO_PWR_32_DBL+(this.low>>>0)};LongPrototype.toString=function e(t){t=t||10;if(t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(MIN_VALUE)){var n=fromNumber(t),r=this.div(n),a=r.mul(n).sub(this);return r.toString(t)+a.toInt().toString(t)}else return"-"+this.neg().toString(t)}var s=fromNumber(pow_dbl(t,6),this.unsigned),o=this;var i="";while(true){var u=o.div(s),l=o.sub(u.mul(s)).toInt()>>>0,c=l.toString(t);o=u;if(o.isZero())return c+i;else{while(c.length<6)c="0"+c;i=""+c+i}}};LongPrototype.getHighBits=function e(){return this.high};LongPrototype.getHighBitsUnsigned=function e(){return this.high>>>0};LongPrototype.getLowBits=function e(){return this.low};LongPrototype.getLowBitsUnsigned=function e(){return this.low>>>0};LongPrototype.getNumBitsAbs=function e(){if(this.isNegative())return this.eq(MIN_VALUE)?64:this.neg().getNumBitsAbs();var t=this.high!=0?this.high:this.low;for(var n=31;n>0;n--)if((t&1<<n)!=0)break;return this.high!=0?n+33:n+1};LongPrototype.isZero=function e(){return this.high===0&&this.low===0};LongPrototype.eqz=LongPrototype.isZero;LongPrototype.isNegative=function e(){return!this.unsigned&&this.high<0};LongPrototype.isPositive=function e(){return this.unsigned||this.high>=0};LongPrototype.isOdd=function e(){return(this.low&1)===1};LongPrototype.isEven=function e(){return(this.low&1)===0};LongPrototype.equals=function e(t){if(!isLong(t))t=fromValue(t);if(this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1)return false;return this.high===t.high&&this.low===t.low};LongPrototype.eq=LongPrototype.equals;LongPrototype.notEquals=function e(t){return!this.eq(t)};LongPrototype.neq=LongPrototype.notEquals;LongPrototype.ne=LongPrototype.notEquals;LongPrototype.lessThan=function e(t){return this.comp(t)<0};LongPrototype.lt=LongPrototype.lessThan;LongPrototype.lessThanOrEqual=function e(t){return this.comp(t)<=0};LongPrototype.lte=LongPrototype.lessThanOrEqual;LongPrototype.le=LongPrototype.lessThanOrEqual;LongPrototype.greaterThan=function e(t){return this.comp(t)>0};LongPrototype.gt=LongPrototype.greaterThan;LongPrototype.greaterThanOrEqual=function e(t){return this.comp(t)>=0};LongPrototype.gte=LongPrototype.greaterThanOrEqual;LongPrototype.ge=LongPrototype.greaterThanOrEqual;LongPrototype.compare=function e(t){if(!isLong(t))t=fromValue(t);if(this.eq(t))return 0;var n=this.isNegative(),r=t.isNegative();if(n&&!r)return-1;if(!n&&r)return 1;if(!this.unsigned)return this.sub(t).isNegative()?-1:1;return t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1};LongPrototype.comp=LongPrototype.compare;LongPrototype.negate=function e(){if(!this.unsigned&&this.eq(MIN_VALUE))return MIN_VALUE;return this.not().add(ONE)};LongPrototype.neg=LongPrototype.negate;LongPrototype.add=function e(t){if(!isLong(t))t=fromValue(t);var n=this.high>>>16;var r=this.high&65535;var a=this.low>>>16;var s=this.low&65535;var o=t.high>>>16;var i=t.high&65535;var u=t.low>>>16;var l=t.low&65535;var c=0,p=0,m=0,d=0;d+=s+l;m+=d>>>16;d&=65535;m+=a+u;p+=m>>>16;m&=65535;p+=r+i;c+=p>>>16;p&=65535;c+=n+o;c&=65535;return fromBits(m<<16|d,c<<16|p,this.unsigned)};LongPrototype.subtract=function e(t){if(!isLong(t))t=fromValue(t);return this.add(t.neg())};LongPrototype.sub=LongPrototype.subtract;LongPrototype.multiply=function e(t){if(this.isZero())return ZERO;if(!isLong(t))t=fromValue(t);if(wasm){var n=wasm.mul(this.low,this.high,t.low,t.high);return fromBits(n,wasm.get_high(),this.unsigned)}if(t.isZero())return ZERO;if(this.eq(MIN_VALUE))return t.isOdd()?MIN_VALUE:ZERO;if(t.eq(MIN_VALUE))return this.isOdd()?MIN_VALUE:ZERO;if(this.isNegative()){if(t.isNegative())return this.neg().mul(t.neg());else return this.neg().mul(t).neg()}else if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(TWO_PWR_24)&&t.lt(TWO_PWR_24))return fromNumber(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16;var a=this.high&65535;var s=this.low>>>16;var o=this.low&65535;var i=t.high>>>16;var u=t.high&65535;var l=t.low>>>16;var c=t.low&65535;var p=0,m=0,d=0,h=0;h+=o*c;d+=h>>>16;h&=65535;d+=s*c;m+=d>>>16;d&=65535;d+=o*l;m+=d>>>16;d&=65535;m+=a*c;p+=m>>>16;m&=65535;m+=s*l;p+=m>>>16;m&=65535;m+=o*u;p+=m>>>16;m&=65535;p+=r*c+a*l+s*u+o*i;p&=65535;return fromBits(d<<16|h,p<<16|m,this.unsigned)};LongPrototype.mul=LongPrototype.multiply;LongPrototype.divide=function e(t){if(!isLong(t))t=fromValue(t);if(t.isZero())throw Error("division by zero");if(wasm){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1){return this}var n=(this.unsigned?wasm.div_u:wasm.div_s)(this.low,this.high,t.low,t.high);return fromBits(n,wasm.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?UZERO:ZERO;var r,a,s;if(!this.unsigned){if(this.eq(MIN_VALUE)){if(t.eq(ONE)||t.eq(NEG_ONE))return MIN_VALUE;else if(t.eq(MIN_VALUE))return ONE;else{var o=this.shr(1);r=o.div(t).shl(1);if(r.eq(ZERO)){return t.isNegative()?ONE:NEG_ONE}else{a=this.sub(t.mul(r));s=r.add(a.div(t));return s}}}else if(t.eq(MIN_VALUE))return this.unsigned?UZERO:ZERO;if(this.isNegative()){if(t.isNegative())return this.neg().div(t.neg());return this.neg().div(t).neg()}else if(t.isNegative())return this.div(t.neg()).neg();s=ZERO}else{if(!t.unsigned)t=t.toUnsigned();if(t.gt(this))return UZERO;if(t.gt(this.shru(1)))return UONE;s=UZERO}a=this;while(a.gte(t)){r=Math.max(1,Math.floor(a.toNumber()/t.toNumber()));var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:pow_dbl(2,i-48),l=fromNumber(r),c=l.mul(t);while(c.isNegative()||c.gt(a)){r-=u;l=fromNumber(r,this.unsigned);c=l.mul(t)}if(l.isZero())l=ONE;s=s.add(l);a=a.sub(c)}return s};LongPrototype.div=LongPrototype.divide;LongPrototype.modulo=function e(t){if(!isLong(t))t=fromValue(t);if(wasm){var n=(this.unsigned?wasm.rem_u:wasm.rem_s)(this.low,this.high,t.low,t.high);return fromBits(n,wasm.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};LongPrototype.mod=LongPrototype.modulo;LongPrototype.rem=LongPrototype.modulo;LongPrototype.not=function e(){return fromBits(~this.low,~this.high,this.unsigned)};LongPrototype.and=function e(t){if(!isLong(t))t=fromValue(t);return fromBits(this.low&t.low,this.high&t.high,this.unsigned)};LongPrototype.or=function e(t){if(!isLong(t))t=fromValue(t);return fromBits(this.low|t.low,this.high|t.high,this.unsigned)};LongPrototype.xor=function e(t){if(!isLong(t))t=fromValue(t);return fromBits(this.low^t.low,this.high^t.high,this.unsigned)};LongPrototype.shiftLeft=function e(t){if(isLong(t))t=t.toInt();if((t&=63)===0)return this;else if(t<32)return fromBits(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned);else return fromBits(0,this.low<<t-32,this.unsigned)};LongPrototype.shl=LongPrototype.shiftLeft;LongPrototype.shiftRight=function e(t){if(isLong(t))t=t.toInt();if((t&=63)===0)return this;else if(t<32)return fromBits(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned);else return fromBits(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};LongPrototype.shr=LongPrototype.shiftRight;LongPrototype.shiftRightUnsigned=function e(t){if(isLong(t))t=t.toInt();t&=63;if(t===0)return this;else{var n=this.high;if(t<32){var r=this.low;return fromBits(r>>>t|n<<32-t,n>>>t,this.unsigned)}else if(t===32)return fromBits(n,0,this.unsigned);else return fromBits(n>>>t-32,0,this.unsigned)}};LongPrototype.shru=LongPrototype.shiftRightUnsigned;LongPrototype.shr_u=LongPrototype.shiftRightUnsigned;LongPrototype.toSigned=function e(){if(!this.unsigned)return this;return fromBits(this.low,this.high,false)};LongPrototype.toUnsigned=function e(){if(this.unsigned)return this;return fromBits(this.low,this.high,true)};LongPrototype.toBytes=function e(t){return t?this.toBytesLE():this.toBytesBE()};LongPrototype.toBytesLE=function e(){var t=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};LongPrototype.toBytesBE=function e(){var t=this.high,n=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Long$1.fromBytes=function e(t,n,r){return r?Long$1.fromBytesLE(t,n):Long$1.fromBytesBE(t,n)};Long$1.fromBytesLE=function e(t,n){return new Long$1(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};Long$1.fromBytesBE=function e(t,n){return new Long$1(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)};var LongExports=_mergeNamespaces({__proto__:null,default:long},[long]);const Long=long||LongExports;function hexToLong(e){return Long.fromString(e,true,16)}hexToLong("c3a5c85c97cb3127");hexToLong("b492b66fbe98f273");hexToLong("9ae16a3b2f90404f");function createScalarValue(e,t){if(t==="string"){return encodeString(e)}return toTypedArray([e],t)}function noConversionNeeded(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function toTypedArray(e,t){if(t==="string"){throw new Error("Cannot convert a string[] to a TypedArray")}if(Array.isArray(e)){e=flatten(e)}if(env().getBool("DEBUG")){checkConversionForErrors(e,t)}if(noConversionNeeded(e,t)){return e}if(t==null||t==="float32"||t==="complex64"){return new Float32Array(e)}else if(t==="int32"){return new Int32Array(e)}else if(t==="bool"){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n){if(Math.round(e[n])!==0){t[n]=1}}return t}else{throw new Error(`Unknown data type ${t}`)}}function now(){return env().platform.now()}class Profiler{constructor(e,t){this.backendTimer=e;this.logger=t;if(t==null){this.logger=new Logger}}profileKernel(e,t,n){let r;const a=()=>{r=n()};let s;const o=now();if(this.backendTimer.timerAvailable()){s=this.backendTimer.time(a)}else{a();for(const e of r){e.dataSync()}s=Promise.resolve({kernelMs:now()-o})}if(env().getBool("CHECK_COMPUTATION_FOR_ERRORS")){for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{checkComputationForErrors(t,n.dtype,e)}))}}const i={kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>e.getExtraProfileInfo!=null?e.getExtraProfileInfo():""))};return i}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}class Logger{logKernelProfile(e,t,n,r,a,s){const o=typeof r==="number"?rightPad(`${r}ms`,9):r["error"];const i=rightPad(e,25);const u=t.rank;const l=t.size;const c=rightPad(t.shape.toString(),14);let p="";for(const e in a){const n=a[e];if(n!=null){const r=n.shape||t.shape;const a=r.length;p+=`${e}: ${a}D ${a>0?r:""} `}}console.log(`%c${i}\t%c${o}\t%c${u}D ${c}\t%c${l}\t%c${p}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function getFilteredNodesXToY(e,t,n){const r={};const a={};for(let e=0;e<t.length;e++){r[t[e].id]=true}for(let n=0;n<e.length;n++){const s=e[n];const o=s.inputs;for(const e in o){const n=o[e];let i=false;for(let e=0;e<t.length;e++){if(r[n.id]){s.outputs.forEach((e=>r[e.id]=true));i=true;a[s.id]=true;break}}if(i){break}}}const s={};s[n.id]=true;const o={};for(let t=e.length-1;t>=0;t--){const n=e[t];const r=n.inputs;for(let e=0;e<n.outputs.length;e++){if(s[n.outputs[e].id]){for(const e in r){s[r[e].id]=true;o[n.id]=true}break}}}const i=[];for(let t=0;t<e.length;t++){const n=e[t];if(a[n.id]&&o[n.id]){const e={};for(const t in n.inputs){const a=n.inputs[t];if(r[a.id]){e[t]=a}}const t=Object.assign({},n);t.inputs=e;t.outputs=n.outputs;i.push(t)}}return i}class TensorBuffer{constructor(e,t,n){this.dtype=t;this.shape=e.slice();this.size=sizeFromShape(e);if(n!=null){const e=n.length;assert(e===this.size,(()=>`Length of values '${e}' does not match the size `+`inferred by the shape '${this.size}'.`))}if(t==="complex64"){throw new Error(`complex64 dtype TensorBuffers are not supported. Please create `+`a TensorBuffer for the real and imaginary parts separately and `+`call tf.complex(real, imag).`)}this.values=n||getArrayFromDType(t,this.size);this.strides=computeStrides(e)}set(e,...t){if(t.length===0){t=[0]}assert(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must `+`match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){if(e.length===0){e=[0]}let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}. `+`  Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t){n+=this.strides[t]*e[t]}return this.values[n]}locToIndex(e){if(this.rank===0){return 0}else if(this.rank===1){return e[0]}let t=e[e.length-1];for(let n=0;n<e.length-1;++n){t+=this.strides[n]*e[n]}return t}indexToLoc(e){if(this.rank===0){return[]}else if(this.rank===1){return[e]}const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n){t[n]=Math.floor(e/this.strides[n]);e-=t[n]*this.strides[n]}t[t.length-1]=e;return t}get rank(){return this.shape.length}toTensor(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)}}let trackerFn=null;let opHandler$1=null;function setTensorTracker(e){trackerFn=e}function setOpHandler(e){opHandler$1=e}class Tensor{constructor(e,t,n,r){this.kept=false;this.isDisposedInternal=false;this.shape=e.slice();this.dtype=t||"float32";this.size=sizeFromShape(e);this.strides=computeStrides(e);this.dataId=n;this.id=r;this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return opHandler$1.buffer(this.shape,this.dtype,e)}bufferSync(){return opHandler$1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return toNestedArray(this.shape,e,this.dtype==="complex64")}arraySync(){return toNestedArray(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=trackerFn().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map((e=>decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){this.throwIfDisposed();return trackerFn().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=trackerFn().readSync(this.dataId);if(this.dtype==="string"){try{return e.map((e=>decodeString(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. "+"To get the original bytes, call tensor.bytes().")}}return e}async bytes(){this.throwIfDisposed();const e=await trackerFn().read(this.dataId);if(this.dtype==="string"){return e}else{return new Uint8Array(e.buffer)}}dispose(){if(this.isDisposed){return}trackerFn().disposeTensor(this);this.isDisposedInternal=true}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed){throw new Error(`Tensor is disposed.`)}}print(e=false){return opHandler$1.print(this,e)}clone(){this.throwIfDisposed();return opHandler$1.clone(this)}toString(e=false){const t=this.dataSync();return tensorToString(t,this.shape,this.dtype,e)}cast(e){this.throwIfDisposed();return opHandler$1.cast(this,e)}variable(e=true,t,n){this.throwIfDisposed();return trackerFn().makeVariable(this,e,t,n)}}Object.defineProperty(Tensor,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function getGlobalTensorClass(){return getGlobal("Tensor",(()=>Tensor))}getGlobalTensorClass();class Variable extends Tensor{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t;this.name=n}assign(e){if(e.dtype!==this.dtype){throw new Error(`dtype of the new value (${e.dtype}) and `+`previous value (${this.dtype}) must match`)}if(!arraysEqual(e.shape,this.shape)){throw new Error(`shape of the new value (${e.shape}) and `+`previous value (${this.shape}) must match`)}trackerFn().disposeTensor(this);this.dataId=e.dataId;trackerFn().incRef(this,null)}dispose(){trackerFn().disposeVariable(this);this.isDisposedInternal=true}}Object.defineProperty(Variable,Symbol.hasInstance,{value:e=>e instanceof Tensor&&e.assign!=null&&e.assign instanceof Function});var Rank;(function(e){e["R0"]="R0";e["R1"]="R1";e["R2"]="R2";e["R3"]="R3";e["R4"]="R4";e["R5"]="R5";e["R6"]="R6"})(Rank||(Rank={}));var UpcastInt32AndMap;(function(e){e["float32"]="float32";e["int32"]="int32";e["bool"]="int32";e["complex64"]="complex64"})(UpcastInt32AndMap||(UpcastInt32AndMap={}));var UpcastBoolAndMap;(function(e){e["float32"]="float32";e["int32"]="int32";e["bool"]="bool";e["complex64"]="complex64"})(UpcastBoolAndMap||(UpcastBoolAndMap={}));var UpcastFloat32AndMap;(function(e){e["float32"]="float32";e["int32"]="float32";e["bool"]="float32";e["complex64"]="complex64"})(UpcastFloat32AndMap||(UpcastFloat32AndMap={}));var UpcastComplex64AndMap;(function(e){e["float32"]="complex64";e["int32"]="complex64";e["bool"]="complex64";e["complex64"]="complex64"})(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));const upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string"){return"string"}throw new Error(`Can not upcast ${e} with ${t}`)}return upcastTypeMap[e][t]}function sumOutType(e){return upcastType(e,"int32")}function makeTypesMatch(e,t){if(e.dtype===t.dtype){return[e,t]}const n=upcastType(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function getTensorsInContainer(e){const t=[];const n=new Set;walkTensorContainer(e,t,n);return t}function walkTensorContainer(e,t,n){if(e==null){return}if(e instanceof Tensor){t.push(e);return}if(!isIterable(e)){return}const r=e;for(const e in r){const a=r[e];if(!n.has(a)){n.add(a);walkTensorContainer(a,t,n)}}}function isIterable(e){return Array.isArray(e)||typeof e==="object"}function isRegisteredKernelInvocation(e){return e.kernelName!=null}class EngineState{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=false;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables){this.registeredVariables[e].dispose()}}}class Engine{constructor(e){this.ENV=e;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new EngineState}async ready(){if(this.pendingBackendInit!=null){return this.pendingBackendInit.then((()=>{}))}if(this.backendInstance!=null){return}const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];const r=await this.initializeBackend(n).success;if(r){await this.setBackend(n);return}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}get backend(){if(this.pendingBackendInit!=null){throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make `+`sure to await tf.ready() or await tf.setBackend() before calling `+`other methods`)}if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t){throw new Error(`The highest priority backend '${e}' has not yet been `+`initialized. Make sure to await tf.ready() or `+`await tf.setBackend() before calling other methods`)}this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t){return null}}else{return null}}return this.registry[e]}findBackendFactory(e){if(!(e in this.registryFactory)){return null}return this.registryFactory[e].factory}registerBackend(e,t,n=1){if(e in this.registryFactory){warn(`${e} backend was already registered. `+`Reusing existing backend factory.`);return false}this.registryFactory[e]={factory:t,priority:n};return true}async setBackend(e){if(this.registryFactory[e]==null){throw new Error(`Backend name '${e}' not found in registry`)}this.backendName=e;if(this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);const r=n?await t:t;if(!r){return false}}this.backendInstance=this.registry[e];this.setupRegisteredKernels();this.profiler=new Profiler(this.backendInstance);return true}setupRegisteredKernels(){const e=getKernelsForBackend(this.backendName);e.forEach((e=>{if(e.setupFunc!=null){e.setupFunc(this.backendInstance)}}))}disposeRegisteredKernels(e){const t=getKernelsForBackend(e);t.forEach((t=>{if(t.disposeFunc!=null){t.disposeFunc(this.registry[e])}}))}initializeBackend(e){const t=this.registryFactory[e];if(t==null){throw new Error(`Cannot initialize backend ${e}, no registration found.`)}try{const n=t.factory();if(n&&!(n instanceof KernelBackend)&&typeof n.then==="function"){const t=++this.pendingBackendInitId;const r=n.then((n=>{if(t<this.pendingBackendInitId){return false}this.registry[e]=n;this.pendingBackendInit=null;return true})).catch((n=>{if(t<this.pendingBackendInitId){return false}this.pendingBackendInit=null;warn(`Initialization of backend ${e} failed`);warn(n.stack||n.message);return false}));this.pendingBackendInit=r;return{success:r,asyncInit:true}}else{this.registry[e]=n;return{success:true,asyncInit:false}}}catch(t){warn(`Initialization of backend ${e} failed`);warn(t.stack||t.message);return{success:false,asyncInit:false}}}removeBackend(e){if(!(e in this.registryFactory)){throw new Error(`${e} backend not found in registry`)}if(this.backendName===e&&this.pendingBackendInit!=null){this.pendingBackendInitId++}if(e in this.registry){this.disposeRegisteredKernels(e);this.registry[e].dispose();delete this.registry[e]}delete this.registryFactory[e];if(this.backendName===e){this.pendingBackendInit=null;this.backendName=null;this.backendInstance=null}}getSortedBackends(){if(Object.keys(this.registryFactory).length===0){throw new Error("No backend found in registry.")}return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];const{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r){return{name:n,asyncInit:a}}}throw new Error(`Could not initialize any backends, all backend initializations `+`failed.`)}moveData(e,t){const n=this.state.tensorInfo.get(t);const r=n.backend;const a=this.readSync(t);const s=r.refCount(t);r.disposeData(t,true);n.backend=e;e.move(t,a,n.shape,n.dtype,s);if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}}tidy(e,t){let n=null;if(t==null){if(typeof e!=="function"){throw new Error("Please provide a function to tidy()")}t=e}else{if(typeof e!=="string"&&!(e instanceof String)){throw new Error("When calling with two arguments, the first argument "+"to tidy() must be a string")}if(typeof t!=="function"){throw new Error("When calling with two arguments, the 2nd argument "+"to tidy() must be a function")}n=e}let r;return this.scopedRun((()=>this.startScope(n)),(()=>this.endScope(r)),(()=>{r=t();if(r instanceof Promise){console.error("Cannot return a Promise inside of tidy.")}return r}))}scopedRun(e,t,n){e();try{const e=n();t();return e}catch(e){t();throw e}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(e){const t=ENGINE.runKernel(Identity,{x:e});const n={x:e};const r=e=>({x:()=>{const t="float32";const n={x:e};const r={dtype:t};return ENGINE.runKernel(Cast,n,r)}});const a=[];this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{});return t}runKernel(e,t,n){if(this.backendName==null){this.backend}const r=getKernel(e,this.backendName)!=null;if(!r){throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`)}return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+=e.dtype==="complex64"?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];const o=r-t-a-s;if(o>0){throw new Error(`Backend '${this.backendName}' has an internal memory leak `+`(${o} data ids) after running '${e}'`)}}runKernelFunc(e){let t;let n=[];const r=this.isTapeOn();const a=this.state.numBytes;const s=this.state.numTensors;if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack.push(0)}let o;if(this.backendName==null){this.backend}let i;const u=isRegisteredKernelInvocation(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(e)){const{kernelName:t,inputs:a,attrs:s}=e;if(this.backendName==null){this.backend}const u=getKernel(t,this.backendName);assert(u!=null,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`));o=()=>{const e=this.backend.numDataIds();i=u.kernelFunc({inputs:a,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(t,e,o)}const l=o.map((e=>{if(e.rank!=null){return e}return this.makeTensorFromTensorInfo(e)}));if(r){const e=this.getTensorsForGradient(t,a,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e;const a=e=>{if(!r){return}n=e.map((e=>this.keep(this.clone(e))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(i)?i:[i];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(u,e,n)}return n}}const{inputs:l,attrs:c}=e;const p=isRegisteredKernelInvocation(e)?null:e.backwardsFunc;let m;this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{if(!this.ENV.getBool("DEBUG")&&!this.state.profiling){t=o()}else{m=this.profiler.profileKernel(u,l,(()=>o()));if(this.ENV.getBool("DEBUG")){this.profiler.logKernelProfile(m)}t=m.outputs}}));if(r){this.addTapeNode(u,l,t,p,n,c)}if(this.state.profiling){this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>l[e]!=null?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo})}return Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=getGradient(e);if(r!=null){const e=r.inputsToSave||[];const a=r.outputsToSave||[];let s;if(r.saveAllInputs){assert(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array."));s=Object.keys(t).map((e=>t[e]))}else{s=e.map((e=>t[e]))}const o=n.filter(((e,t)=>a[t]));return s.concat(o)}return[]}makeTensor(e,t,n,r){if(e==null){throw new Error("Values passed to engine.makeTensor() are null")}n=n||"float32";r=r||this.backend;let a=e;if(n==="string"&&isString(e[0])){a=e.map((e=>encodeString(e)))}const s=r.write(a,t,n);const o=new Tensor(t,n,s,this.nextTensorId());this.trackTensor(o,r);if(n==="string"){const e=this.state.tensorInfo.get(s);const t=bytesFromStringArray(a);this.state.numBytes+=t-e.bytes;e.bytes=t}return o}makeTensorFromDataId(e,t,n,r){n=n||"float32";const a={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e;const s=new Tensor(r,a,n,this.nextTensorId());this.trackTensor(s,t);return s}makeVariable(e,t=true,n,r){n=n||this.nextVariableId().toString();if(r!=null&&r!==e.dtype){e=e.cast(r)}const a=new Variable(e,t,n,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null){throw new Error(`Variable with name ${a.name} was already registered`)}this.state.registeredVariables[a.name]=a;this.incRef(a,this.backend);return a}trackTensor(e,t){this.state.numTensors++;if(e.dtype==="string"){this.state.numStringTensors++}let n=0;if(e.dtype!=="complex64"&&e.dtype!=="string"){n=e.size*bytesPerElement(e.dtype)}this.state.numBytes+=n;if(!this.state.tensorInfo.has(e.dataId)){this.state.numDataBuffers++;this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})}if(!(e instanceof Variable)){this.track(e)}}incRef(e,t){this.trackTensor(e,t);this.backend.incRef(e.dataId)}removeDataId(e,t){if(this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t){this.state.tensorInfo.delete(e);this.state.numDataBuffers--}}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId)){return}const t=this.state.tensorInfo.get(e.dataId);this.state.numTensors--;if(e.dtype==="string"){this.state.numStringTensors--;this.state.numBytes-=t.bytes}if(e.dtype!=="complex64"&&e.dtype!=="string"){const t=e.size*bytesPerElement(e.dtype);this.state.numBytes-=t}if(t.backend.disposeData(e.dataId)){this.removeDataId(e.dataId,t.backend)}}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e);if(this.state.registeredVariables[e.name]!=null){delete this.state.registeredVariables[e.name]}}memory(){const e=this.backend.memory();e.numTensors=this.state.numTensors;e.numDataBuffers=this.state.numDataBuffers;e.numBytes=this.state.numBytes;if(this.state.numStringTensors>0){e.unreliable=true;if(e.reasons==null){e.reasons=[]}e.reasons.push("Memory usage by string tensors is approximate "+"(2 bytes per character)")}return e}async profile(e){this.state.profiling=true;const t=this.state.numBytes;const n=this.state.numTensors;this.state.activeProfile.kernels=[];this.state.activeProfile.result=await e();this.state.profiling=false;this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot)));this.state.activeProfile.newBytes=this.state.numBytes-t;this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels){e.kernelTimeMs=await e.kernelTimeMs;e.extraInfo=await e.extraInfo}return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,a,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a};const i=getGradient(e);if(i!=null){r=i.gradFunc}if(r!=null){o.gradient=e=>{e=e.map(((e,t)=>{if(e==null){const e=n[t];const r=makeZerosTypedArray(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}));return r(e.length>1?e:e[0],a,s)}}this.state.activeTape.push(o)}keep(e){e.kept=true;return e}startTape(){if(this.state.gradientDepth===0){this.state.activeTape=[]}this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};if(e){t.name=e}this.state.scopeStack.push(t);this.state.activeScope=t}endScope(e){const t=getTensorsInContainer(e);const n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];if(!t.kept&&!n.has(t.id)){t.dispose()}}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1];t.forEach((e=>{if(!e.kept&&e.scopeId===r.id){this.track(e)}}))}gradients(e,t,n,r=false){assert(t.length>0,(()=>"gradients() received an empty list of xs."));if(n!=null&&n.dtype!=="float32"){throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`)}const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));assert(a instanceof Tensor,(()=>"The result y returned by f() must be a tensor."));const s=getFilteredNodesXToY(this.state.activeTape,t,a);if(!r&&s.length===0&&t.length>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure "+"that the f you passed encloses all operations that lead from x "+"to y.")}return this.tidy("backward",(()=>{const e={};e[a.id]=n==null?ones$1(a.shape):n;backpropagateGradients(e,s,(e=>this.tidy(e)),add$1);const r=t.map((t=>e[t.id]));if(this.state.gradientDepth===0){this.state.activeTape.forEach((e=>{for(const t of e.saved){t.dispose()}}));this.state.activeTape=null}return{value:a,grads:r}}))}customGrad(e){assert(isFunction(e),(()=>"The f passed in customGrad(f) must be a function."));return(...t)=>{assert(t.every((e=>e instanceof Tensor)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be "+"tensors"));let n;const r={};t.forEach(((e,t)=>{r[t]=e}));const a=(r,a)=>{n=e(...[...t,a]);assert(n.value instanceof Tensor,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.value` is a tensor"));assert(isFunction(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function."));return n.value};const s=(e,r)=>{const a=n.gradFunc(e,r);const s=Array.isArray(a)?a:[a];assert(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"the same number of tensors as inputs passed to f(...)."));assert(s.every((e=>e instanceof Tensor)),(()=>"The function f passed in customGrad(f) must return an "+"object where `obj.gradFunc` is a function that returns "+"a list of only tensors."));const o={};s.forEach(((e,t)=>{o[t]=()=>e}));return o};return this.runKernelFunc({forwardFunc:a,backwardsFunc:s,inputs:r})}}readSync(e){const t=this.state.tensorInfo.get(e);return t.backend.readSync(e)}read(e){const t=this.state.tensorInfo.get(e);return t.backend.read(e)}readToGPU(e,t){const n=this.state.tensorInfo.get(e);return n.backend.readToGPU(e,t)}async time(e){const t=now();const n=await this.backend.time(e);n.wallMs=now()-t;return n}track(e){if(this.state.activeScope!=null){e.scopeId=this.state.activeScope.id;this.state.activeScope.track.push(e)}return e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++;this.state.dispose();this.ENV.reset();this.state=new EngineState;for(const e in this.registry){this.disposeRegisteredKernels(e);this.registry[e].dispose();delete this.registry[e]}this.backendName=null;this.backendInstance=null;this.pendingBackendInit=null}}Engine.nextTensorId=0;Engine.nextVariableId=0;function ones$1(e){const t=makeOnesTypedArray(sizeFromShape(e),"float32");return ENGINE.makeTensor(t,e,"float32")}function getOrMakeEngine(){const e=getGlobalNamespace();if(e._tfengine==null){const t=new Environment(e);e._tfengine=new Engine(t)}setEnvironmentGlobal(e._tfengine.ENV);setTensorTracker((()=>e._tfengine));return e._tfengine}const ENGINE=getOrMakeEngine();function add$1(e,t){const n={a:e,b:t};return ENGINE.runKernel(Add,n)}function _isNavigatorDefined(){return typeof navigator!=="undefined"&&navigator!=null}function isMobile(e){if(e||_isNavigatorDefined()){if(!e){e=navigator}if(e.product==="ReactNative"){return true}const t=e.userAgent||e.vendor||(typeof window!=="undefined"?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return false}function isBrowser(){return typeof window!=="undefined"&&window.document!=null||typeof WorkerGlobalScope!=="undefined"}const ENV$2=env();ENV$2.registerFlag("DEBUG",(()=>false),(e=>{if(e){console.warn("Debugging mode is ON. The output of every math call will "+"be downloaded to CPU and checked for NaNs. "+"This significantly impacts performance.")}}));ENV$2.registerFlag("IS_BROWSER",(()=>isBrowser()));ENV$2.registerFlag("IS_NODE",(()=>typeof process!=="undefined"&&typeof process.versions!=="undefined"&&typeof process.versions.node!=="undefined"));ENV$2.registerFlag("IS_CHROME",(()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)));ENV$2.registerFlag("PROD",(()=>false));ENV$2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ENV$2.getBool("DEBUG")));ENV$2.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>true));ENV$2.registerFlag("IS_TEST",(()=>false));ENV$2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>true));ENV$2.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>false));ENV$2.registerFlag("ENGINE_COMPILE_ONLY",(()=>false));function inferShape(e,t){let n=e;if(isTypedArray(e)){return t==="string"?[]:[e.length]}if(!Array.isArray(e)){return[]}const r=[];while(Array.isArray(n)||isTypedArray(n)&&t!=="string"){r.push(n.length);n=n[0]}if(Array.isArray(e)&&env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")){deepAssertShapeConsistency(e,r,[])}return r}function assertDtype(e,t,n,r){if(e==="string_or_numeric"){return}if(e==null){throw new Error(`Expected dtype cannot be null.`)}if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string"){throw new Error(`Argument '${n}' passed to '${r}' must `+`be ${e} tensor, but got ${t} tensor`)}}function convertToTensor(e,t,n,r="numeric"){if(e instanceof Tensor){assertDtype(r,e.dtype,t,n);return e}let a=inferDtype(e);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0){a=r}assertDtype(r,a,t,n);if(e==null||!isTypedArray(e)&&!Array.isArray(e)&&typeof e!=="number"&&typeof e!=="boolean"&&typeof e!=="string"){const r=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a `+`Tensor or TensorLike, but got '${r}'`)}const s=inferShape(e,a);if(!isTypedArray(e)&&!Array.isArray(e)){e=[e]}const o=true;const i=a!=="string"?toTypedArray(e,a):flatten(e,[],o);return ENGINE.makeTensor(i,s,a)}function convertToTensorArray(e,t,n,r="numeric"){if(!Array.isArray(e)){throw new Error(`Argument ${t} passed to ${n} must be a `+"`Tensor[]` or `TensorLike[]`")}const a=e;return a.map(((e,a)=>convertToTensor(e,`${t}[${a}]`,n,r)))}const OP_SCOPE_SUFFIX="__op";function op(e){const t=Object.keys(e);if(t.length!==1){throw new Error(`Please provide an object with a single key `+`(operation name) mapping to a function. Got an object with `+`${t.length} keys.`)}let n=t[0];const r=e[n];if(n.endsWith("_")){n=n.substring(0,n.length-1)}n=n+OP_SCOPE_SUFFIX;const a=(...e)=>{ENGINE.startScope(n);try{const t=r(...e);if(isPromise(t)){console.error("Cannot return a Promise inside of tidy.")}ENGINE.endScope(t);return t}catch(e){ENGINE.endScope(null);throw e}};Object.defineProperty(a,"name",{value:n,configurable:true});return a}function complex_(e,t){const n=convertToTensor(e,"real","complex");const r=convertToTensor(t,"imag","complex");assertShapesMatch(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, `+`must match in call to tf.complex().`);const a={real:n,imag:r};return ENGINE.runKernel(Complex,a)}const complex$1=op({complex_:complex_});function makeTensor(e,t,n,r){if(r==null){r=inferDtype(e)}if(r==="complex64"){throw new Error(`Cannot construct a complex64 tensor directly. `+`Please use tf.complex(real, imag).`)}if(!isTypedArray(e)&&!Array.isArray(e)&&typeof e!=="number"&&typeof e!=="boolean"&&typeof e!=="string"){throw new Error("values passed to tensor(values) must be a number/boolean/string or "+"an array of numbers/booleans/strings, or a TypedArray")}if(t!=null){assertNonNegativeIntegerDimensions(t);const e=sizeFromShape(t);const r=sizeFromShape(n);assert(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have `+`${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e];const a=e===n.length-1?r!==sizeFromShape(t.slice(e)):true;assert(n[e]===t[e]||!a,(()=>`Error creating a new Tensor. Inferred shape `+`(${n}) does not match the provided `+`shape (${t}). `))}}if(!isTypedArray(e)&&!Array.isArray(e)){e=[e]}t=t||n;e=r!=="string"?toTypedArray(e,r):flatten(e,[],true);return ENGINE.makeTensor(e,t,r)}function tensor(e,t,n){const r=inferShape(e,n);return makeTensor(e,t,r,n)}const DTYPE_VALUE_SIZE_MAP={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const NUM_BYTES_STRING_LENGTH=4;function decodeWeights(e,t){const n={};let r;let a=0;for(const s of t){const t=s.name;const o=s.dtype;const i=s.shape;const u=sizeFromShape(i);let l;if("quantization"in s){const n=s.quantization;if(n.dtype==="uint8"||n.dtype==="uint16"){if(!("min"in n&&"scale"in n)){throw new Error(`Weight ${s.name} with quantization ${n.dtype} `+`doesn't have corresponding metadata min and scale.`)}}else if(n.dtype==="float16"){if(o!=="float32"){throw new Error(`Weight ${s.name} is quantized with ${n.dtype} `+`which only supports weights of type float32 not ${o}.`)}}else{throw new Error(`Weight ${s.name} has unknown `+`quantization dtype ${n.dtype}. `+`Supported quantization dtypes are: `+`'uint8', 'uint16', and 'float16'.`)}const i=DTYPE_VALUE_SIZE_MAP[n.dtype];const c=e.slice(a,a+u*i);const p=n.dtype==="uint8"?new Uint8Array(c):new Uint16Array(c);if(o==="float32"){if(n.dtype==="uint8"||n.dtype==="uint16"){l=new Float32Array(p.length);for(let e=0;e<p.length;e++){const t=p[e];l[e]=t*n.scale+n.min}}else if(n.dtype==="float16"){if(r===undefined){r=getFloat16Decoder()}l=r(p)}else{throw new Error(`Unsupported quantization type ${n.dtype} `+`for weight type float32.`)}}else if(o==="int32"){if(n.dtype!=="uint8"&&n.dtype!=="uint16"){throw new Error(`Unsupported quantization type ${n.dtype} `+`for weight type int32.`)}l=new Int32Array(p.length);for(let e=0;e<p.length;e++){const t=p[e];l[e]=Math.round(t*n.scale+n.min)}}else{throw new Error(`Unsupported dtype in weight '${t}': ${o}`)}a+=u*i}else if(o==="string"){const t=sizeFromShape(s.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(a,a+NUM_BYTES_STRING_LENGTH))[0];a+=NUM_BYTES_STRING_LENGTH;const n=new Uint8Array(e.slice(a,a+t));l.push(n);a+=t}}else{const r=DTYPE_VALUE_SIZE_MAP[o];const s=e.slice(a,a+u*r);if(o==="float32"){l=new Float32Array(s)}else if(o==="int32"){l=new Int32Array(s)}else if(o==="bool"){l=new Uint8Array(s)}else if(o==="complex64"){l=new Float32Array(s);const e=new Float32Array(l.length/2);const r=new Float32Array(l.length/2);for(let t=0;t<e.length;t++){e[t]=l[t*2];r[t]=l[t*2+1]}const a=tensor(e,i,"float32");const o=tensor(r,i,"float32");n[t]=complex$1(a,o);a.dispose();o.dispose()}else{throw new Error(`Unsupported dtype in weight '${t}': ${o}`)}a+=u*r}if(o!=="complex64"){n[t]=tensor(l,i,o)}}return n}function getModelJSONForModelArtifacts(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};if(e.signature!=null){n.signature=e.signature}if(e.userDefinedMetadata!=null){n.userDefinedMetadata=e.userDefinedMetadata}if(e.modelInitializer!=null){n.modelInitializer=e.modelInitializer}if(e.trainingConfig!=null){n.trainingConfig=e.trainingConfig}return n}async function getModelArtifactsForJSON(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null){n.trainingConfig=e.trainingConfig}if(e.weightsManifest!=null){const[r,a]=await t(e.weightsManifest);n.weightSpecs=r;n.weightData=a}if(e.signature!=null){n.signature=e.signature}if(e.userDefinedMetadata!=null){n.userDefinedMetadata=e.userDefinedMetadata}if(e.modelInitializer!=null){n.modelInitializer=e.modelInitializer}return n}function getModelArtifactsInfoForJSON(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("Expected JSON model topology, received ArrayBuffer.")}return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:stringByteLength(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:stringByteLength(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}class IORouterRegistry{constructor(){this.saveRouters=[];this.loadRouters=[]}static getInstance(){if(IORouterRegistry.instance==null){IORouterRegistry.instance=new IORouterRegistry}return IORouterRegistry.instance}static registerSaveRouter(e){IORouterRegistry.getInstance().saveRouters.push(e)}static registerLoadRouter(e){IORouterRegistry.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return IORouterRegistry.getHandlers(e,"save")}static getLoadHandlers(e,t){return IORouterRegistry.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];const a=t==="load"?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters;a.forEach((t=>{const a=t(e,n);if(a!==null){r.push(a)}}));return r}}const registerSaveRouter=e=>IORouterRegistry.registerSaveRouter(e);const registerLoadRouter=e=>IORouterRegistry.registerLoadRouter(e);const getSaveHandlers=e=>IORouterRegistry.getSaveHandlers(e);const getLoadHandlers=(e,t)=>IORouterRegistry.getLoadHandlers(e,t);const DATABASE_NAME$1="tensorflowjs";const DATABASE_VERSION=1;const MODEL_STORE_NAME="models_store";const INFO_STORE_NAME="model_info_store";class BrowserIndexedDB{constructor(e){this.indexedDB=getIndexedDBFactory();if(e==null||!e){throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")}this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(DATABASE_NAME$1,DATABASE_VERSION);r.onupgradeneeded=()=>setUpDatabase(r);r.onsuccess=()=>{const a=r.result;if(t==null){const t=a.transaction(MODEL_STORE_NAME,"readonly");const r=t.objectStore(MODEL_STORE_NAME);const s=r.get(this.modelPath);s.onsuccess=()=>{if(s.result==null){a.close();return n(new Error(`Cannot find model with path '${this.modelPath}' `+`in IndexedDB.`))}else{e(s.result.modelArtifacts)}};s.onerror=e=>{a.close();return n(s.error)};t.oncomplete=()=>a.close()}else{const r=getModelArtifactsInfoForJSON(t);const s=a.transaction(INFO_STORE_NAME,"readwrite");let o=s.objectStore(INFO_STORE_NAME);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;i.onsuccess=()=>{u=a.transaction(MODEL_STORE_NAME,"readwrite");const i=u.objectStore(MODEL_STORE_NAME);const l=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});l.onsuccess=()=>e({modelArtifactsInfo:r});l.onerror=e=>{o=s.objectStore(INFO_STORE_NAME);const t=o.delete(this.modelPath);t.onsuccess=()=>{a.close();return n(l.error)};t.onerror=e=>{a.close();return n(l.error)}}};i.onerror=e=>{a.close();return n(i.error)};s.oncomplete=()=>{if(u==null){a.close()}else{u.oncomplete=()=>a.close()}}}};r.onerror=e=>n(r.error)}))}}BrowserIndexedDB.URL_SCHEME="indexeddb://";const indexedDBRouter=e=>{if(!env().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(e)&&e.startsWith(BrowserIndexedDB.URL_SCHEME)){return browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length))}else{return null}}};IORouterRegistry.registerSaveRouter(indexedDBRouter);IORouterRegistry.registerLoadRouter(indexedDBRouter);class BrowserIndexedDBManager{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(DATABASE_NAME$1,DATABASE_VERSION);n.onupgradeneeded=()=>setUpDatabase(n);n.onsuccess=()=>{const r=n.result;const a=r.transaction(INFO_STORE_NAME,"readonly");const s=a.objectStore(INFO_STORE_NAME);const o=s.getAll();o.onsuccess=()=>{const t={};for(const e of o.result){t[e.modelPath]=e.modelArtifactsInfo}e(t)};o.onerror=e=>{r.close();return t(o.error)};a.oncomplete=()=>r.close()};n.onerror=e=>t(n.error)}))}async removeModel(e){e=maybeStripScheme$1(e);return new Promise(((t,n)=>{const r=this.indexedDB.open(DATABASE_NAME$1,DATABASE_VERSION);r.onupgradeneeded=()=>setUpDatabase(r);r.onsuccess=()=>{const a=r.result;const s=a.transaction(INFO_STORE_NAME,"readwrite");const o=s.objectStore(INFO_STORE_NAME);const i=o.get(e);let u;i.onsuccess=()=>{if(i.result==null){a.close();return n(new Error(`Cannot find model with path '${e}' `+`in IndexedDB.`))}else{const r=o.delete(e);const s=()=>{u=a.transaction(MODEL_STORE_NAME,"readwrite");const r=u.objectStore(MODEL_STORE_NAME);const s=r.delete(e);s.onsuccess=()=>t(i.result.modelArtifactsInfo);s.onerror=e=>n(i.error)};r.onsuccess=s;r.onerror=e=>{s();a.close();return n(i.error)}}};i.onerror=e=>{a.close();return n(i.error)};s.oncomplete=()=>{if(u==null){a.close()}else{u.oncomplete=()=>a.close()}}};r.onerror=e=>n(r.error)}))}}const PATH_SEPARATOR="/";const PATH_PREFIX="tensorflowjs_models";const INFO_SUFFIX="info";const MODEL_TOPOLOGY_SUFFIX="model_topology";const WEIGHT_SPECS_SUFFIX="weight_specs";const WEIGHT_DATA_SUFFIX="weight_data";const MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(e){return{info:[PATH_PREFIX,e,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,e,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,e,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,e,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,e,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function removeItems(e){for(const t of Object.values(e)){window.localStorage.removeItem(t)}}function getModelPathFromKey(e){const t=e.split(PATH_SEPARATOR);if(t.length<3){throw new Error(`Invalid key format: ${e}`)}return t.slice(1,t.length-1).join(PATH_SEPARATOR)}class BrowserLocalStorage{constructor(e){if(!env().getBool("IS_BROWSER")||typeof window==="undefined"||typeof window.localStorage==="undefined"){throw new Error("The current environment does not support local storage.")}this.LS=window.localStorage;if(e==null||!e){throw new Error("For local storage, modelPath must not be null, undefined or empty.")}this.modelPath=e;this.keys=getModelKeys(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology "+"in binary formats yet.")}else{const t=JSON.stringify(e.modelTopology);const n=JSON.stringify(e.weightSpecs);const r=getModelArtifactsInfoForJSON(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r));this.LS.setItem(this.keys.topology,t);this.LS.setItem(this.keys.weightSpecs,n);this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:undefined,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:undefined,modelInitializer:e.modelInitializer!=null?e.modelInitializer:undefined,trainingConfig:e.trainingConfig!=null?e.trainingConfig:undefined};this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a));return{modelArtifactsInfo:r}}catch(e){removeItems(this.keys);throw new Error(`Failed to save model '${this.modelPath}' to local storage: `+`size quota being exceeded is a possible cause of this failure: `+`modelTopologyBytes=${r.modelTopologyBytes}, `+`weightSpecsBytes=${r.weightSpecsBytes}, `+`weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null){throw new Error(`In local storage, there is no model with name '${this.modelPath}'`)}if(e.modelTopologyType!=="JSON"){throw new Error("BrowserLocalStorage does not support loading non-JSON model "+"topology yet.")}const t={};const n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null){throw new Error(`In local storage, the topology of model '${this.modelPath}' `+`is missing.`)}t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null){throw new Error(`In local storage, the weight specs of model '${this.modelPath}' `+`are missing.`)}t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const e=JSON.parse(a);t.format=e.format;t.generatedBy=e.generatedBy;t.convertedBy=e.convertedBy;if(e.signature!=null){t.signature=e.signature}if(e.userDefinedMetadata!=null){t.userDefinedMetadata=e.userDefinedMetadata}if(e.modelInitializer!=null){t.modelInitializer=e.modelInitializer}if(e.trainingConfig!=null){t.trainingConfig=e.trainingConfig}}const s=this.LS.getItem(this.keys.weightData);if(s==null){throw new Error(`In local storage, the binary weight values of model `+`'${this.modelPath}' are missing.`)}t.weightData=base64StringToArrayBuffer(s);return t}}BrowserLocalStorage.URL_SCHEME="localstorage://";const localStorageRouter=e=>{if(!env().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(e)&&e.startsWith(BrowserLocalStorage.URL_SCHEME)){return browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length))}else{return null}}};IORouterRegistry.registerSaveRouter(localStorageRouter);IORouterRegistry.registerLoadRouter(localStorageRouter);class BrowserLocalStorageManager{constructor(){assert(env().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser"));assert(typeof window==="undefined"||typeof window.localStorage!=="undefined",(()=>"Current browser does not appear to support localStorage"));this.LS=window.localStorage}async listModels(){const e={};const t=PATH_PREFIX+PATH_SEPARATOR;const n=PATH_SEPARATOR+INFO_SUFFIX;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){const t=getModelPathFromKey(a);e[t]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=maybeStripScheme(e);const t=getModelKeys(e);if(this.LS.getItem(t.info)==null){throw new Error(`Cannot find model at path '${e}'`)}const n=JSON.parse(this.LS.getItem(t.info));removeItems(t);return n}}const URL_SCHEME_SUFFIX="://";class ModelStoreManagerRegistry{constructor(){this.managers={}}static getInstance(){if(ModelStoreManagerRegistry.instance==null){ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry}return ModelStoreManagerRegistry.instance}static registerManager(e,t){assert(e!=null,(()=>"scheme must not be undefined or null."));if(e.endsWith(URL_SCHEME_SUFFIX)){e=e.slice(0,e.indexOf(URL_SCHEME_SUFFIX))}assert(e.length>0,(()=>"scheme must not be an empty string."));const n=ModelStoreManagerRegistry.getInstance();assert(n.managers[e]==null,(()=>`A model store manager is already registered for scheme '${e}'.`));n.managers[e]=t}static getManager(e){const t=ModelStoreManagerRegistry.getInstance().managers[e];if(t==null){throw new Error(`Cannot find model manager for scheme '${e}'`)}return t}static getSchemes(){return Object.keys(ModelStoreManagerRegistry.getInstance().managers)}}class PlatformBrowser{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8"){throw new Error(`Browser's encoder only supports utf-8, but got ${t}`)}if(this.textEncoder==null){this.textEncoder=new TextEncoder}return this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(env().get("IS_BROWSER")){env().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch(e){}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch(e){}}function buffer(e,t="float32",n){t=t||"float32";assertNonNegativeIntegerDimensions(e);return new TensorBuffer(e,t,n)}function cast_(e,t){const n=convertToTensor(e,"x","cast");if(!isValidDtype(t)){throw new Error(`Failed to cast to unknown dtype ${t}`)}if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string"){throw new Error("Only strings can be casted to strings")}const r={x:n};const a={dtype:t};return ENGINE.runKernel(Cast,r,a)}const cast$1=op({cast_:cast_});function clone_(e){const t=convertToTensor(e,"x","clone","string_or_numeric");const n={x:t};return ENGINE.runKernel(Identity,n)}const clone=op({clone_:clone_});function print$1(e,t=false){console.log(e.toString(t))}getOrMakeEngine();const opHandler={buffer:buffer,cast:cast$1,clone:clone,print:print$1};setOpHandler(opHandler);const DEFAULT_FILE_NAME_PREFIX="model";const DEFAULT_JSON_EXTENSION_NAME=".json";const DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";class BrowserDownloads{constructor(e){if(!env().getBool("IS_BROWSER")){throw new Error("browserDownloads() cannot proceed because the current environment "+"is not a browser.")}if(e.startsWith(BrowserDownloads.URL_SCHEME)){e=e.slice(BrowserDownloads.URL_SCHEME.length)}if(e==null||e.length===0){e=DEFAULT_FILE_NAME_PREFIX}this.modelJsonFileName=e+DEFAULT_JSON_EXTENSION_NAME;this.weightDataFileName=e+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}async save(e){if(typeof document==="undefined"){throw new Error("Browser downloads are not supported in "+"this environment since `document` is not present")}const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer){throw new Error("BrowserDownloads.save() does not support saving model topology "+"in binary formats yet.")}else{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}];const r=getModelJSONForModelArtifacts(e,n);const a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"}));const s=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;s.download=this.modelJsonFileName;s.href=a;await defer((()=>s.dispatchEvent(new MouseEvent("click"))));if(e.weightData!=null){const e=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName;e.href=t;await defer((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}}}}BrowserDownloads.URL_SCHEME="downloads://";const browserDownloadsRouter=e=>{if(!env().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(e)&&e.startsWith(BrowserDownloads.URL_SCHEME)){return browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length))}else{return null}}};IORouterRegistry.registerSaveRouter(browserDownloadsRouter);function weightsLoaderFactory(e){return async(t,n="",r)=>{const a=t.map((()=>false));const s={};const o=r!=null?r.map((()=>false)):[];const i=[];t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const u="quantization"in e?e.quantization.dtype:e.dtype;const l=DTYPE_VALUE_SIZE_MAP[u]*sizeFromShape(e.shape);const c=()=>{a[t]=true;if(s[t]==null){s[t]=[]}s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};if(r!=null){r.forEach(((t,n)=>{if(t===e.name){c();o[n]=true}}))}else{c()}i.push(e.name);n+=l}))}));if(!o.every((e=>e))){const e=r.filter(((e,t)=>!o[t]));throw new Error(`Could not find weights in manifest with names: `+`${e.join(", ")}. \n`+`Manifest JSON has weights with names: `+`${i.join(", ")}.`)}const u=a.reduce(((e,t,n)=>{if(t){e.push(n)}return e}),[]);const l=[];u.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(!n.endsWith("/")?"/":"")+e;l.push(t)}))}));const c=await e(l);const p={};let m=0;u.forEach((e=>{const n=t[e].paths.length;let r=0;for(let e=0;e<n;e++){r+=c[m+e].byteLength}const a=new ArrayBuffer(r);const o=new Uint8Array(a);let i=0;for(let e=0;e<n;e++){const t=new Uint8Array(c[m+e]);o.set(t,i);i+=t.byteLength}const u=s[e];u.forEach((e=>{const t=a.slice(e.groupOffset,e.groupOffset+e.sizeBytes);const n=decodeWeights(t,[e.manifestEntry]);for(const e in n){p[e]=n[e]}}));m+=n}));return p}}const httpRouter=(e,t)=>{if(typeof fetch==="undefined"&&(t==null||t.fetchFunc==null)){return null}else{let n=true;if(Array.isArray(e)){n=e.every((e=>isHTTPScheme(e)))}else{n=isHTTPScheme(e)}if(n){return http(e,t)}}return null};IORouterRegistry.registerSaveRouter(httpRouter);IORouterRegistry.registerLoadRouter(httpRouter);function browserHTTPRequest(e,t){return http(e,t)}var io=Object.freeze({__proto__:null,browserFiles:()=>{},browserHTTPRequest:browserHTTPRequest,concatenateArrayBuffers:()=>{},decodeWeights:decodeWeights,encodeWeights:()=>{},fromMemory:()=>{},fromMemorySync:()=>{},getLoadHandlers:getLoadHandlers,getModelArtifactsForJSON:getModelArtifactsForJSON,getModelArtifactsInfoForJSON:getModelArtifactsInfoForJSON,getSaveHandlers:getSaveHandlers,http:()=>{},isHTTPScheme:()=>{},loadWeights:()=>{},registerLoadRouter:registerLoadRouter,registerSaveRouter:registerSaveRouter,weightsLoaderFactory:weightsLoaderFactory,withSaveHandler:()=>{},withSaveHandlerSync:()=>{},copyModel:()=>{},listModels:()=>{},moveModel:()=>{},removeModel:()=>{}});function matMul_(e,t,n=false,r=false){let a=convertToTensor(e,"a","matMul");let s=convertToTensor(t,"b","matMul");[a,s]=makeTypesMatch(a,s);const o={a:a,b:s};const i={transposeA:n,transposeB:r};return ENGINE.runKernel(BatchMatMul,o,i)}const matMul$1=op({matMul_:matMul_});function oneHot_(e,t,n=1,r=0){if(t<2){throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`)}const a=convertToTensor(e,"indices","oneHot","int32");const s={indices:a};const o={depth:t,onValue:n,offValue:r};return ENGINE.runKernel(OneHot,s,o)}const oneHot=op({oneHot_:oneHot_});function enableProdMode(){env().set("PROD",true)}function engine(){return ENGINE}function tidy(e,t){return ENGINE.tidy(e,t)}function dispose(e){const t=getTensorsInContainer(e);t.forEach((e=>e.dispose()))}function keep(e){return ENGINE.keep(e)}function registerBackend(e,t,n=1){return ENGINE.registerBackend(e,t,n)}function neg_(e){const t=convertToTensor(e,"x","neg");const n={x:t};return ENGINE.runKernel(Neg,n)}const neg=op({neg_:neg_});function real_(e){const t=convertToTensor(e,"input","real");const n={input:t};return ENGINE.runKernel(Real,n)}const real$1=op({real_:real_});op({confusionMatrix_:()=>{}});function getBroadcastDims$1(e,t){const n=e.length;const r=[];for(let a=0;a<n;a++){const s=n-1-a;const o=e[s]||1;const i=t[t.length-1-a]||1;if(i>1&&o===1){r.unshift(s)}}return r}function getReductionAxes(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1];const s=t.length-r-1;const o=t[s];if(a==null||a===1&&o>1){n.unshift(s)}}return n}function assertAndGetBroadcastShape(e,t){const n=[];const r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let r=e[e.length-a-1];if(r==null){r=1}let s=t[t.length-a-1];if(s==null){s=1}if(r===1){n.unshift(s)}else if(s===1){n.unshift(r)}else if(r!==s){const n=`Operands could not be broadcast together with shapes `+`${e} and ${t}.`;throw Error(n)}else{n.unshift(r)}}return n}op({fromPixels_:()=>{}});function validateInput$1(e,t,n){if(t.rank<1){throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+` but the rank was ${t.rank}.`)}if(e.rank<1){throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+` but the rank was ${e.rank}.`)}if(t.dtype!=="int32"){throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`)}if(n.length<1){throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`)}if(n.length===0){if(t.size===0){throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`)}if(e.size===0){throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}}validateUpdateShape(n,t,e)}function assertParamsValid(e,t,n){const r=e.shape.length;assert(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must `+`match the rank of the array (${r}).`));assert(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must `+`match the rank of the array (${r}).`));for(let a=0;a<r;++a){assert(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] `+`(${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}}function isSliceContinous(e,t,n){let r=n.length;for(let e=0;e<n.length;e++){if(n[e]>1){r=e;break}}for(let a=r+1;a<n.length;a++){if(t[a]>0||n[a]!==e[a]){return false}}return true}function computeFlatOffset(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++){n+=e[r]*t[r]}return n}function parseSliceParams(e,t,n){let r;const a=e.shape.length;if(typeof t==="number"){r=[t,...new Array(a-1).fill(0)]}else if(t.length<a){r=t.concat(new Array(a-t.length).fill(0))}else{r=t.slice()}r.forEach((e=>{assert(e!==-1,(()=>"slice() does not support negative begin indexing."))}));let s;if(n==null){s=new Array(a).fill(-1)}else if(typeof n==="number"){s=[n,...new Array(a-1).fill(-1)]}else if(n.length<a){s=n.concat(new Array(a-n.length).fill(-1))}else{s=n}s=s.map(((t,n)=>{if(t>=0){return t}else{assert(t===-1,(()=>`Negative size values should be exactly -1 but got `+`${t} for the slice() size at index ${n}.`));return e.shape[n]-r[n]}}));return[r,s]}var slice_util=Object.freeze({__proto__:null,assertParamsValid:assertParamsValid,maskToAxes:()=>{},computeOutShape$2:()=>{},stridesWithElidedDims:()=>{},getNormalizedAxes:()=>{},startIndicesWithElidedDims:()=>{},stopIndicesWithElidedDims:()=>{},stridesForAxis:()=>{},startForAxis:()=>{},stopForAxis:()=>{},isSliceContinous:isSliceContinous,computeFlatOffset:computeFlatOffset,parseSliceParams:parseSliceParams,sliceInfo:()=>{}});class Serializable{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class SerializationMap{constructor(){this.classNameMap={}}static getMap(){if(SerializationMap.instance==null){SerializationMap.instance=new SerializationMap}return SerializationMap.instance}static register(e){SerializationMap.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function registerClass(e){assert(e.className!=null,(()=>`Class being registered does not have the static className `+`property defined.`));assert(typeof e.className==="string",(()=>`className is required to be a string, but got type `+typeof e.className));assert(e.className.length>0,(()=>`Class being registered has an empty-string as its className, `+`which is disallowed.`));SerializationMap.register(e)}function add_(e,t){let n=convertToTensor(e,"a","add");let r=convertToTensor(t,"b","add");[n,r]=makeTypesMatch(n,r);const a={a:n,b:r};return ENGINE.runKernel(Add,a)}const add=op({add_:add_});function div_(e,t){let n=convertToTensor(e,"a","div");let r=convertToTensor(t,"b","div");[n,r]=makeTypesMatch(n,r);if(n.dtype==="int32"&&r.dtype==="int32"){return floorDiv(n,r)}const a={a:n,b:r};const s={};return ENGINE.runKernel(RealDiv,a,s)}const div=op({div_:div_});function mul_(e,t){let n=convertToTensor(e,"a","mul");let r=convertToTensor(t,"b","mul");[n,r]=makeTypesMatch(n,r);const a={a:n,b:r};return ENGINE.runKernel(Multiply,a)}const mul=op({mul_:mul_});function abs_(e){const t=convertToTensor(e,"x","abs");if(t.dtype==="complex64"){const e={x:t};return ENGINE.runKernel(ComplexAbs,e)}else{const e={x:t};return ENGINE.runKernel(Abs,e)}}const abs=op({abs_:abs_});function computePool2DInfo(e,t,n,r,a,s,o="channelsLast"){const[i,u]=parseTupleParam(t);let l;if(o==="channelsLast"){l=[i,u,e[3],e[3]]}else if(o==="channelsFirst"){l=[i,u,e[1],e[1]]}else{throw new Error(`Unknown dataFormat ${o}`)}return computeConv2DInfo(e,l,n,r,a,s,false,o)}function computeConv2DInfo(e,t,n,r,a,s,o=false,i="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(i==="channelsLast"){[u,l,c,p]=e}else if(i==="channelsFirst"){[u,p,l,c]=e}else{throw new Error(`Unknown dataFormat ${i}`)}const[m,d,,h]=t;const[f,g]=parseTupleParam(n);const[y,x]=parseTupleParam(r);const T=getEffectiveFilterSize(m,y);const E=getEffectiveFilterSize(d,x);const{padInfo:N,outHeight:S,outWidth:b}=getPadAndOutInfo(a,l,c,f,g,T,E,s,i);const _=o?h*p:h;let I;if(i==="channelsFirst"){I=[u,_,S,b]}else if(i==="channelsLast"){I=[u,S,b,_]}return{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:p,outHeight:S,outWidth:b,outChannels:_,padInfo:N,strideHeight:f,strideWidth:g,filterHeight:m,filterWidth:d,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationHeight:y,dilationWidth:x,inShape:e,outShape:I,filterShape:t}}function getEffectiveFilterSize(e,t){if(t<=1){return e}return e+(e-1)*(t-1)}function convertConv2DDataFormat(e){if(e==="NHWC"){return"channelsLast"}else if(e==="NCHW"){return"channelsFirst"}else{throw new Error(`Unknown dataFormat ${e}`)}}function reshape_(e,t){const n=convertToTensor(e,"x","reshape","string_or_numeric");const r={x:n};const a={shape:t};return ENGINE.runKernel(Reshape,r,a)}const reshape$1=op({reshape_:reshape_});function concat_(e,t=0){assert(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=convertToTensorArray(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"){n.forEach((e=>{if(e.dtype!=="complex64"){throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}}))}if(n.length===1){return clone(n[0])}const r=n;const a={axis:t};return ENGINE.runKernel(Concat,r,a)}const concat$1=op({concat_:concat_});function sigmoid_(e){const t=convertToTensor(e,"x","sigmoid","float32");const n={x:t};return ENGINE.runKernel(Sigmoid,n)}const sigmoid$1=op({sigmoid_:sigmoid_});function slice_(e,t,n){const r=convertToTensor(e,"x","slice","string_or_numeric");if(r.rank===0){throw new Error("Slicing scalar is not possible")}const a={x:r};const s={begin:t,size:n};return ENGINE.runKernel(Slice,a,s)}const slice$1=op({slice_:slice_});op({batchNorm2d_:()=>{}});op({batchNorm3d_:()=>{}});op({batchNorm4d_:()=>{}});function bincount_(e,t,n){const r=convertToTensor(e,"x","bincount");const a=convertToTensor(t,"weights","bincount");assert(r.dtype==="int32",(()=>`Error in bincount: input `+`dtype must be int32, but got ${r.dtype}`));assert(n>=0,(()=>`size must be non-negative, but got ${n}.`));assert(a.size===r.size||a.size===0,(()=>`Error in bincount: weights must have the same size as input or`+`0-length, but got input shape: ${r.shape}, weights shape: `+`${a.shape}.`));const s={x:r,weights:a};const o={size:n};return ENGINE.runKernel(Bincount,s,o)}const bincount=op({bincount_:bincount_});function broadcastTo_(e,t){let n=convertToTensor(e,"broadcastTo","x");const r=n.shape;if(t.some((e=>!(e>0)||e%1!==0))){throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`)}if(t.length<n.rank){throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`)}if(t.length>n.rank){const e=n.shape.slice();while(e.length<t.length){e.unshift(1)}n=reshape$1(n,e)}const a=n.shape;const s=Array.from(t);for(let e=t.length-1;e>=0;e--){if(a[e]===t[e]){s[e]=1}else if(n.shape[e]!==1){throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`)}}const o=s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(o.length===0){return clone(n)}const i={x:n};const u={reps:s};return ENGINE.runKernel(Tile,i,u)}const broadcastTo=op({broadcastTo_:broadcastTo_});op({concat1d_:()=>{}});op({concat2d_:()=>{}});op({concat3d_:()=>{}});op({concat4d_:()=>{}});op({conv1d_:()=>{}});function conv2DBackpropInput_(e,t,n,r,a,s="NHWC",o){assert(e.length===t.rank,(()=>`Length of inShape `+`(${e.length}) and rank of dy (${t.rank}) must match`));let i=e;let u=t;let l=false;if(t.rank===3){l=true;u=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]]);i=[1,e[0],e[1],e[2]]}assert(i.length===4,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length `+`${i.length}.`));assert(u.rank===4,(()=>`Error in conv2dDerInput: dy must be rank 4, but got `+`rank ${u.rank}`));assert(n.rank===4,(()=>`Error in conv2dDerInput: filter must be rank 4, but got `+`rank ${n.rank}`));const c=s==="NHWC"?i[3]:i[1];const p=s==="NHWC"?u.shape[3]:u.shape[1];assert(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must `+`match input depth for filter ${n.shape[2]}.`));assert(p===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${p}) must `+`match output depth for filter ${n.shape[3]}.`));checkPadOnDimRoundingMode("conv2dDerInput",a,o);const m={dy:u,filter:n};const d={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i};const h=ENGINE.runKernel(Conv2DBackpropInput,m,d);if(l){return reshape$1(h,[h.shape[1],h.shape[2],h.shape[3]])}return h}op({conv2DBackpropInput_:conv2DBackpropInput_});op({conv2dTranspose_:()=>{}});op({conv3dTranspose_:()=>{}});function equal_(e,t){let n=convertToTensor(e,"a","equal","string_or_numeric");let r=convertToTensor(t,"b","equal","string_or_numeric");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};return ENGINE.runKernel(Equal,a)}const equal=op({equal_:equal_});function where_(e,t,n){const r=convertToTensor(t,"a","where");const a=convertToTensor(n,"b","where");const s=convertToTensor(e,"condition","where","bool");const o=assertAndGetBroadcastShape(assertAndGetBroadcastShape(s.shape,r.shape),a.shape);const i=broadcastTo(s,o);const u=broadcastTo(r,o);const l=broadcastTo(a,o);const c={condition:i,t:u,e:l};return ENGINE.runKernel(Select,c)}const where=op({where_:where_});function zerosLike_(e){const t=convertToTensor(e,"x","zerosLike");const n={x:t};return ENGINE.runKernel(ZerosLike,n)}const zerosLike=op({zerosLike_:zerosLike_});function dot_(e,t){const n=convertToTensor(e,"t1","dot");const r=convertToTensor(t,"t2","dot");assert((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks `+`${n.rank} and ${r.rank}.`));const a=n.rank===1?n.size:n.shape[1];const s=r.rank===1?r.size:r.shape[0];assert(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got `+`${a} and ${s}.`));if(n.rank===1&&r.rank===1){const e=reshape$1(n,[1,-1]);const t=reshape$1(r,[-1,1]);const a=matMul$1(e,t);return reshape$1(a,[])}else if(n.rank===1&&r.rank===2){const e=reshape$1(n,[1,-1]);const t=reshape$1(r,[r.shape[0],r.shape[1]]);const a=matMul$1(e,t);return reshape$1(a,[a.size])}else if(n.rank===2&&r.rank===1){const e=reshape$1(r,[-1,1]);const t=matMul$1(n,e);return reshape$1(t,[t.size])}else{const e=reshape$1(r,[r.shape[0],r.shape[1]]);const t=matMul$1(n,e);return t}}const dot=op({dot_:dot_});function axesAreInnerMostDims(e,t){for(let n=0;n<e.length;++n){if(e[e.length-n-1]!==t-1-n){return false}}return true}function computeOutAndReduceShapes(e,t){const n=[];const r=e.length;for(let a=0;a<r;a++){if(t.indexOf(a)===-1){n.push(e[a])}}const a=t.map((t=>e[t]));return[n,a]}function expandShapeToKeepDim(e,t){const n=t.map((e=>1));return combineLocations(e,n,t)}function assertAxesAreInnerMostDims(e,t,n){assert(axesAreInnerMostDims(t,n),(()=>`${e} supports only inner-most axes for now. `+`Got axes ${t} and rank-${n} input.`))}function getAxesPermutation(e,t){if(axesAreInnerMostDims(e,t)){return null}const n=[];for(let r=0;r<t;++r){if(e.indexOf(r)===-1){n.push(r)}}e.forEach((e=>n.push(e)));return n}function getInnerMostAxes(e,t){const n=[];for(let r=t-e;r<t;++r){n.push(r)}return n}function max_(e,t=null,n=false){const r=convertToTensor(e,"x","max");const a={x:r};const s={reductionIndices:t,keepDims:n};return ENGINE.runKernel(Max,a,s)}const max=op({max_:max_});function scalar(e,t){if((isTypedArray(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64"){throw new Error("Error creating a new Scalar: value must be a primitive "+"(number|boolean|string)")}if(t==="string"&&isTypedArray(e)&&!(e instanceof Uint8Array)){throw new Error("When making a scalar from encoded string, "+"the value must be `Uint8Array`.")}const n=[];const r=[];return makeTensor(e,n,r,t)}function square_(e){const t=convertToTensor(e,"x","square");const n={};return ENGINE.runKernel("Square",{x:t},n)}const square=op({square_:square_});function sum_(e,t=null,n=false){let r=convertToTensor(e,"x","sum");if(r.dtype==="bool"){r=cast$1(r,"int32")}const a={x:r};const s={axis:t,keepDims:n};return ENGINE.runKernel(Sum,a,s)}const sum$1=op({sum_:sum_});function norm_(e,t="euclidean",n=null,r=false){e=convertToTensor(e,"x","norm");const a=normImpl(e,t,n);let s=a.shape;if(r){const t=parseAxisParam(n,e.shape);s=expandShapeToKeepDim(a.shape,t)}return reshape$1(a,s)}function normImpl(e,t,n=null){if(e.rank===0){return abs(e)}if(e.rank!==1&&n===null){return normImpl(reshape$1(e,[-1]),t,n)}if(e.rank===1||typeof n==="number"||Array.isArray(n)&&n.length===1){if(t===1){return sum$1(abs(e),n)}if(t===Infinity){return max(abs(e),n)}if(t===-Infinity){return min(abs(e),n)}if(t==="euclidean"||t===2){return sqrt(sum$1(pow$1(abs(e),scalar(2,"int32")),n))}throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1){return max(sum$1(abs(e),n[0]),n[1]-1)}if(t===Infinity){return max(sum$1(abs(e),n[1]),n[0])}if(t===-Infinity){return min(sum$1(abs(e),n[1]),n[0])}if(t==="fro"||t==="euclidean"){return sqrt(sum$1(square(e),n))}throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const norm=op({norm_:norm_});function exp_(e){const t=convertToTensor(e,"x","exp");const n={x:t};return ENGINE.runKernel(Exp,n)}const exp=op({exp_:exp_});function expandDims_(e,t=0){const n=convertToTensor(e,"x","expandDims","string_or_numeric");assert(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n};const a={dim:t};return ENGINE.runKernel(ExpandDims,r,a)}const expandDims$1=op({expandDims_:expandDims_});function gather_(e,t,n=0,r=0){const a=convertToTensor(e,"x","gather");const s=convertToTensor(t,"indices","gather","int32");const o={x:a,indices:s};const i={axis:n,batchDims:r};return ENGINE.runKernel(GatherV2,o,i)}const gather=op({gather_:gather_});function greater_(e,t){let n=convertToTensor(e,"a","greater","string_or_numeric");let r=convertToTensor(t,"b","greater","string_or_numeric");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};return ENGINE.runKernel(Greater,a)}const greater=op({greater_:greater_});function log_(e){const t=convertToTensor(e,"x","log","float32");const n={x:t};return ENGINE.runKernel(Log,n)}const log=op({log_:log_});function log1p_(e){const t=convertToTensor(e,"x","log1p");const n={x:t};return ENGINE.runKernel(Log1p,n)}const log1p=op({log1p_:log1p_});function customGrad(e){return ENGINE.customGrad(e)}function sub_(e,t){let n=convertToTensor(e,"a","sub");let r=convertToTensor(t,"b","sub");[n,r]=makeTypesMatch(n,r);const a={a:n,b:r};return ENGINE.runKernel(Sub,a)}const sub=op({sub_:sub_});function logSumExp_(e,t=null,n=false){const r=convertToTensor(e,"x","logSumExp");const a=parseAxisParam(t,r.shape);const s=max(r,a,true);const o=sub(r,s);const i=exp(o);const u=sum$1(i,a);const l=log(u);const c=add(reshape$1(s,l.shape),l);if(n){const e=expandShapeToKeepDim(c.shape,a);return reshape$1(c,e)}return c}const logSumExp=op({logSumExp_:logSumExp_});function logicalAnd_(e,t){const n=convertToTensor(e,"a","logicalAnd","bool");const r=convertToTensor(t,"b","logicalAnd","bool");assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};return ENGINE.runKernel(LogicalAnd,a)}const logicalAnd=op({logicalAnd_:logicalAnd_});op({searchSorted_:()=>{}});function maximum_(e,t){let n=convertToTensor(e,"a","maximum");let r=convertToTensor(t,"b","maximum");[n,r]=makeTypesMatch(n,r);if(n.dtype==="bool"){n=cast$1(n,"int32");r=cast$1(r,"int32")}assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};return ENGINE.runKernel(Maximum,a)}const maximum=op({maximum_:maximum_});function mean_(e,t=null,n=false){const r=convertToTensor(e,"x","mean");const a={x:r};const s={axis:t,keepDims:n};return ENGINE.runKernel(Mean,a,s)}const mean=op({mean_:mean_});function zeros$1(e,t="float32"){if(t==="complex64"){const t=zeros$1(e,"float32");const n=zeros$1(e,"float32");return complex$1(t,n)}const n=makeZerosTypedArray(sizeFromShape(e),t);return ENGINE.makeTensor(n,e,t)}function ones(e,t="float32"){if(t==="complex64"){const t=ones(e,"float32");const n=zeros$1(e,"float32");return complex$1(t,n)}const n=makeOnesTypedArray(sizeFromShape(e),t);return ENGINE.makeTensor(n,e,t)}function minimum_(e,t){let n=convertToTensor(e,"a","minimum");let r=convertToTensor(t,"b","minimum");[n,r]=makeTypesMatch(n,r);if(n.dtype==="bool"){n=cast$1(n,"int32");r=cast$1(r,"int32")}assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};return ENGINE.runKernel(Minimum,a)}const minimum=op({minimum_:minimum_});op({multiRNNCell_:()=>{}});function notEqual_(e,t){let n=convertToTensor(e,"a","notEqual","string_or_numeric");let r=convertToTensor(t,"b","notEqual","string_or_numeric");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};return ENGINE.runKernel(NotEqual,a)}const notEqual$1=op({notEqual_:notEqual_});op({outerProduct_:()=>{}});function pad_(e,t,n=0){const r=convertToTensor(e,"x","pad");if(r.rank===0){throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")}const a={paddings:t,constantValue:n};const s={x:r};return ENGINE.runKernel(PadV2,s,a)}const pad=op({pad_:pad_});op({pad1d_:()=>{}});op({pad2d_:()=>{}});op({pad3d_:()=>{}});op({pad4d_:()=>{}});function prod_(e,t=null,n=false){let r=convertToTensor(e,"x","prod");if(r.dtype==="bool"){r=cast$1(r,"int32")}const a={x:r};const s={axis:t,keepDims:n};return ENGINE.runKernel(Prod,a,s)}const prod$1=op({prod_:prod_});var alea$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n=o();t.next=function(){var e=2091639*t.s0+t.c*2.3283064365386963e-10;t.s0=t.s1;t.s1=t.s2;return t.s2=e-(t.c=e|0)};t.c=1;t.s0=n(" ");t.s1=n(" ");t.s2=n(" ");t.s0-=n(e);if(t.s0<0){t.s0+=1}t.s1-=n(e);if(t.s1<0){t.s1+=1}t.s2-=n(e);if(t.s2<0){t.s2+=1}n=null}function a(e,t){t.c=e.c;t.s0=e.s0;t.s1=e.s1;t.s2=e.s2;return t}function s(e,t){var n=new r(e),s=t&&t.state,o=n.next;o.int32=function(){return n.next()*4294967296|0};o.double=function(){return o()+(o()*2097152|0)*11102230246251565e-32};o.quick=o;if(s){if(typeof s=="object")a(s,n);o.state=function(){return a(n,{})}}return o}function o(){var e=4022871197;var t=function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0;r-=e;r*=e;e=r>>>0;r-=e;e+=r*4294967296}return(e>>>0)*2.3283064365386963e-10};return t}if(t&&t.exports){t.exports=s}else if(n&&n.amd){n((function(){return s}))}else{this.alea=s}})(commonjsGlobal,e,typeof undefined=="function")})(alea$1);var xor128$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n="";t.x=0;t.y=0;t.z=0;t.w=0;t.next=function(){var e=t.x^t.x<<11;t.x=t.y;t.y=t.z;t.z=t.w;return t.w^=t.w>>>19^e^e>>>8};if(e===(e|0)){t.x=e}else{n+=e}for(var r=0;r<n.length+64;r++){t.x^=n.charCodeAt(r)|0;t.next()}}function a(e,t){t.x=e.x;t.y=e.y;t.z=e.z;t.w=e.w;return t}function s(e,t){var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(r===0);return r};o.int32=n.next;o.quick=o;if(s){if(typeof s=="object")a(s,n);o.state=function(){return a(n,{})}}return o}if(t&&t.exports){t.exports=s}else if(n&&n.amd){n((function(){return s}))}else{this.xor128=s}})(commonjsGlobal,e,typeof undefined=="function")})(xor128$1);var xorwow$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;t.x=t.y;t.y=t.z;t.z=t.w;t.w=t.v;return(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0};t.x=0;t.y=0;t.z=0;t.w=0;t.v=0;if(e===(e|0)){t.x=e}else{n+=e}for(var r=0;r<n.length+64;r++){t.x^=n.charCodeAt(r)|0;if(r==n.length){t.d=t.x<<10^t.x>>>4}t.next()}}function a(e,t){t.x=e.x;t.y=e.y;t.z=e.z;t.w=e.w;t.v=e.v;t.d=e.d;return t}function s(e,t){var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(r===0);return r};o.int32=n.next;o.quick=o;if(s){if(typeof s=="object")a(s,n);o.state=function(){return a(n,{})}}return o}if(t&&t.exports){t.exports=s}else if(n&&n.amd){n((function(){return s}))}else{this.xorwow=s}})(commonjsGlobal,e,typeof undefined=="function")})(xorwow$1);var xorshift7$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.x,n=t.i,r,a;r=e[n];r^=r>>>7;a=r^r<<24;r=e[n+1&7];a^=r^r>>>10;r=e[n+3&7];a^=r^r>>>3;r=e[n+4&7];a^=r^r<<7;r=e[n+7&7];r=r^r<<13;a^=r^r<<9;e[n]=a;t.i=n+1&7;return a};function n(e,t){var n,r=[];if(t===(t|0)){r[0]=t}else{t=""+t;for(n=0;n<t.length;++n){r[n&7]=r[n&7]<<15^t.charCodeAt(n)+r[n+1&7]<<13}}while(r.length<8)r.push(0);for(n=0;n<8&&r[n]===0;++n);if(n==8)r[7]=-1;else r[n];e.x=r;e.i=0;for(n=256;n>0;--n){e.next()}}n(t,e)}function a(e,t){t.x=e.x.slice();t.i=e.i;return t}function s(e,t){if(e==null)e=+new Date;var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(r===0);return r};o.int32=n.next;o.quick=o;if(s){if(s.x)a(s,n);o.state=function(){return a(n,{})}}return o}if(t&&t.exports){t.exports=s}else if(n&&n.amd){n((function(){return s}))}else{this.xorshift7=s}})(commonjsGlobal,e,typeof undefined=="function")})(xorshift7$1);var xor4096$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.w,n=t.X,r=t.i,a,s;t.w=e=e+1640531527|0;s=n[r+34&127];a=n[r=r+1&127];s^=s<<13;a^=a<<17;s^=s>>>15;a^=a>>>12;s=n[r]=s^a;t.i=r;return s+(e^e>>>16)|0};function n(e,t){var n,r,a,s,o,i=[],u=128;if(t===(t|0)){r=t;t=null}else{t=t+"\0";r=0;u=Math.max(u,t.length)}for(a=0,s=-32;s<u;++s){if(t)r^=t.charCodeAt((s+32)%t.length);if(s===0)o=r;r^=r<<10;r^=r>>>15;r^=r<<4;r^=r>>>13;if(s>=0){o=o+1640531527|0;n=i[s&127]^=r+o;a=0==n?a+1:0}}if(a>=128){i[(t&&t.length||0)&127]=-1}a=127;for(s=4*128;s>0;--s){r=i[a+34&127];n=i[a=a+1&127];r^=r<<13;n^=n<<17;r^=r>>>15;n^=n>>>12;i[a]=r^n}e.w=o;e.X=i;e.i=a}n(t,e)}function a(e,t){t.i=e.i;t.w=e.w;t.X=e.X.slice();return t}function s(e,t){if(e==null)e=+new Date;var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(r===0);return r};o.int32=n.next;o.quick=o;if(s){if(s.X)a(s,n);o.state=function(){return a(n,{})}}return o}if(t&&t.exports){t.exports=s}else if(n&&n.amd){n((function(){return s}))}else{this.xor4096=s}})(commonjsGlobal,e,typeof undefined=="function")})(xor4096$1);var tychei$1={exports:{}};(function(e){(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;e=e<<25^e>>>7^n;n=n-r|0;r=r<<24^r>>>8^a;a=a-e|0;t.b=e=e<<20^e>>>12^n;t.c=n=n-r|0;t.d=r<<16^n>>>16^a;return t.a=a-e|0};t.a=0;t.b=0;t.c=2654435769|0;t.d=1367130551;if(e===Math.floor(e)){t.a=e/4294967296|0;t.b=e|0}else{n+=e}for(var r=0;r<n.length+20;r++){t.b^=n.charCodeAt(r)|0;t.next()}}function a(e,t){t.a=e.a;t.b=e.b;t.c=e.c;t.d=e.d;return t}function s(e,t){var n=new r(e),s=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};o.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(r===0);return r};o.int32=n.next;o.quick=o;if(s){if(typeof s=="object")a(s,n);o.state=function(){return a(n,{})}}return o}if(t&&t.exports){t.exports=s}else if(n&&n.amd){n((function(){return s}))}else{this.tychei=s}})(commonjsGlobal,e,typeof undefined=="function")})(tychei$1);var seedrandom$1={exports:{}};(function(e){(function(t,n,r){var a=256,s=6,o=52,i="random",u=r.pow(a,s),l=r.pow(2,o),c=l*2,p=a-1,m;function d(e,t,o){var p=[];t=t==true?{entropy:true}:t||{};var m=y(g(t.entropy?[e,T(n)]:e==null?x():e,3),p);var d=new h(p);var E=function(){var e=d.g(s),t=u,n=0;while(e<l){e=(e+n)*a;t*=a;n=d.g(1)}while(e>=c){e/=2;t/=2;n>>>=1}return(e+n)/t};E.int32=function(){return d.g(4)|0};E.quick=function(){return d.g(4)/4294967296};E.double=E;y(T(d.S),n);return(t.pass||o||function(e,t,n,a){if(a){if(a.S){f(a,d)}e.state=function(){return f(d,{})}}if(n){r[i]=e;return t}else return e})(E,m,"global"in t?t.global:this==r,t.state)}function h(e){var t,n=e.length,r=this,s=0,o=r.i=r.j=0,i=r.S=[];if(!n){e=[n++]}while(s<a){i[s]=s++}for(s=0;s<a;s++){i[s]=i[o=p&o+e[s%n]+(t=i[s])];i[o]=t}(r.g=function(e){var t,n=0,s=r.i,o=r.j,i=r.S;while(e--){t=i[s=p&s+1];n=n*a+i[p&(i[s]=i[o=p&o+t])+(i[o]=t)]}r.i=s;r.j=o;return n})(a)}function f(e,t){t.i=e.i;t.j=e.j;t.S=e.S.slice();return t}function g(e,t){var n=[],r=typeof e,a;if(t&&r=="object"){for(a in e){try{n.push(g(e[a],t-1))}catch(e){}}}return n.length?n:r=="string"?e:e+"\0"}function y(e,t){var n=e+"",r,a=0;while(a<n.length){t[p&a]=p&(r^=t[p&a]*19)+n.charCodeAt(a++)}return T(t)}function x(){try{var e;if(m&&(e=m.randomBytes)){e=e(a)}else{e=new Uint8Array(a);(t.crypto||t.msCrypto).getRandomValues(e)}return T(e)}catch(e){var r=t.navigator,s=r&&r.plugins;return[+new Date,t,s,t.screen,T(n)]}}function T(e){return String.fromCharCode.apply(0,e)}y(r.random(),n);if(e.exports){e.exports=d;try{m=require("crypto")}catch(e){}}else{r["seed"+i]=d}})(typeof self!=="undefined"?self:commonjsGlobal,[],Math)})(seedrandom$1);var alea=alea$1.exports;var xor128=xor128$1.exports;var xorwow=xorwow$1.exports;var xorshift7=xorshift7$1.exports;var xor4096=xor4096$1.exports;var tychei=tychei$1.exports;var sr=seedrandom$1.exports;sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;function range(e,t,n=1,r="float32"){if(n===0){throw new Error("Cannot have a step of zero")}const a={start:e,stop:t,step:n,dtype:r};return ENGINE.runKernel(Range,{},a)}function relu_(e){const t=convertToTensor(e,"x","relu");const n={x:t};return ENGINE.runKernel(Relu,n)}const relu$1=op({relu_:relu_});function reverse_(e,t){const n=convertToTensor(e,"x","reverse");const r={x:n};const a={dims:t};return ENGINE.runKernel(Reverse,r,a)}const reverse=op({reverse_:reverse_});op({separableConv2d_:()=>{}});function fft_(e){assert(e.dtype==="complex64",(()=>`The dtype for tf.spectral.fft() must be complex64 `+`but got ${e.dtype}.`));const t={input:e};return ENGINE.runKernel(FFT,t)}const fft=op({fft_:fft_});function squaredDifference_(e,t){let n=convertToTensor(e,"a","squaredDifference");let r=convertToTensor(t,"b","squaredDifference");[n,r]=makeTypesMatch(n,r);assertAndGetBroadcastShape(n.shape,r.shape);const a={a:n,b:r};const s={};return ENGINE.runKernel(SquaredDifference,a,s)}const squaredDifference=op({squaredDifference_:squaredDifference_});function squeeze_(e,t){const n=convertToTensor(e,"x","squeeze","string_or_numeric");return reshape$1(n,squeezeShape(n.shape,t).newShape)}const squeeze=op({squeeze_:squeeze_});function stack_(e,t=0){const n=convertToTensorArray(e,"tensors","stack","string_or_numeric");assert(n.length>=1,(()=>"Pass at least one tensor to tf.stack"));if(n.length>0){assert(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"))}const r=n;const a={axis:t};return ENGINE.runKernel(Pack,r,a)}const stack=op({stack_:stack_});function tensor1d(e,t){assertNonNull(e);const n=inferShape(e,t);if(n.length!==1){throw new Error("tensor1d() requires values to be a flat/TypedArray")}const r=null;return makeTensor(e,r,n,t)}function tensor2d(e,t,n){assertNonNull(e);if(t!=null&&t.length!==2){throw new Error("tensor2d() requires shape to have two numbers")}const r=inferShape(e,n);if(r.length!==2&&r.length!==1){throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")}if(r.length===1&&t==null){throw new Error("tensor2d() requires shape to be provided when `values` "+"are a flat/TypedArray")}return makeTensor(e,t,r,n)}function unstack_(e,t=0){const n=convertToTensor(e,"x","unstack","string_or_numeric");assert(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n};const a={axis:t};return ENGINE.runKernel(Unpack,r,a)}const unstack=op({unstack_:unstack_});function conv2DBackpropFilter_(e,t,n,r,a,s="NHWC",o){let i=e;if(e.rank===3){i=reshape$1(e,[1,e.shape[0],e.shape[1],e.shape[2]])}let u=t;if(u.rank===3){u=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]])}assert(i.rank===4,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape `+`${i.shape}.`));assert(u.rank===4,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape `+`${u.shape}.`));assert(n.length===4,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got `+`${n}.`));const l=s==="NHWC"?i.shape[3]:i.shape[1];const c=s==="NHWC"?u.shape[3]:u.shape[1];assert(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must `+`match input depth in filter (${n[2]}.`));assert(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must `+`match output depth for filter (${n[3]}).`));checkPadOnDimRoundingMode("conv2dDerFilter",a,o);const p={x:i,dy:u};const m={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:n};return ENGINE.runKernel(Conv2DBackpropFilter,p,m)}op({conv2DBackpropFilter_:conv2DBackpropFilter_});function getFusedDyActivation(e,t,n){if(n==null||n==="linear"){return e}if(n==="relu"){return mul(e,step(t))}throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function getFusedBiasGradient(e,t){let n=t;const r=getReductionAxes(e.shape,t.shape);if(r.length>0){n=sum$1(n,r)}return reshape$1(n,e.shape)}const shouldFuse=(e,t)=>{const n=e>0;return!n||t==="linear"};function depthwiseConv2dNativeBackpropFilter_(e,t,n,r,a,s=[1,1],o){let i=e;if(e.rank===3){i=reshape$1(e,[1,e.shape[0],e.shape[1],e.shape[2]])}let u=t;if(u.rank===3){u=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]])}const l={x:i,dy:u};const c={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:n};return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter,l,c)}op({depthwiseConv2dNativeBackpropFilter_:depthwiseConv2dNativeBackpropFilter_});function depthwiseConv2dNativeBackpropInput_(e,t,n,r,a,s=[1,1],o){let i=t;let u=false;if(t.rank===3){u=true;i=reshape$1(t,[1,t.shape[0],t.shape[1],t.shape[2]])}const l={dy:i,filter:n};const c={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:e};const p=ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput,l,c);if(u){return reshape$1(p,[p.shape[1],p.shape[2],p.shape[3]])}return p}op({depthwiseConv2dNativeBackpropInput_:depthwiseConv2dNativeBackpropInput_});function fusedMatMul_({a:e,b:t,transposeA:n=false,transposeB:r=false,bias:a,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(shouldFuse(ENGINE.state.gradientDepth,s)===false){let u=matMul$1(e,t,n,r);if(a!=null){u=add(u,a)}return applyActivation(u,s,o,i)}let u=convertToTensor(e,"a","fused matMul");let l=convertToTensor(t,"b","fused matMul");[u,l]=makeTypesMatch(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1];const p=r?l.shape[l.rank-1]:l.shape[l.rank-2];const m=n?u.shape[u.rank-1]:u.shape[u.rank-2];const d=r?l.shape[l.rank-2]:l.shape[l.rank-1];const h=u.shape.slice(0,-2);const f=l.shape.slice(0,-2);const g=sizeFromShape(h);const y=sizeFromShape(f);assert(c===p,(()=>`Error in fused matMul: inner shapes (${c}) and (`+`${p}) of Tensors with shapes ${u.shape} and `+`${l.shape} and transposeA=${n}`+` and transposeB=${r} must match.`));const x=assertAndGetBroadcastShape(u.shape.slice(0,-2),l.shape.slice(0,-2));const T=x.concat([m,d]);const E=n?reshape$1(u,[g,c,m]):reshape$1(u,[g,m,c]);const N=r?reshape$1(l,[y,d,p]):reshape$1(l,[y,p,d]);let S;if(a!=null){S=convertToTensor(a,"bias","fused matMul");[S]=makeTypesMatch(S,u);assertAndGetBroadcastShape(T,S.shape)}let b;if(o!=null){b=convertToTensor(o,"prelu weights","fused matMul")}const _=(e,t)=>{const[o,i,u,l]=t;const c=getFusedDyActivation(reshape$1(e,u.shape),u,s);let p;let m;if(!n&&!r){p=matMul$1(c,i,false,true);m=matMul$1(o,c,true,false)}else if(!n&&r){p=matMul$1(c,i,false,false);m=matMul$1(c,o,true,false)}else if(n&&!r){p=matMul$1(i,c,false,true);m=matMul$1(o,c,false,false)}else{p=matMul$1(i,c,true,true);m=matMul$1(c,o,true,true)}if(a!=null){const e=getFusedBiasGradient(l,c);return[p,m,e]}else{return[p,m]}};const I={a:E,b:N,bias:S,preluActivationWeights:b};const v={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:i};if(a==null){const e=customGrad(((e,t,n)=>{const r=ENGINE.runKernel(_FusedMatMul,I,v);n([e,t,r]);return{value:reshape$1(r,T),gradFunc:_}}));return e(E,N)}else{const e=customGrad(((e,t,n,r)=>{const a=ENGINE.runKernel(_FusedMatMul,I,v);r([e,t,a,n]);return{value:reshape$1(a,T),gradFunc:_}}));return e(E,N,S)}}const matMul=op({fusedMatMul_:fusedMatMul_});var fused_ops=Object.freeze({__proto__:null,conv2d_:()=>{},depthwiseConv2d_:()=>{},matMul:matMul});function frame_(e,t,n,r=false,a=0){let s=0;const o=[];while(s+t<=e.size){o.push(slice$1(e,s,t));s+=n}if(r){while(s<e.size){const r=s+t-e.size;const i=concat$1([slice$1(e,s,t-r),fill$1([r],a)]);o.push(i);s+=n}}if(o.length===0){return tensor2d([],[0,t])}return reshape$1(concat$1(o),[o.length,t])}const frame=op({frame_:frame_});var Reduction;(function(e){e[e["NONE"]=0]="NONE";e[e["MEAN"]=1]="MEAN";e[e["SUM"]=2]="SUM";e[e["SUM_BY_NONZERO_WEIGHTS"]=3]="SUM_BY_NONZERO_WEIGHTS"})(Reduction||(Reduction={}));op({computeWeightedLoss_:()=>{}});op({cosineDistance_:()=>{}});op({hingeLoss_:()=>{}});op({sigmoidCrossEntropy_:()=>{}});op({softmaxCrossEntropy_:()=>{}});const spectral$1={fft:fft,ifft_:()=>{},rfft_:()=>{},irfft_:()=>{}};const signal={hammingWindow_:()=>{},hannWindow_:()=>{},frame:frame,stft_:()=>{}};const image$1={flipLeftRight_:()=>{},grayscaleToRGB_:()=>{},resizeNearestNeighbor_:()=>{},resizeBilinear_:()=>{},rotateWithOffset_:()=>{},cropAndResize_:()=>{},nonMaxSuppression_:()=>{},nonMaxSuppressionAsync_:()=>{},nonMaxSuppressionWithScore_:()=>{},nonMaxSuppressionWithScoreAsync_:()=>{},nonMaxSuppressionPadded_:()=>{},nonMaxSuppressionPaddedAsync_:()=>{},threshold_:()=>{},transform_:()=>{}};const linalg={bandPart_:()=>{},gramSchmidt_:()=>{},qr_:()=>{}};const losses={absoluteDifference_:()=>{},computeWeightedLoss_:()=>{},cosineDistance_:()=>{},hingeLoss_:()=>{},huberLoss_:()=>{},logLoss_:()=>{},meanSquaredError_:()=>{},sigmoidCrossEntropy_:()=>{},softmaxCrossEntropy_:()=>{}};const sparse$1={sparseFillEmptyRows_:()=>{},sparseReshape_:()=>{},sparseSegmentMean_:()=>{},sparseSegmentSum_:()=>{}};const string$1={stringNGrams_:()=>{},stringSplit_:()=>{},stringToHashBucketFast_:()=>{}};class Optimizer extends Serializable{minimize(e,t=false,n){const{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else{this.applyGradients(a)}dispose(a);if(t){return r}else{r.dispose();return null}}get iterations(){if(this.iterations_==null){this.iterations_=0}return this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return variableGrads(e,t)}dispose(){if(this.iterations_!=null){dispose(this.iterations_)}}async saveIterations(){if(this.iterations_==null){this.iterations_=0}return{name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class `+`${this.getClassName()}`)}async extractIterations(e){this.iterations_=(await e[0].tensor.data())[0];return e.slice(1)}}Object.defineProperty(Optimizer,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});class AdadeltaOptimizer extends Optimizer{constructor(e,t,n=null){super();this.learningRate=e;this.rho=t;this.epsilon=n;this.accumulatedGrads=[];this.accumulatedUpdates=[];if(n==null){this.epsilon=ENGINE.backend.epsilon()}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];const a=false;if(this.accumulatedGrads[n]==null){this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:tidy((()=>zerosLike(r).variable(a)))}}if(this.accumulatedUpdates[n]==null){this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:tidy((()=>zerosLike(r).variable(a)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(s==null){return}const o=this.accumulatedGrads[n].variable;const i=this.accumulatedUpdates[n].variable;tidy((()=>{const e=add(mul(o,this.rho),mul(square(s),1-this.rho));const t=mul(div(sqrt(add(i,this.epsilon)),sqrt(add(o,this.epsilon))),s);const n=add(mul(i,this.rho),mul(square(t),1-this.rho));o.assign(e);i.assign(n);const a=add(mul(t,-this.learningRate),r);r.assign(a)}))}));this.incrementIterations()}dispose(){if(this.accumulatedUpdates!=null){dispose(this.accumulatedGrads.map((e=>e.variable)));dispose(this.accumulatedUpdates.map((e=>e.variable)))}}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2;const n=false;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));this.accumulatedUpdates=e.slice(t,t*2).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["rho"],t["epsilon"])}}AdadeltaOptimizer.className="Adadelta";registerClass(AdadeltaOptimizer);class AdagradOptimizer extends Optimizer{constructor(e,t=.1){super();this.learningRate=e;this.initialAccumulatorValue=t;this.accumulatedGrads=[]}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];if(this.accumulatedGrads[n]==null){const e=false;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:tidy((()=>fill$1(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(a==null){return}const s=this.accumulatedGrads[n].variable;tidy((()=>{const e=add(s,square(a));s.assign(e);const t=add(mul(div(a,sqrt(add(e,ENGINE.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))}));this.incrementIterations()}dispose(){if(this.accumulatedGrads!=null){dispose(this.accumulatedGrads.map((e=>e.variable)))}}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=false;this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t["learningRate"],t["initialAccumulatorValue"])}}AdagradOptimizer.className="Adagrad";registerClass(AdagradOptimizer);class AdamOptimizer extends Optimizer{constructor(e,t,n,r=null){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=r;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];tidy((()=>{this.accBeta1=scalar(t).variable();this.accBeta2=scalar(n).variable()}));if(r==null){this.epsilon=ENGINE.backend.epsilon()}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);tidy((()=>{const n=sub(1,this.accBeta1);const r=sub(1,this.accBeta2);t.forEach(((t,a)=>{const s=ENGINE.registeredVariables[t];const o=false;if(this.accumulatedFirstMoment[a]==null){this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:tidy((()=>zerosLike(s).variable(o)))}}if(this.accumulatedSecondMoment[a]==null){this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:tidy((()=>zerosLike(s).variable(o)))}}const i=Array.isArray(e)?e[a].tensor:e[t];if(i==null){return}const u=this.accumulatedFirstMoment[a].variable;const l=this.accumulatedSecondMoment[a].variable;const c=add(mul(u,this.beta1),mul(i,1-this.beta1));const p=add(mul(l,this.beta2),mul(square(i),1-this.beta2));const m=div(c,n);const d=div(p,r);u.assign(c);l.assign(p);const h=add(mul(div(m,add(sqrt(d),this.epsilon)),-this.learningRate),s);s.assign(h)}));this.accBeta1.assign(mul(this.accBeta1,this.beta1));this.accBeta2.assign(mul(this.accBeta2,this.beta2))}));this.incrementIterations()}dispose(){this.accBeta1.dispose();this.accBeta2.dispose();if(this.accumulatedFirstMoment!=null){dispose(this.accumulatedFirstMoment.map((e=>e.variable)))}if(this.accumulatedSecondMoment!=null){dispose(this.accumulatedSecondMoment.map((e=>e.variable)))}}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);tidy((()=>{this.accBeta1.assign(pow$1(this.beta1,this.iterations_+1));this.accBeta2.assign(pow$1(this.beta2,this.iterations_+1))}));const t=e.length/2;const n=false;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));this.accumulatedSecondMoment=e.slice(t,t*2).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"])}}AdamOptimizer.className="Adam";registerClass(AdamOptimizer);class AdamaxOptimizer extends Optimizer{constructor(e,t,n,r=null,a=0){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=r;this.decay=a;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];tidy((()=>{this.iteration=scalar(0).variable();this.accBeta1=scalar(t).variable()}));if(r==null){this.epsilon=ENGINE.backend.epsilon()}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);tidy((()=>{const n=sub(1,this.accBeta1);const r=div(-this.learningRate,add(mul(this.iteration,this.decay),1));t.forEach(((t,a)=>{const s=ENGINE.registeredVariables[t];const o=false;if(this.accumulatedFirstMoment[a]==null){this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:zerosLike(s).variable(o)}}if(this.accumulatedWeightedInfNorm[a]==null){this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:zerosLike(s).variable(o)}}const i=Array.isArray(e)?e[a].tensor:e[t];if(i==null){return}const u=this.accumulatedFirstMoment[a].variable;const l=this.accumulatedWeightedInfNorm[a].variable;const c=add(mul(u,this.beta1),mul(i,1-this.beta1));const p=mul(l,this.beta2);const m=abs(i);const d=maximum(p,m);u.assign(c);l.assign(d);const h=add(mul(div(r,n),div(c,add(d,this.epsilon))),s);s.assign(h)}));this.iteration.assign(add(this.iteration,1));this.accBeta1.assign(mul(this.accBeta1,this.beta1))}));this.incrementIterations()}dispose(){this.accBeta1.dispose();this.iteration.dispose();if(this.accumulatedFirstMoment!=null){dispose(this.accumulatedFirstMoment.map((e=>e.variable)))}if(this.accumulatedWeightedInfNorm!=null){dispose(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t["learningRate"],t["beta1"],t["beta2"],t["epsilon"],t["decay"])}}AdamaxOptimizer.className="Adamax";registerClass(AdamaxOptimizer);class SGDOptimizer extends Optimizer{constructor(e){super();this.learningRate=e;this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(r==null){return}const a=ENGINE.registeredVariables[t];tidy((()=>{const e=add(mul(this.c,r),a);a.assign(e)}))}));this.incrementIterations()}setLearningRate(e){this.learningRate=e;if(this.c!=null){this.c.dispose()}this.c=keep(scalar(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){e=await this.extractIterations(e);if(e.length!==0){throw new Error("SGD optimizer does not have settable weights.")}}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t["learningRate"])}}SGDOptimizer.className="SGD";registerClass(SGDOptimizer);class MomentumOptimizer extends SGDOptimizer{constructor(e,t,n=false){super(e);this.learningRate=e;this.momentum=t;this.useNesterov=n;this.accumulations=[];this.m=scalar(this.momentum)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];if(this.accumulations[n]==null){const e=false;this.accumulations[n]={originalName:`${t}/momentum`,variable:tidy((()=>zerosLike(r).variable(e)))}}const a=this.accumulations[n].variable;const s=Array.isArray(e)?e[n].tensor:e[t];if(s==null){return}tidy((()=>{let e;const t=add(mul(this.m,a),s);if(this.useNesterov){e=add(mul(this.c,add(s,mul(t,this.m))),r)}else{e=add(mul(this.c,t),r)}a.assign(t);r.assign(e)}))}));this.incrementIterations()}dispose(){this.m.dispose();if(this.accumulations!=null){dispose(this.accumulations.map((e=>e.variable)))}}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=false;this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t["learningRate"],t["momentum"],t["useNesterov"])}}MomentumOptimizer.className="Momentum";registerClass(MomentumOptimizer);class RMSPropOptimizer extends Optimizer{constructor(e,t=.9,n=0,r=null,a=false){super();this.learningRate=e;this.decay=t;this.momentum=n;this.epsilon=r;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];this.centered=a;if(r==null){this.epsilon=ENGINE.backend.epsilon()}if(e==null){throw new Error(`learningRate for RMSPropOptimizer must be defined.`)}}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=ENGINE.registeredVariables[t];const a=false;if(this.accumulatedMeanSquares[n]==null){this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:tidy((()=>zerosLike(r).variable(a)))}}if(this.accumulatedMoments[n]==null){this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:tidy((()=>zerosLike(r).variable(a)))}}if(this.accumulatedMeanGrads[n]==null&&this.centered){this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:tidy((()=>zerosLike(r).variable(a)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(s==null){return}const o=this.accumulatedMeanSquares[n].variable;const i=this.accumulatedMoments[n].variable;tidy((()=>{const e=add(mul(o,this.decay),mul(square(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable;const a=add(mul(t,this.decay),mul(s,1-this.decay));const u=div(mul(s,this.learningRate),sqrt(sub(e,add(square(a),this.epsilon))));const l=add(mul(i,this.momentum),u);o.assign(e);t.assign(a);i.assign(l);const c=sub(r,l);r.assign(c)}else{const e=add(mul(o,this.decay),mul(square(s),1-this.decay));const t=add(mul(i,this.momentum),div(mul(s,this.learningRate),sqrt(add(e,this.epsilon))));o.assign(e);i.assign(t);const n=sub(r,t);r.assign(n)}}))}));this.incrementIterations()}dispose(){if(this.accumulatedMeanSquares!=null){dispose(this.accumulatedMeanSquares.map((e=>e.variable)))}if(this.accumulatedMeanGrads!=null&&this.centered){dispose(this.accumulatedMeanGrads.map((e=>e.variable)))}if(this.accumulatedMoments!=null){dispose(this.accumulatedMoments.map((e=>e.variable)))}}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];if(this.centered){e.push(...this.accumulatedMeanGrads)}return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2;const n=false;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));this.accumulatedMoments=e.slice(t,t*2).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})));if(this.centered){this.accumulatedMeanGrads=e.slice(t*2,t*3).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t["learningRate"],t["decay"],t["momentum"],t["epsilon"],t["centered"])}}RMSPropOptimizer.className="RMSProp";registerClass(RMSPropOptimizer);(()=>{if(typeof requestAnimationFrame!=="undefined"){return requestAnimationFrame}else if(typeof setImmediate!=="undefined"){return setImmediate}return e=>e()})();function assertParamsConsistent(e,t){const n=e[0].length;e.forEach(((e,t)=>{assert(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same `+`as the rank of the rest (${n})`))}));assert(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++){assert(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) `+`does not match the shape of the rest (${r}) `+`along the non-concatenated axis ${a}.`))}}))}function computeOutShape$1(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++){n[t]+=e[r][t]}return n}const PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(e){if(e<=PARALLELIZE_THRESHOLD){return e}return nearestDivisor(e,Math.floor(Math.sqrt(e)))}const SELU_SCALEALPHA=1.7580993408473768;const SELU_SCALE=1.0507009873554805;const ERF_P=.3275911;const ERF_A1=.254829592;const ERF_A2=-.284496736;const ERF_A3=1.421413741;const ERF_A4=-1.453152027;const ERF_A5=1.061405429;function collectGatherOpShapeInfo(e,t,n,r){const a=t.shape.length;const s=e.shape.length;if(r!==0){if(r<-a||r>a){throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`)}}if(r<0){r+=a}if(r>s){throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`)}if(n<r){throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`)}for(let n=0;n<r;++n){if(e.shape[n]!==t.shape[n]){throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`)}}const o=e.shape[n];const i=[];let u=1;let l=1;let c=1;for(let t=0;t<r;++t){i.push(e.shape[t]);u*=e.shape[t]}for(let t=r;t<n;t++){i.push(e.shape[t]);l*=e.shape[t]}for(let e=r;e<a;e++){i.push(t.shape[e])}for(let t=n+1;t<s;t++){i.push(e.shape[t]);c*=e.shape[t]}return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}var segment_util=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:()=>{},computeOutShape$2:()=>{},collectGatherOpShapeInfo:collectGatherOpShapeInfo});var backend_util=Object.freeze({__proto__:null,slice_util:slice_util,segment_util:segment_util,fromUint8ToStringArray:()=>{},fromStringArrayToUint8:()=>{},upcastType:upcastType,axesAreInnerMostDims:axesAreInnerMostDims,combineLocations:()=>{},computeOutAndReduceShapes:computeOutAndReduceShapes,expandShapeToKeepDim:expandShapeToKeepDim,assertAxesAreInnerMostDims:assertAxesAreInnerMostDims,getAxesPermutation:getAxesPermutation,getUndoAxesPermutation:()=>{},getInnerMostAxes:getInnerMostAxes,getBroadcastDims:getBroadcastDims$1,getReductionAxes:getReductionAxes,assertAndGetBroadcastShape:assertAndGetBroadcastShape,assertParamsConsistent:assertParamsConsistent,computeOutShape$2:()=>{},computeDilation2DInfo:()=>{},computePool2DInfo:computePool2DInfo,computePool3DInfo:()=>{},computeConv2DInfo:computeConv2DInfo,computeConv3DInfo:()=>{},computeDefaultPad:()=>{},tupleValuesAreOne:()=>{},eitherStridesOrDilationsAreOne:()=>{},convertConv2DDataFormat:convertConv2DDataFormat,checkPadOnDimRoundingMode:()=>{},getFusedDyActivation:getFusedDyActivation,getFusedBiasGradient:getFusedBiasGradient,applyActivation:()=>{},shouldFuse:shouldFuse,PARALLELIZE_THRESHOLD:PARALLELIZE_THRESHOLD,computeOptimalWindowSize:computeOptimalWindowSize,getImageCenter:()=>{},getReshaped:()=>{},getPermuted:()=>{},getReshapedPermuted:()=>{},getSliceBeginCoords:()=>{},getSliceSize:()=>{},prepareAndValidate:()=>{},validateUpdateShape:()=>{},validateInput:validateInput$1,calculateShapes:()=>{},SELU_SCALEALPHA:SELU_SCALEALPHA,SELU_SCALE:SELU_SCALE,ERF_P:ERF_P,ERF_A1:ERF_A1,ERF_A2:ERF_A2,ERF_A3:ERF_A3,ERF_A4:ERF_A4,ERF_A5:ERF_A5,warn:warn,log:log$1,mergeRealAndImagArrays:()=>{},splitRealAndImagArrays:()=>{},complexWithEvenIndex:()=>{},complexWithOddIndex:()=>{},getComplexWithIndex:()=>{},assignToTypedArray:()=>{},exponents:()=>{},exponent:()=>{},decodeEinsumEquation:()=>{},getEinsumPermutation:()=>{},checkEinsumDimSizes:()=>{},getEinsumComputePath:()=>{},isIdentityPermutation:()=>{},prepareSplitSize:()=>{},getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>{},getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>{},getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>{},getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>{},getSparseReshapeNegativeOutputDimErrorMessage:()=>{},getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>{},getSparseReshapeInputOutputMultipleErrorMessage:()=>{},getSparseReshapeInputOutputMismatchErrorMessage:()=>{},getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>{},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>{},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>{},getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>{}});const ENV$1=env();ENV$1.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>false),(e=>{if(e){console.warn("Keep intermediate tensors is ON. This will print the values of all "+"intermediate tensors during model inference. Not all models "+"support this mode. For details, check e2e/benchmarks/ "+"model_config.js. This significantly impacts performance.")}}));var DataType;(function(e){e[e["DT_INVALID"]=0]="DT_INVALID";e[e["DT_FLOAT"]=1]="DT_FLOAT";e[e["DT_DOUBLE"]=2]="DT_DOUBLE";e[e["DT_INT32"]=3]="DT_INT32";e[e["DT_UINT8"]=4]="DT_UINT8";e[e["DT_INT16"]=5]="DT_INT16";e[e["DT_INT8"]=6]="DT_INT8";e[e["DT_STRING"]=7]="DT_STRING";e[e["DT_COMPLEX64"]=8]="DT_COMPLEX64";e[e["DT_INT64"]=9]="DT_INT64";e[e["DT_BOOL"]=10]="DT_BOOL";e[e["DT_QINT8"]=11]="DT_QINT8";e[e["DT_QUINT8"]=12]="DT_QUINT8";e[e["DT_QINT32"]=13]="DT_QINT32";e[e["DT_BFLOAT16"]=14]="DT_BFLOAT16";e[e["DT_QINT16"]=15]="DT_QINT16";e[e["DT_QUINT16"]=16]="DT_QUINT16";e[e["DT_UINT16"]=17]="DT_UINT16";e[e["DT_COMPLEX128"]=18]="DT_COMPLEX128";e[e["DT_HALF"]=19]="DT_HALF";e[e["DT_RESOURCE"]=20]="DT_RESOURCE";e[e["DT_VARIANT"]=21]="DT_VARIANT";e[e["DT_UINT32"]=22]="DT_UINT32";e[e["DT_UINT64"]=23]="DT_UINT64";e[e["DT_FLOAT_REF"]=101]="DT_FLOAT_REF";e[e["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF";e[e["DT_INT32_REF"]=103]="DT_INT32_REF";e[e["DT_UINT8_REF"]=104]="DT_UINT8_REF";e[e["DT_INT16_REF"]=105]="DT_INT16_REF";e[e["DT_INT8_REF"]=106]="DT_INT8_REF";e[e["DT_STRING_REF"]=107]="DT_STRING_REF";e[e["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF";e[e["DT_INT64_REF"]=109]="DT_INT64_REF";e[e["DT_BOOL_REF"]=110]="DT_BOOL_REF";e[e["DT_QINT8_REF"]=111]="DT_QINT8_REF";e[e["DT_QUINT8_REF"]=112]="DT_QUINT8_REF";e[e["DT_QINT32_REF"]=113]="DT_QINT32_REF";e[e["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF";e[e["DT_QINT16_REF"]=115]="DT_QINT16_REF";e[e["DT_QUINT16_REF"]=116]="DT_QUINT16_REF";e[e["DT_UINT16_REF"]=117]="DT_UINT16_REF";e[e["DT_COMPLEX128_REF"]=118]="DT_COMPLEX128_REF";e[e["DT_HALF_REF"]=119]="DT_HALF_REF";e[e["DT_RESOURCE_REF"]=120]="DT_RESOURCE_REF";e[e["DT_VARIANT_REF"]=121]="DT_VARIANT_REF";e[e["DT_UINT32_REF"]=122]="DT_UINT32_REF";e[e["DT_UINT64_REF"]=123]="DT_UINT64_REF"})(DataType||(DataType={}));var SaverDef;(function(e){(function(e){e[e["LEGACY"]=0]="LEGACY";e[e["V1"]=1]="V1";e[e["V2"]=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(SaverDef||(SaverDef={}));const CUSTOM_OPS={};function getRegisteredOp(e){return CUSTOM_OPS[e]}function getParamValue(e,t,n,r,a){const s=t.inputParams[e];if(s&&s.inputIndexStart!==undefined){const e=s.inputIndexStart;const o=s.inputIndexEnd===0?undefined:s.inputIndexEnd===undefined?e+1:s.inputIndexEnd;if(s.type==="tensor"){return getTensor(t.inputNames[s.inputIndexStart],n,r,a)}if(s.type==="tensors"){const s=t.inputNames.slice(e,o);return s.map((e=>getTensor(e,n,r,a)))}const i=getTensor(t.inputNames.slice(e)[0],n,r,a);const u=i.dataSync();return s.type==="number"?u[0]:toNestedArray(i.shape,u)}const o=t.attrParams[e];return o&&o.value}function getTensor(e,t,n,r){const[a,s]=parseNodeName(e);if(r!=null){const e=r.getHashTableHandleByName(a);if(e!=null){return e}}const o=n.currentContextIds.find((e=>!!t[getNodeNameWithContextId(a,e)]));return o!==undefined?t[getNodeNameWithContextId(a,o)][s]:undefined}function getTensorsForCurrentContenxt(e,t,n){return t[getNodeNameWithContextId(e,n.currentContextId)]}function getNodeNameAndIndex(e,t){const[n,r,a]=parseNodeName(e);return[getNodeNameWithContextId(n,t&&t.currentContextId),r,a]}function getNodeNameWithContextId(e,t){return!!t?`${e}-${t}`:e}function parseNodeName(e){const t=e.split(":");if(t.length===1){return[e,0,undefined]}const n=t[0];const r=t.length===3?t[1]:undefined;const a=Number(t[t.length-1]);return[n,a,r]}function getPadding(e,t,n){let r=getParamValue("pad",e,t,n);if(r==="explicit"){r=getParamValue("explicitPaddings",e,t,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++){a[e][0]=r[e*2];a[e][1]=r[e*2+1]}return a}return r}function cloneTensor(e){return e.kept?e:clone(e)}const json$i=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var arithmetic=Object.freeze({__proto__:null,json:json$i});const json$h=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:true}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:true}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var basicMath=Object.freeze({__proto__:null,json:json$h});const json$g=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:true}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var control=Object.freeze({__proto__:null,json:json$g});const json$f=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:true},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:true}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var convolution=Object.freeze({__proto__:null,json:json$f});const json$e=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:true},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:true},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:true}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var creation=Object.freeze({__proto__:null,json:json$e});const json$d=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:true},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var dynamic=Object.freeze({__proto__:null,json:json$d});const json$c=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var evaluation=Object.freeze({__proto__:null,json:json$c});const json$b=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:true},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var graph=Object.freeze({__proto__:null,json:json$b});const json$a=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:true},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:true}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var hashTable=Object.freeze({__proto__:null,json:json$a});const json$9=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var image=Object.freeze({__proto__:null,json:json$9});const json$8=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]}];var logical=Object.freeze({__proto__:null,json:json$8});const json$7=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:false},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:false},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:false},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:false},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:false},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:false},{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var matrices=Object.freeze({__proto__:null,json:json$7});const json$6=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:false}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:true}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:true,notSupported:true}]}];var normalization=Object.freeze({__proto__:null,json:json$6});const json$5=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var reduction=Object.freeze({__proto__:null,json:json$5});const json$4=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:true}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:true}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:false,notSupported:true}]}];var sliceJoin=Object.freeze({__proto__:null,json:json$4});const json$3=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:true}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var sparse=Object.freeze({__proto__:null,json:json$3});const json$2=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:true}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:true}]}];var spectral=Object.freeze({__proto__:null,json:json$2});const json$1=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var string=Object.freeze({__proto__:null,json:json$1});const json=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:true},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var transformation=Object.freeze({__proto__:null,json:json});class OperationMapper{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,graph,hashTable,image,logical,matrices,normalization,reduction,sliceJoin,sparse,spectral,string,transformation];const t=[].concat(...e.map((e=>e.json)));this.opMappers=t.reduce(((e,t)=>{e[t.tfOpName]=t;return e}),{})}transformGraph(e,t={}){const n=e.node;const r=[];const a=[];const s=[];const o=n.reduce(((e,t)=>{e[t.name]=this.mapNode(t);if(t.op.startsWith("Placeholder")){r.push(e[t.name])}else if(t.op==="Const"){a.push(e[t.name])}else if(t.input==null||t.input.length===0){s.push(e[t.name])}return e}),{});let i=[];const u=[];let l={};let c={};if(t!=null){l=this.mapSignatureEntries(t.inputs);c=this.mapSignatureEntries(t.outputs)}const p=Object.keys(o);p.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=getNodeNameAndIndex(e);const s=o[r];if(s.outputs!=null){const e=s.outputs.indexOf(a);if(e!==-1){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s);s.children.push(t)}))}));if(Object.keys(c).length===0){p.forEach((e=>{const t=o[e];if(t.children.length===0){u.push(t)}}))}else{Object.keys(c).forEach((e=>{const[t]=getNodeNameAndIndex(e);const n=o[t];if(n!=null){n.signatureKey=c[e];u.push(n)}}))}if(Object.keys(l).length>0){Object.keys(l).forEach((e=>{const[t]=getNodeNameAndIndex(e);const n=o[t];if(n){n.signatureKey=l[e];i.push(n)}}))}else{i=r}let m={};if(e.library!=null&&e.library.function!=null){m=e.library.function.reduce(((e,t)=>{e[t.signature.name]=this.mapFunction(t);return e}),{})}const d={nodes:o,inputs:i,outputs:u,weights:a,placeholders:r,signature:t,functions:m};if(s.length>0){d.initNodes=s}return d}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>{t[e[n].name]=n;return t}),{})}mapNode(e){const t=getRegisteredOp(e.op)||this.opMappers[e.op]||{};if(e.attr==null){e.attr={}}const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};if(t.inputs!=null){n.inputParams=t.inputs.reduce(((e,t)=>{e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end};return e}),{})}if(t.attrs!=null){n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let a=undefined;switch(n.type){case"string":a=getStringParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getStringParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"string[]":a=getStringArrayParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getStringArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"number":a=getNumberParam(e.attr,n.tfName,n.defaultValue||0);if(a===undefined&&!!n.tfDeprecatedName){a=getNumberParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"number[]":a=getNumericArrayParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getNumericArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"bool":a=getBoolParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getBoolParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"bool[]":a=getBoolArrayParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getBoolArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"shape":a=getTensorShapeParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getTensorShapeParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"shape[]":a=getTensorShapeArrayParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getTensorShapeArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"dtype":a=getDtypeParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getDtypeParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"dtype[]":a=getDtypeArrayParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getDtypeArrayParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"func":a=getFuncParam(e.attr,n.tfName,n.defaultValue);if(a===undefined&&!!n.tfDeprecatedName){a=getFuncParam(e.attr,n.tfDeprecatedName,n.defaultValue)}break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}t[n.name]={value:a,type:r};return t}),{})}return n}mapFunction(e){const t=e.nodeDef;const n=[];const r=[];let a={};if(t!=null){a=t.reduce(((e,t)=>{e[t.name]=this.mapNode(t);if(t.op==="Const"){r.push(e[t.name])}return e}),{})}const s=[];const o=[];e.signature.inputArg.forEach((e=>{const[t]=getNodeNameAndIndex(e.name);const n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:parseDtypeParam(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name;s.push(n);a[t]=n}));const i=Object.keys(a);i.forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=getNodeNameAndIndex(e);const o=a[r];if(o.outputs!=null){const e=o.outputs.indexOf(s);if(e!==-1){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(o);o.children.push(t)}))}));const u=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=getNodeNameAndIndex(u[e.name]);const r=a[t];if(r!=null){r.defaultOutput=n;o.push(r)}}));const l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:o,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>{e[t.name]=this.mapArgToTensorInfo(t);return e}),{}),outputs:e.signature.outputArg.reduce(((t,n)=>{t[n.name]=this.mapArgToTensorInfo(n,e.ret);return t}),{})}}mapArgToTensorInfo(e,t){let n=e.name;if(t!=null){n=t[n]}return{name:n,dtype:e.type}}}function decodeBase64(e){const t=env().global;if(typeof t.atob!=="undefined"){return t.atob(e)}else if(typeof Buffer!=="undefined"){return new Buffer(e,"base64").toString()}else{throw new Error("Unable to decode base64 in this environment. "+"Missing built-in atob() or Buffer()")}}function parseStringParam(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):decodeBase64(e);return t?n:n.toLowerCase()}function getStringParam(e,t,n,r=false){const a=e[t];if(a!=null){return parseStringParam(a.s,r)}return n}function getBoolParam(e,t,n){const r=e[t];return r?r.b:n}function getNumberParam(e,t,n){const r=e[t]||{};const a=r["i"]!=null?r["i"]:r["f"]!=null?r["f"]:n;return typeof a==="number"?a:parseInt(a,10)}function parseDtypeParam(e){if(typeof e==="string"){e=DataType[e]}switch(e){case DataType.DT_FLOAT:case DataType.DT_HALF:return"float32";case DataType.DT_INT32:case DataType.DT_INT64:case DataType.DT_INT8:case DataType.DT_UINT8:return"int32";case DataType.DT_BOOL:return"bool";case DataType.DT_DOUBLE:return"float32";case DataType.DT_STRING:return"string";default:return null}}function getDtypeParam(e,t,n){const r=e[t];if(r&&r.type){return parseDtypeParam(r.type)}return n}function parseTensorShapeParam(e){if(e.unknownRank){return undefined}if(e.dim!=null){return e.dim.map((e=>typeof e.size==="number"?e.size:parseInt(e.size,10)))}return[]}function getTensorShapeParam(e,t,n){const r=e[t];if(r&&r.shape){return parseTensorShapeParam(r.shape)}return n}function getStringArrayParam(e,t,n,r=false){const a=e[t];if(a&&a.list&&a.list.s){return a.list.s.map((e=>parseStringParam(e,r)))}return n}class NodeValueImpl{constructor(e,t,n){this.node=e;this.tensorMap=t;this.context=n;this.inputs=[];this.attrs={};this.inputs=e.inputNames.map((e=>this.getInput(e)));if(e.rawAttrs!=null){this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>{e[t]=this.getAttr(t);return e}),{})}}getInput(e){return getTensor(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null){return getTensor(e,this.tensorMap,this.context)}if(n.i!=null||n.f!=null){return getNumberParam(this.node.rawAttrs,e,t)}if(n.s!=null){return getStringParam(this.node.rawAttrs,e,t)}if(n.b!=null){return getBoolParam(this.node.rawAttrs,e,t)}if(n.shape!=null){return getTensorShapeParam(this.node.rawAttrs,e,t)}if(n.type!=null){return getDtypeParam(this.node.rawAttrs,e,t)}if(n.list!=null){if(n.list.i!=null||n.list.f!=null){return getNumericArrayParam(this.node.rawAttrs,e,t)}if(n.list.s!=null){return getStringArrayParam(this.node.rawAttrs,e,t)}if(n.list.shape!=null){return getTensorShapeArrayParam(this.node.rawAttrs,e,t)}if(n.list.b!=null){return getBoolArrayParam(this.node.rawAttrs,e,t)}if(n.list.type!=null){return getDtypeArrayParam(this.node.rawAttrs,e,t)}}return t}}var tfOps=Object.freeze({__proto__:null,abs:abs,acos_:()=>{},acosh_:()=>{},add:add,addN_:()=>{},all_:()=>{},any_:()=>{},argMax_:()=>{},argMin_:()=>{},asin_:()=>{},asinh_:()=>{},atan_:()=>{},atan_:()=>{},atanh_:()=>{},avgPool_:()=>{},avgPool3d_:()=>{},basicLSTMCell_:()=>{},batchToSpaceND_:()=>{},batchNorm_:()=>{},batchNorm2d_:()=>{},batchNorm3d_:()=>{},batchNorm4d_:()=>{},bincount:bincount,broadcastArgs_:()=>{},broadcastTo:broadcastTo,buffer:buffer,cast:cast$1,ceil_:()=>{},clipByValue_:()=>{},clone:clone,complex:complex$1,concat:concat$1,concat1d_:()=>{},concat2d_:()=>{},concat3d_:()=>{},concat4d_:()=>{},conv1d_:()=>{},conv2d_:()=>{},conv2dTranspose_:()=>{},conv3d_:()=>{},conv3dTranspose_:()=>{},cos_:()=>{},cosh_:()=>{},cumprod_:()=>{},cumsum_:()=>{},denseBincount_:()=>{},depthToSpace_:()=>{},depthwiseConv2d_:()=>{},diag_:()=>{},dilation2d_:()=>{},div:div,divNoNan_:()=>{},dot:dot,einsum_:()=>{},elu_:()=>{},equal:equal,erf_:()=>{},euclideanNorm_:()=>{},exp:exp,expandDims:expandDims$1,expm1_:()=>{},eye_:()=>{},fill$1:()=>{},floor_:()=>{},floorDiv_:()=>{},gather:gather,greater:greater,greaterEqual_:()=>{},imag_:()=>{},isFinite_:()=>{},isInf_:()=>{},isNaN_:()=>{},leakyRelu_:()=>{},less_:()=>{},lessEqual_:()=>{},linspace:()=>{},localResponseNormalization_:()=>{},log:log,log1p:log1p,logSigmoid_:()=>{},logSoftmax_:()=>{},logSumExp:logSumExp,logicalAnd:logicalAnd,logicalNot_:()=>{},logicalOr_:()=>{},logicalXor_:()=>{},lowerBound:()=>{},matMul:matMul$1,max:max,maxPool_:()=>{},maxPool3d_:()=>{},maxPoolWithArgmax_:()=>{},maximum:maximum,mean:mean,meshgrid:()=>{},min_:()=>{},minimum:minimum,mirrorPad_:()=>{},mod_:()=>{},moments_:()=>{},mul:mul,multiRNNCell_:()=>{},multinomial_:()=>{},neg:neg,notEqual:notEqual$1,oneHot:oneHot,ones:ones,onesLike_:()=>{},outerProduct_:()=>{},pad:pad,pad1d_:()=>{},pad2d_:()=>{},pad3d_:()=>{},pad4d_:()=>{},pool_:()=>{},pow_:()=>{},prelu_:()=>{},print:print$1,prod:prod$1,rand_:()=>{},randomGamma_:()=>{},randomNormal_:()=>{},randomStandardNormal_:()=>{},randomUniform_:()=>{},range:range,real:real$1,reciprocal_:()=>{},relu:relu$1,relu6_:()=>{},reshape:reshape$1,reverse:reverse,reverse1d_:()=>{},reverse2d_:()=>{},reverse3d_:()=>{},reverse4d_:()=>{},round$1:()=>{},rsqrt_:()=>{},scalar:scalar,selu_:()=>{},separableConv2d_:()=>{},setdiff1dAsync_:()=>{},sigmoid:sigmoid$1,sign_:()=>{},sin_:()=>{},sinh_:()=>{},slice:slice$1,slice1d_:()=>{},slice2d_:()=>{},slice3d_:()=>{},slice4d_:()=>{},softmax_:()=>{},softplus_:()=>{},spaceToBatchND_:()=>{},fft:fft,ifft_:()=>{},irfft_:()=>{},rfft_:()=>{},split_:()=>{},sqrt_:()=>{},square:square,squaredDifference:squaredDifference,squeeze:squeeze,stack:stack,step_:()=>{},stridedSlice_:()=>{},sub:sub,sum:sum$1,tan_:()=>{},tanh_:()=>{},tensor:tensor,tensor1d:tensor1d,tensor2d:tensor2d,tensor3d:()=>{},tensor4d:()=>{},tensor5d:()=>{},tensor6d:()=>{},tile_:()=>{},topk_:()=>{},truncatedNormal_:()=>{},unique_:()=>{},unsortedSegmentSum_:()=>{},unstack:unstack,upperBound:()=>{},variable:()=>{},where:where,whereAsync_:()=>{},zeros:zeros$1,zerosLike:zerosLike,op:op,OP_SCOPE_SUFFIX:OP_SCOPE_SUFFIX,booleanMaskAsync_:()=>{},transpose_:()=>{},norm:norm,movingAverage_:()=>{},scatterND_:()=>{},searchSorted_:()=>{},sparseToDense_:()=>{},gatherND_:()=>{},dropout_:()=>{},enclosingPowerOfTwo:()=>{},cosineWindow:()=>{},inTopKAsync_:()=>{},image:image$1,linalg:linalg,losses:losses,spectral:spectral$1,fused:fused_ops,signal:signal,sparse:sparse$1,string:string$1});const executeOp$j=(e,t,n,r=tfOps)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":{return[r.add(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"AddN":{return[r.addN(getParamValue("tensors",e,t,n))]}case"FloorMod":case"Mod":return[r.mod(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"Mul":return[r.mul(getParamValue("a",e,t,n),getParamValue("b",e,t,n))];case"RealDiv":case"Div":{return[r.div(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"DivNoNan":{return[r.divNoNan(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"FloorDiv":{return[r.floorDiv(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Sub":{return[r.sub(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Minimum":{return[r.minimum(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Maximum":{return[r.maximum(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Pow":{return[r.pow(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"SquaredDifference":{return[r.squaredDifference(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$i=(e,t,n,r=tfOps)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(getParamValue("x",e,t,n))];case"Acos":return[r.acos(getParamValue("x",e,t,n))];case"Acosh":return[r.acosh(getParamValue("x",e,t,n))];case"Asin":return[r.asin(getParamValue("x",e,t,n))];case"Asinh":return[r.asinh(getParamValue("x",e,t,n))];case"Atan":return[r.atan(getParamValue("x",e,t,n))];case"Atan2":return[r.atan2(getParamValue("x",e,t,n),getParamValue("y",e,t,n))];case"Atanh":return[r.atanh(getParamValue("x",e,t,n))];case"Ceil":return[r.ceil(getParamValue("x",e,t,n))];case"Complex":return[r.complex(getParamValue("real",e,t,n),getParamValue("imag",e,t,n))];case"Cos":return[r.cos(getParamValue("x",e,t,n))];case"Cosh":return[r.cosh(getParamValue("x",e,t,n))];case"Elu":return[r.elu(getParamValue("x",e,t,n))];case"Erf":return[r.erf(getParamValue("x",e,t,n))];case"Exp":return[r.exp(getParamValue("x",e,t,n))];case"Expm1":{return[r.expm1(getParamValue("x",e,t,n))]}case"Floor":return[r.floor(getParamValue("x",e,t,n))];case"Log":return[r.log(getParamValue("x",e,t,n))];case"Log1p":{return[r.log1p(getParamValue("x",e,t,n))]}case"Imag":return[r.imag(getParamValue("x",e,t,n))];case"Neg":return[r.neg(getParamValue("x",e,t,n))];case"Reciprocal":{return[r.reciprocal(getParamValue("x",e,t,n))]}case"Real":return[r.real(getParamValue("x",e,t,n))];case"Relu":return[r.relu(getParamValue("x",e,t,n))];case"Round":{return[r.round(getParamValue("x",e,t,n))]}case"Selu":return[r.selu(getParamValue("x",e,t,n))];case"Sigmoid":return[r.sigmoid(getParamValue("x",e,t,n))];case"Sin":return[r.sin(getParamValue("x",e,t,n))];case"Sign":{return[r.sign(getParamValue("x",e,t,n))]}case"Sinh":{return[r.sinh(getParamValue("x",e,t,n))]}case"Softplus":{return[r.softplus(getParamValue("x",e,t,n))]}case"Sqrt":{return[r.sqrt(getParamValue("x",e,t,n))]}case"Square":{return[r.square(getParamValue("x",e,t,n))]}case"Tanh":{return[r.tanh(getParamValue("x",e,t,n))]}case"Tan":return[r.tan(getParamValue("x",e,t,n))];case"ClipByValue":return[r.clipByValue(getParamValue("x",e,t,n),getParamValue("clipValueMin",e,t,n),getParamValue("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(getParamValue("x",e,t,n))];case"Rsqrt":return[r.rsqrt(getTensor(e.inputNames[0],t,n))];case"Prod":return[r.prod(getParamValue("x",e,t,n),getParamValue("axes",e,t,n))];case"LeakyRelu":return[r.leakyRelu(getParamValue("x",e,t,n),getParamValue("alpha",e,t,n))];case"Prelu":return[r.prelu(getParamValue("x",e,t,n),getParamValue("alpha",e,t,n))];case"IsNan":return[r.isNaN(getTensor(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function inferElementShape(e,t,n){let r=mergeElementShape(e,n);const a=!fullDefinedShape(r);if(a&&t.length===0){throw new Error(`Tried to calculate elements of an empty list`+` with non-fully-defined elementShape: ${r}`)}if(a){t.forEach((e=>{r=mergeElementShape(e.shape,r)}))}if(!fullDefinedShape(r)){throw new Error(`Non-fully-defined elementShape: ${r}`)}return r}function mergeElementShape(e,t){if(typeof e==="number"){return t}if(typeof t==="number"){return e}if(e.length!==t.length){throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`)}const n=[];for(let r=0;r<e.length;++r){const a=e[r];const s=t[r];if(a>=0&&s>=0&&a!==s){throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`)}n[r]=a>=0?a:s}return n}class TensorArray{constructor(e,t,n,r,a,s,o){this.name=e;this.dtype=t;this.maxSize=n;this.elementShape=r;this.identicalElementShapes=a;this.dynamicSize=s;this.clearAfterRead=o;this.tensors=[];this.closed_=false;this.idTensor=scalar(0);keep(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{if(e==null||!e.has(t.tensor.id)){t.tensor.dispose()}}));this.tensors=[];this.closed_=true;this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_){throw new Error(`TensorArray ${this.name} has already been closed.`)}if(e<0||e>=this.size()){throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`)}const t=this.tensors[e];if(t.cleared){throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read `+`(perhaps try setting clear_after_read = false?).`)}if(this.clearAfterRead){t.cleared=true}t.read=true;return t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_){throw new Error(`TensorArray ${this.name} has already been closed.`)}if(e<0||!this.dynamicSize&&e>=this.maxSize){throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`)}const n=this.tensors[e]||{};if(t.dtype!==this.dtype){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`)}if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)){this.elementShape=t.shape}assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`);if(n.read){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`)}if(n.written){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`)}n.tensor=t;keep(t);n.written=true;this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length){throw new Error(`TensorArray ${this.name}: could not write multiple tensors,`+`because the index size: ${e.length} is not the same as tensors size: ${t.length}.`)}e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(!!t&&t!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`)}if(!e){e=[];for(let t=0;t<this.size();t++){e.push(t)}}else{e=e.slice(0,this.size())}if(e.length===0){return tensor([],[0].concat(this.elementShape))}const n=this.readMany(e);assertShapesMatchAllowUndefinedSize(this.elementShape,n[0].shape,"TensorArray shape mismatch: ");return stack(n,0)}concat(e){if(!!e&&e!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`)}if(this.size()===0){return tensor([],[0].concat(this.elementShape))}const t=[];for(let e=0;e<this.size();e++){t.push(e)}const n=this.readMany(t);assertShapesMatchAllowUndefinedSize(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`);return concat$1(n,0)}scatter(e,t){if(t.dtype!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`)}if(e.length!==t.shape[0]){throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`)}const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize){throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`)}this.writeMany(e,unstack(t,0))}split(e,t){if(t.dtype!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`)}let n=0;const r=e.map((e=>{n+=e;return n}));if(n!==t.shape[0]){throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`)}if(!this.dynamicSize&&e.length!==this.maxSize){throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), `+"and the TensorArray is not marked as dynamically resizeable")}const a=n===0?0:t.size/n;const s=[];tidy((()=>{t=reshape$1(t,[1,n,a]);for(let n=0;n<e.length;++n){const o=n===0?0:r[n-1];const i=[0,o,0];const u=[1,e[n],a];s[n]=reshape$1(slice$1(t,i,u),this.elementShape)}return s}));const o=[];for(let t=0;t<e.length;t++){o[t]=t}this.writeMany(o,s)}}class TensorList{constructor(e,t,n,r=-1){this.tensors=e;this.elementShape=t;this.elementDtype=n;if(e!=null){e.forEach((e=>{if(n!==e.dtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`)}assertShapesMatchAllowUndefinedSize(t,e.shape,"TensorList shape mismatch: ");keep(e)}))}this.idTensor=scalar(0);this.maxNumElements=r;keep(this.idTensor)}get id(){return this.idTensor.id}copy(){return new TensorList([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{if(e==null||!e.has(t.id)){t.dispose()}}));this.tensors.length=0;this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`)}if(n!==-1&&this.tensors.length!==n){throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`)}assertShapesMatchAllowUndefinedSize(e,this.elementShape,"TensorList shape mismatch: ");const r=inferElementShape(this.elementShape,this.tensors,e);return tidy((()=>{const e=this.tensors.map((e=>reshape$1(e,r)));return stack(e,0)}))}popBack(e,t){if(t!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`)}if(this.size()===0){throw new Error("Trying to pop from an empty list.")}const n=inferElementShape(this.elementShape,this.tensors,e);const r=this.tensors.pop();assertShapesMatchAllowUndefinedSize(r.shape,e,"TensorList shape mismatch: ");return reshape$1(r,n)}pushBack(e){if(e.dtype!==this.elementDtype){throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`)}assertShapesMatchAllowUndefinedSize(e.shape,this.elementShape,"TensorList shape mismatch: ");if(this.maxNumElements===this.size()){throw new Error(`Trying to push element into a full list.`)}keep(e);this.tensors.push(e)}resize(e){if(e<0){throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`)}if(this.maxNumElements!==-1&&e>this.maxNumElements){throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`)}const t=new TensorList([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n){t.tensors[n]=this.tensors[n]}return t}getItem(e,t,n){if(n!==this.elementDtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`)}if(e<0||e>this.tensors.length){throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`)}if(this.tensors[e]==null){throw new Error(`element at index ${e} is null.`)}assertShapesMatchAllowUndefinedSize(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=inferElementShape(this.elementShape,this.tensors,t);return reshape$1(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`)}if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements){throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`)}assertShapesMatchAllowUndefinedSize(this.elementShape,t.shape,"TensorList shape mismatch: ");keep(t);this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`)}assertShapesMatchAllowUndefinedSize(this.elementShape,n,"TensorList shape mismatch: ");e=e.slice(0,this.size());const r=inferElementShape(this.elementShape,this.tensors,n);if(e.length===0){return tensor([],[0].concat(r))}return tidy((()=>{const t=e.map((e=>reshape$1(this.tensors[e],r)));return stack(t,0)}))}concat(e,t){if(!!e&&e!==this.elementDtype){throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`)}assertShapesMatchAllowUndefinedSize(this.elementShape,t,"TensorList shape mismatch: ");const n=inferElementShape(this.elementShape,this.tensors,t);if(this.size()===0){return tensor([],[0].concat(n))}return tidy((()=>{const e=this.tensors.map((e=>reshape$1(e,n)));return concat$1(e,0)}))}}function fromTensor(e,t,n){const r=e.dtype;if(e.shape.length<1){throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`)}if(e.dtype!==n){throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`)}const a=e.shape.slice(1);assertShapesMatchAllowUndefinedSize(a,t,"TensorList shape mismatch: ");const s=unstack(e);return new TensorList(s,t,r)}function reserve(e,t,n,r){return new TensorList([],e,t,r)}function scatter(e,t,n,r){if(t.length!==e.shape[0]){throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`)}const a=Math.max(...t);if(r!=null&&r!==-1&&a>=r){throw new Error(`Max index must be < array size (${a}  vs. ${r})`)}const s=new TensorList([],n,e.dtype,r);const o=unstack(e,0);t.forEach(((e,t)=>{s.setItem(e,o[t])}));return s}const executeOp$h=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=getParamValue("thenBranch",e,t,n);const a=getParamValue("elseBranch",e,t,n);const s=getParamValue("cond",e,t,n);const o=getParamValue("args",e,t,n);const i=await s.data();if(i[0]){return n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}else{return n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}}case"While":case"StatelessWhile":{const r=getParamValue("body",e,t,n);const a=getParamValue("cond",e,t,n);const s=getParamValue("args",e,t,n);const o=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap);const i=s.map((e=>e.id));let u=await o[0].data();o.forEach((e=>{if(!e.kept&&i.indexOf(e.id)===-1){e.dispose()}}));let l=s;while(u[0]){const e=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{if(!e.kept&&i.indexOf(e.id)===-1&&t.indexOf(e.id)===-1){e.dispose()}}));const s=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await s[0].data();s.forEach((e=>{if(!e.kept&&i.indexOf(e.id)===-1&&t.indexOf(e.id)===-1){e.dispose()}}))}return l}case"LoopCond":{const r=getParamValue("pred",e,t,n);return[cloneTensor(r)]}case"Switch":{const r=getParamValue("pred",e,t,n);let a=getParamValue("data",e,t,n);if(!a.kept){a=cloneTensor(a)}return(await r.data())[0]?[undefined,a]:[a,undefined]}case"Merge":{const r=e.inputNames.find((e=>getTensor(e,t,n)!==undefined));if(r){const e=getTensor(r,t,n);return[cloneTensor(e)]}return undefined}case"Enter":{const r=getParamValue("frameName",e,t,n);const a=getParamValue("tensor",e,t,n);n.enterFrame(r);return[cloneTensor(a)]}case"Exit":{const r=getParamValue("tensor",e,t,n);n.exitFrame();return[cloneTensor(r)]}case"NextIteration":{const r=getParamValue("tensor",e,t,n);n.nextIteration();return[cloneTensor(r)]}case"TensorArrayV3":{const r=getParamValue("size",e,t,n);const a=getParamValue("dtype",e,t,n);const s=getParamValue("elementShape",e,t,n);const o=getParamValue("dynamicSize",e,t,n);const i=getParamValue("clearAfterRead",e,t,n);const u=getParamValue("identicalElementShapes",e,t,n);const l=getParamValue("name",e,t,n);const c=new TensorArray(l,a,r,s,u,o,i);n.addTensorArray(c);return[c.idTensor,scalar(1)]}case"TensorArrayWriteV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=getParamValue("index",e,t,n);const s=getParamValue("tensor",e,t,n);const o=n.getTensorArray(r.id);o.write(a,s);return[o.idTensor]}case"TensorArrayReadV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=getParamValue("index",e,t,n);const s=n.getTensorArray(r.id);return[s.read(a)]}case"TensorArrayGatherV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=getParamValue("indices",e,t,n);const s=getParamValue("dtype",e,t,n);const o=n.getTensorArray(r.id);return[o.gather(a,s)]}case"TensorArrayScatterV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=getParamValue("indices",e,t,n);const s=getParamValue("tensor",e,t,n);const o=n.getTensorArray(r.id);o.scatter(a,s);return[o.idTensor]}case"TensorArrayConcatV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=n.getTensorArray(r.id);const s=getParamValue("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=getParamValue("tensor",e,t,n);const s=getParamValue("lengths",e,t,n);const o=n.getTensorArray(r.id);o.split(s,a);return[o.idTensor]}case"TensorArraySizeV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=n.getTensorArray(r.id);return[scalar(a.size(),"int32")]}case"TensorArrayCloseV3":{const r=getParamValue("tensorArrayId",e,t,n);const a=n.getTensorArray(r.id);a.clearAndClose();return[a.idTensor]}case"TensorListSetItem":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("index",e,t,n);const s=getParamValue("tensor",e,t,n);const o=n.getTensorList(r.id);o.setItem(a,s);return[o.idTensor]}case"TensorListGetItem":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("index",e,t,n);const s=getParamValue("elementShape",e,t,n);const o=getParamValue("elementDType",e,t,n);const i=n.getTensorList(r.id);return[i.getItem(a,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=getParamValue("indices",e,t,n);const a=getParamValue("tensor",e,t,n);const s=getParamValue("elementShape",e,t,n);const o=getParamValue("numElements",e,t,n);const i=scatter(a,r,s,o);n.addTensorList(i);return[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=getParamValue("elementShape",e,t,n);const a=getParamValue("elementDType",e,t,n);let s;if(e.op==="TensorListReserve"){s="numElements"}else{s="maxNumElements"}const o=getParamValue(s,e,t,n);const i=e.op==="TensorListReserve"?-1:o;const u=reserve(r,a,o,i);n.addTensorList(u);return[u.idTensor]}case"TensorListGather":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("indices",e,t,n);const s=getParamValue("elementShape",e,t,n);const o=getParamValue("elementDType",e,t,n);const i=n.getTensorList(r.id);return[i.gather(a,o,s)]}case"TensorListStack":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("elementShape",e,t,n);const s=getParamValue("elementDType",e,t,n);const o=getParamValue("numElements",e,t,n);const i=n.getTensorList(r.id);return[i.stack(a,s,o)]}case"TensorListFromTensor":{const r=getParamValue("tensor",e,t,n);const a=getParamValue("elementShape",e,t,n);const s=getParamValue("elementDType",e,t,n);const o=fromTensor(r,a,s);n.addTensorList(o);return[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=getParamValue("tensorListId",e,t,n);const a=n.getTensorList(r.id);const s=getParamValue("dtype",e,t,n);const o=getParamValue("elementShape",e,t,n);return[a.concat(s,o)]}case"TensorListPushBack":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("tensor",e,t,n);const s=n.getTensorList(r.id);s.pushBack(a);return[s.idTensor]}case"TensorListPopBack":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("elementShape",e,t,n);const s=getParamValue("elementDType",e,t,n);const o=n.getTensorList(r.id);return[o.popBack(a,s)]}case"TensorListSplit":{const r=getParamValue("tensor",e,t,n);const a=getParamValue("elementShape",e,t,n);const s=getParamValue("lengths",e,t,n);const o=split$1(r,s,a);n.addTensorList(o);return[o.idTensor]}case"TensorListLength":{const r=getParamValue("tensorListId",e,t,n);const a=n.getTensorList(r.id);return[scalar(a.size(),"int32")]}case"TensorListResize":{const r=getParamValue("tensorListId",e,t,n);const a=getParamValue("size",e,t,n);const s=n.getTensorList(r.id);const o=s.resize(a);n.addTensorList(o);return[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$g=(e,t,n,r=tfOps)=>{switch(e.op){case"Conv1D":{const a=getParamValue("stride",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("dataFormat",e,t,n).toUpperCase();const i=getParamValue("dilation",e,t,n);return[r.conv1d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),a,s,o,i)]}case"Conv2D":{const a=getParamValue("strides",e,t,n);const s=getPadding(e,t,n);const o=getParamValue("dataFormat",e,t,n).toUpperCase();const i=getParamValue("dilations",e,t,n);return[r.conv2d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=fusedConvAndDepthWiseParams(e,t,n);return[r.fused.conv2d({x:getParamValue("x",e,t,n),filter:getParamValue("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=fusedConvAndDepthWiseParams(e,t,n);return[r.fused.depthwiseConv2d({x:getParamValue("x",e,t,n),filter:getParamValue("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=getParamValue("outputShape",e,t,n);const s=getParamValue("strides",e,t,n);const o=getPadding(e,t,n);return[r.conv2dTranspose(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),a,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=getParamValue("strides",e,t,n);const s=getPadding(e,t,n);const o=getParamValue("dilations",e,t,n);const i=getParamValue("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(getParamValue("input",e,t,n),getParamValue("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("dataFormat",e,t,n).toUpperCase();const i=getParamValue("dilations",e,t,n);return[r.conv3d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[a[1],a[2],a[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return[r.avgPool(getParamValue("x",e,t,n),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return[r.maxPool(getParamValue("x",e,t,n),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);const i=getParamValue("includeBatchInIndex",e,t,n);const{result:u,indexes:l}=r.maxPoolWithArgmax(getParamValue("x",e,t,n),[o[1],o[2]],[a[1],a[2]],s,i);return[u,l]}case"AvgPool3D":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return[r.avgPool3d(getParamValue("x",e,t,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("kernelSize",e,t,n);return[r.maxPool3d(getParamValue("x",e,t,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=getParamValue("strides",e,t,n);const s=getParamValue("pad",e,t,n);const o=getParamValue("dilations",e,t,n);const i=a[1];const u=a[2];const l=o[1];const c=o[2];return[r.dilation2d(getParamValue("x",e,t,n),getParamValue("filter",e,t,n),[i,u],s,[l,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$f=(e,t,n,r=tfOps)=>{switch(e.op){case"Fill":{const a=getParamValue("shape",e,t,n);const s=getParamValue("dtype",e,t,n);const o=getParamValue("value",e,t,n);return[r.fill(a,o,s)]}case"LinSpace":{const a=getParamValue("start",e,t,n);const s=getParamValue("stop",e,t,n);const o=getParamValue("num",e,t,n);return[r.linspace(a,s,o)]}case"Multinomial":{const a=getParamValue("logits",e,t,n);const s=getParamValue("numSamples",e,t,n);const o=getParamValue("seed",e,t,n);return[r.multinomial(a,s,o)]}case"OneHot":{const a=getParamValue("indices",e,t,n);const s=getParamValue("depth",e,t,n);const o=getParamValue("onValue",e,t,n);const i=getParamValue("offValue",e,t,n);return[r.oneHot(a,s,o,i)]}case"Ones":{return[r.ones(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n))]}case"OnesLike":{return[r.onesLike(getParamValue("x",e,t,n))]}case"RandomStandardNormal":{return[r.randomStandardNormal(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n),getParamValue("seed",e,t,n))]}case"RandomUniform":{return[r.randomUniform(getParamValue("shape",e,t,n),getParamValue("minval",e,t,n),getParamValue("maxval",e,t,n),getParamValue("dtype",e,t,n))]}case"Range":{const a=getParamValue("start",e,t,n);const s=getParamValue("stop",e,t,n);const o=getParamValue("step",e,t,n);return[r.range(a,s,o,getParamValue("dtype",e,t,n))]}case"TruncatedNormal":{const a=getParamValue("shape",e,t,n);const s=getParamValue("mean",e,t,n);const o=getParamValue("stdDev",e,t,n);const i=getParamValue("seed",e,t,n);return[r.truncatedNormal(a,s,o,getParamValue("dtype",e,t,n),i)]}case"Zeros":{return[r.zeros(getParamValue("shape",e,t,n),getParamValue("dtype",e,t,n))]}case"ZerosLike":{return[r.zerosLike(getParamValue("x",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$e=async(e,t,n,r,a=tfOps)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=nmsParams(e,t,n);const c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,o,i,u,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=nmsParams(e,t,n);const l=getParamValue("padToMaxOutputSize",e,t,n);const c=await a.image.nonMaxSuppressionPaddedAsync(r,s,o,i,u,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=nmsParams(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,o,i,u)]}case"Where":{const r=a.cast(getParamValue("condition",e,t,n),"bool");const s=[await a.whereAsync(r)];r.dispose();return s}case"ListDiff":{return a.setdiff1dAsync(getParamValue("x",e,t,n),getParamValue("y",e,t,n))}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$d=(e,t,n,r=tfOps)=>{switch(e.op){case"LowerBound":{const a=getParamValue("sortedSequence",e,t,n);const s=getParamValue("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=getParamValue("x",e,t,n);const s=getParamValue("k",e,t,n);const o=getParamValue("sorted",e,t,n);const i=r.topk(a,s,o);return[i.values,i.indices]}case"UpperBound":{const a=getParamValue("sortedSequence",e,t,n);const s=getParamValue("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{const a=getParamValue("x",e,t,n);const s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=getParamValue("x",e,t,n);const s=getParamValue("axis",e,t,n);const o=r.unique(a,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$c=(e,t,n,r=tfOps)=>{switch(e.op){case"Const":{return t[e.name]}case"PlaceholderWithDefault":const a=getParamValue("default",e,t,n);return[getTensor(e.name,t,n)||a];case"Placeholder":return[getTensor(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const r=getParamValue("x",e,t,n);return[cloneTensor(r)]}case"IdentityN":return getParamValue("x",e,t,n).map((e=>cloneTensor(e)));case"Snapshot":const s=getParamValue("x",e,t,n);return[cloneTensor(s)];case"Shape":return[r.tensor1d(getParamValue("x",e,t,n).shape,"int32")];case"ShapeN":return getParamValue("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(getParamValue("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(getParamValue("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=getParamValue("x",e,t,n);const i=getParamValue("data",e,t,n);const u=getParamValue("message",e,t,n);const l=getParamValue("summarize",e,t,n);console.warn("The graph has a tf.print() operation,"+"usually used for debugging, which slows down performance.");console.log(u);for(let e=0;e<i.length;e++){console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l))}return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}};class HashTable{constructor(e,t){this.keyDType=e;this.valueDType=t;this.handle=scalar(0);this.tensorMap=new Map;keep(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose()));this.tensorMap.clear();this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return scalar(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();this.tensorMap.forEach((e=>e.dispose()));this.tensorMap.clear();return tidy((()=>{const e=unstack(t);const r=n.length;const a=e.length;assert(r===a,(()=>`The number of elements doesn't match, keys has `+`${r} elements, the values has ${a} `+`elements.`));for(let t=0;t<r;t++){const r=n[t];const a=e[t];keep(a);this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return tidy((()=>{const e=[];for(let r=0;r<n.length;r++){const a=n[r];const s=this.findWithDefault(a,t);e.push(s)}return stack(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType){throw new Error(`Expect key dtype ${this.keyDType}, but got `+`${e.dtype}`)}if(t.dtype!==this.valueDType){throw new Error(`Expect value dtype ${this.valueDType}, but got `+`${t.dtype}`)}}}const executeOp$b=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=getParamValue("keyDType",e,t,n);const s=getParamValue("valueDType",e,t,n);const o=new HashTable(a,s);r.addHashTable(e.name,o);return[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const a=getParamValue("tableHandle",e,t,n,r);const s=getParamValue("keys",e,t,n);const o=getParamValue("values",e,t,n);const i=r.getHashTableById(a.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=getParamValue("tableHandle",e,t,n,r);const s=getParamValue("keys",e,t,n);const o=getParamValue("defaultValue",e,t,n);const i=r.getHashTableById(a.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=getParamValue("tableHandle",e,t,n,r);const s=r.getHashTableById(a.id);return[s.tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$a=(e,t,n,r=tfOps)=>{switch(e.op){case"ResizeBilinear":{const a=getParamValue("images",e,t,n);const s=getParamValue("size",e,t,n);const o=getParamValue("alignCorners",e,t,n);const i=getParamValue("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const a=getParamValue("images",e,t,n);const s=getParamValue("size",e,t,n);const o=getParamValue("alignCorners",e,t,n);const i=getParamValue("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],o,i)]}case"CropAndResize":{const a=getParamValue("image",e,t,n);const s=getParamValue("boxes",e,t,n);const o=getParamValue("boxInd",e,t,n);const i=getParamValue("cropSize",e,t,n);const u=getParamValue("method",e,t,n);const l=getParamValue("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,o,i,u,l)]}case"ImageProjectiveTransformV3":{const a=getParamValue("images",e,t,n);const s=getParamValue("transforms",e,t,n);const o=getParamValue("outputShape",e,t,n);const i=getParamValue("fillValue",e,t,n);const u=getParamValue("interpolation",e,t,n);const l=getParamValue("fillMode",e,t,n);return[r.image.transform(a,s,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$9=(e,t,n,r=tfOps)=>{switch(e.op){case"Equal":{return[r.equal(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"NotEqual":{return[r.notEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Greater":{return[r.greater(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"GreaterEqual":{return[r.greaterEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Less":{return[r.less(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"LessEqual":{return[r.lessEqual(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"LogicalAnd":{return[r.logicalAnd(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"LogicalNot":{return[r.logicalNot(getParamValue("a",e,t,n))]}case"LogicalOr":{return[r.logicalOr(getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}case"Select":case"SelectV2":{return[r.where(getParamValue("condition",e,t,n),getParamValue("a",e,t,n),getParamValue("b",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$8=(e,t,n,r=tfOps)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(getParamValue("a",e,t,n),getParamValue("b",e,t,n),getParamValue("transposeA",e,t,n),getParamValue("transposeB",e,t,n))];case"Einsum":return[r.einsum(getParamValue("equation",e,t,n),...getParamValue("tensors",e,t,n))];case"Transpose":return[r.transpose(getParamValue("x",e,t,n),getParamValue("perm",e,t,n))];case"_FusedMatMul":const[a,s]=getParamValue("fusedOps",e,t,n);const o=a==="biasadd";const i=s==="prelu";const u=getParamValue("numArgs",e,t,n);const l=getParamValue("leakyreluAlpha",e,t,n);if(o){if(i&&u!==2){throw new Error("Fused MatMul with BiasAdd and Prelu must have two "+"extra arguments: bias and alpha.")}if(!i&&u!==1){throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}}const[c,p]=getParamValue("args",e,t,n);return[r.fused.matMul({a:getParamValue("a",e,t,n),b:getParamValue("b",e,t,n),transposeA:getParamValue("transposeA",e,t,n),transposeB:getParamValue("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:p,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$7=(e,t,n,r=tfOps)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(getParamValue("x",e,t,n),getParamValue("axis",e,t,n),getParamValue("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":{return[r.batchNorm(getParamValue("x",e,t,n),getParamValue("mean",e,t,n),getParamValue("variance",e,t,n),getParamValue("offset",e,t,n),getParamValue("scale",e,t,n),getParamValue("epsilon",e,t,n))]}case"FusedBatchNormV3":{return[r.batchNorm(getParamValue("x",e,t,n),getParamValue("mean",e,t,n),getParamValue("variance",e,t,n),getParamValue("offset",e,t,n),getParamValue("scale",e,t,n),getParamValue("epsilon",e,t,n))]}case"LRN":{return[r.localResponseNormalization(getParamValue("x",e,t,n),getParamValue("radius",e,t,n),getParamValue("bias",e,t,n),getParamValue("alpha",e,t,n),getParamValue("beta",e,t,n))]}case"Softmax":{return[r.softmax(getParamValue("x",e,t,n))]}case"LogSoftmax":{return[r.logSoftmax(getParamValue("x",e,t,n))]}case"SparseToDense":{return[r.sparseToDense(getParamValue("sparseIndices",e,t,n),getParamValue("outputShape",e,t,n),getParamValue("sparseValues",e,t,n),getParamValue("defaultValue",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$6=(e,t,n,r=tfOps)=>{switch(e.op){case"Max":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.max(getParamValue("x",e,t,n),a,s)]}case"Mean":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.mean(getParamValue("x",e,t,n),a,s)]}case"Min":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.min(getParamValue("x",e,t,n),a,s)]}case"Sum":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.sum(getParamValue("x",e,t,n),a,s)]}case"All":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.all(getParamValue("x",e,t,n),a,s)]}case"Any":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.any(getParamValue("x",e,t,n),a,s)]}case"ArgMax":{const a=getParamValue("axis",e,t,n);return[r.argMax(getParamValue("x",e,t,n),a)]}case"ArgMin":{const a=getParamValue("axis",e,t,n);return[r.argMin(getParamValue("x",e,t,n),a)]}case"Prod":{const a=getParamValue("axis",e,t,n);const s=getParamValue("keepDims",e,t,n);return[r.prod(getParamValue("x",e,t,n),a,s)]}case"Cumprod":{const a=getParamValue("axis",e,t,n);const s=getParamValue("exclusive",e,t,n);const o=getParamValue("reverse",e,t,n);return[r.cumprod(getParamValue("x",e,t,n),a,s,o)]}case"Cumsum":{const a=getParamValue("axis",e,t,n);const s=getParamValue("exclusive",e,t,n);const o=getParamValue("reverse",e,t,n);return[r.cumsum(getParamValue("x",e,t,n),a,s,o)]}case"Bincount":const a=getParamValue("x",e,t,n);const s=getParamValue("weights",e,t,n);const o=getParamValue("size",e,t,n);return[r.bincount(a,s,o)];case"DenseBincount":{const a=getParamValue("x",e,t,n);const s=getParamValue("weights",e,t,n);const o=getParamValue("size",e,t,n);const i=getParamValue("binaryOutput",e,t,n);return[r.denseBincount(a,s,o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$5=(e,t,n,r=tfOps)=>{switch(e.op){case"ConcatV2":case"Concat":{const a=getParamValue("n",e,t,n);const s=getParamValue("axis",e,t,n);let o=getParamValue("tensors",e,t,n);o=o.slice(0,a);return[r.concat(o,s)]}case"Gather":{const a=getParamValue("x",e,t,n);const s=getParamValue("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=getParamValue("axis",e,t,n);const s=getParamValue("batchDims",e,t,n);const o=getParamValue("x",e,t,n);const i=getParamValue("indices",e,t,n);return[r.gather(o,r.cast(i,"int32"),a,s)]}case"Reverse":{const a=getParamValue("dims",e,t,n);const s=[];for(let e=0;e<a.length;e++){if(a[e]){s.push(e)}}const o=getParamValue("x",e,t,n);return[r.reverse(o,s)]}case"ReverseV2":{const a=getParamValue("axis",e,t,n);const s=getParamValue("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{const a=getParamValue("begin",e,t,n);const s=getParamValue("size",e,t,n);return[r.slice(getParamValue("x",e,t,n),a,s)]}case"StridedSlice":{const a=getParamValue("begin",e,t,n);const s=getParamValue("end",e,t,n);const o=getParamValue("strides",e,t,n);const i=getParamValue("beginMask",e,t,n);const u=getParamValue("endMask",e,t,n);const l=getParamValue("ellipsisMask",e,t,n);const c=getParamValue("newAxisMask",e,t,n);const p=getParamValue("shrinkAxisMask",e,t,n);const m=getParamValue("x",e,t,n);return[r.stridedSlice(m,a,s,o,i,u,l,c,p)]}case"Pack":{return tidy((()=>{const a=getParamValue("axis",e,t,n);const s=getParamValue("tensors",e,t,n);const o=s[0].shape;const i=r.squeeze(s[0]).shape;const u=s.map((e=>{const t=arraysEqual(e.shape,o);if(!t&&!arraysEqual(r.squeeze(e).shape,i)){throw new Error("the input tensors shape does not match")}return t?e:r.reshape(e,o)}));return[r.stack(u,a)]}))}case"Unpack":{const a=getParamValue("axis",e,t,n);const s=getParamValue("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{const a=getParamValue("reps",e,t,n);return[r.tile(getParamValue("x",e,t,n),a)]}case"Split":case"SplitV":{const a=getParamValue("axis",e,t,n);const s=getParamValue("numOrSizeSplits",e,t,n);const o=getParamValue("x",e,t,n);return r.split(o,s,a)}case"ScatterNd":{const a=getParamValue("indices",e,t,n);const s=getParamValue("values",e,t,n);const o=getParamValue("shape",e,t,n);return[r.scatterND(a,s,o)]}case"GatherNd":{const a=getParamValue("x",e,t,n);const s=getParamValue("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=getParamValue("sparseIndices",e,t,n);const s=getParamValue("outputShape",e,t,n);const o=getParamValue("sparseValues",e,t,n);const i=getParamValue("defaultValue",e,t,n);return[r.sparseToDense(a,o,s,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$4=(e,t,n,r=tfOps)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(getParamValue("indices",e,t,n),getParamValue("values",e,t,n),getParamValue("denseShape",e,t,n),getParamValue("defaultValue",e,t,n));return[a,s,o,i]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(getParamValue("inputIndices",e,t,n),getParamValue("inputShape",e,t,n),getParamValue("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":{const a=r.sparse.sparseSegmentMean(getParamValue("data",e,t,n),getParamValue("indices",e,t,n),getParamValue("segmentIds",e,t,n));return[a]}case"SparseSegmentSum":{const a=r.sparse.sparseSegmentSum(getParamValue("data",e,t,n),getParamValue("indices",e,t,n),getParamValue("segmentIds",e,t,n));return[a]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$3=(e,t,n,r=tfOps)=>{switch(e.op){case"FFT":{return[r.fft(getParamValue("x",e,t,n))]}case"IFFT":{return[r.ifft(getParamValue("x",e,t,n))]}case"RFFT":{return[r.rfft(getParamValue("x",e,t,n))]}case"IRFFT":{return[r.irfft(getParamValue("x",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$2=(e,t,n,r=tfOps)=>{switch(e.op){case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(getParamValue("data",e,t,n),getParamValue("dataSplits",e,t,n),getParamValue("separator",e,t,n),getParamValue("nGramWidths",e,t,n),getParamValue("leftPad",e,t,n),getParamValue("rightPad",e,t,n),getParamValue("padWidth",e,t,n),getParamValue("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:o}=r.string.stringSplit(getParamValue("input",e,t,n),getParamValue("delimiter",e,t,n),getParamValue("skipEmpty",e,t,n));return[a,s,o]}case"StringToHashBucketFast":{const a=r.string.stringToHashBucketFast(getParamValue("input",e,t,n),getParamValue("numBuckets",e,t,n));return[a]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const executeOp$1=(e,t,n,r=tfOps)=>{switch(e.op){case"Cast":{return[r.cast(getParamValue("x",e,t,n),getParamValue("dtype",e,t,n))]}case"ExpandDims":{const a=getParamValue("axis",e,t,n);return[r.expandDims(getParamValue("x",e,t,n),a)]}case"Squeeze":{const a=getParamValue("axis",e,t,n);return[r.squeeze(getParamValue("x",e,t,n),a)]}case"Reshape":{return[r.reshape(getParamValue("x",e,t,n),getParamValue("shape",e,t,n))]}case"MirrorPad":{return[r.mirrorPad(getParamValue("x",e,t,n),getParamValue("padding",e,t,n),getParamValue("mode",e,t,n))]}case"PadV2":case"Pad":{return[r.pad(getParamValue("x",e,t,n),getParamValue("padding",e,t,n),getParamValue("constantValue",e,t,n))]}case"SpaceToBatchND":{const a=getParamValue("blockShape",e,t,n);const s=getParamValue("paddings",e,t,n);return[r.spaceToBatchND(getParamValue("x",e,t,n),a,s)]}case"BatchToSpaceND":{const a=getParamValue("blockShape",e,t,n);const s=getParamValue("crops",e,t,n);return[r.batchToSpaceND(getParamValue("x",e,t,n),a,s)]}case"DepthToSpace":{const a=getParamValue("blockSize",e,t,n);const s=getParamValue("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(getParamValue("x",e,t,n),a,s)]}case"BroadcastTo":{return[r.broadcastTo(getParamValue("x",e,t,n),getParamValue("shape",e,t,n))]}case"BroadcastArgs":{return[r.broadcastArgs(getParamValue("s0",e,t,n),getParamValue("s1",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function executeOp(e,t,n,r,a=tidy){const s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>executeOp$j(e,t,n)));case"basic_math":return a((()=>executeOp$i(e,t,n)));case"control":return executeOp$h(e,t,n);case"convolution":return a((()=>executeOp$g(e,t,n)));case"creation":return a((()=>executeOp$f(e,t,n)));case"dynamic":return executeOp$e(e,t,n);case"evaluation":return a((()=>executeOp$d(e,t,n)));case"image":return a((()=>executeOp$a(e,t,n)));case"graph":return a((()=>executeOp$c(e,t,n)));case"logical":return a((()=>executeOp$9(e,t,n)));case"matrices":return a((()=>executeOp$8(e,t,n)));case"normalization":return a((()=>executeOp$7(e,t,n)));case"reduction":return a((()=>executeOp$6(e,t,n)));case"slice_join":return a((()=>executeOp$5(e,t,n)));case"sparse":return a((()=>executeOp$4(e,t,n)));case"spectral":return a((()=>executeOp$3(e,t,n)));case"string":return a((()=>executeOp$2(e,t,n)));case"transformation":return a((()=>executeOp$1(e,t,n)));case"hash_table":return executeOp$b(e,t,n,r);case"custom":const s=getRegisteredOp(e.op);if(s&&s.customExecutor){return s.customExecutor(new NodeValueImpl(e,t,n))}else{throw TypeError(`Custom op ${e.op} is not registered.`)}default:throw TypeError(`Unknown op '${e.op}'. File an issue at `+`https://github.com/tensorflow/tfjs/issues so we can add it`+`, or register a custom execution with tf.registerOp()`)}})(e,t,n);if(isPromise(s)){return s.then((e=>[].concat(e)))}return[].concat(s)}class ExecutionContext{constructor(e={},t={},n={},r={}){this.weightMap=e;this.tensorArrayMap=t;this.tensorListMap=n;this.functionMap=r;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){if(this.contexts!==e){this.contexts=e;this.generateCurrentContextIds()}}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push("");this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){if(this.contexts){this.lastId++;this.contexts=this.contexts.slice();this.contexts.push(this.newFrame(this.lastId,e));this._currentContextIds.unshift(this.contextIdforContexts(this.contexts))}}exitFrame(){if(this.contexts&&this.contexts.length>1){this.contexts=this.contexts.slice();this.contexts.splice(-1);this.currentContextIds.shift()}else{throw new Error("Cannot exit frame, the context is empty")}}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice();this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1;e.id=this.lastId;this.contexts.splice(-1,1,e);this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else{throw new Error("Cannot increase frame iteration, the context is empty")}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap){this.tensorArrayMap[t].clearAndClose(e)}for(const t in this.tensorListMap){this.tensorListMap[t].clearAndClose(e)}}}function getExecutionSubgraph(e,t,n,r){const a=new Set;const s=[];let o=null;let i=null;const u=new Set;const l=Object.keys(e).map((e=>parseNodeName(e)[0]));let c=[];if(r!=null){c=r.map((e=>parseNodeName(e.name)[0]))}const p=[...t];while(p.length>0){const e=p.pop();if(isControlFlow(e)||isDynamicShape(e)||isHashTable(e)){if(o==null){o=e;i=o.children.map((e=>e.name)).filter((e=>a.has(e)))}}a.add(e.name);if(n[e.name]!=null){continue}if(l.indexOf(e.name)!==-1){continue}if(c.indexOf(e.name)!==-1){continue}if(e.inputs.length===0){s.push(e.name);continue}e.inputs.forEach((e=>{if(u.has(e.name)){return}u.add(e.name);p.push(e)}))}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:o,syncInputs:i}}function getNodesInTopologicalOrder(e,t,n){const{usedNodes:r,inputs:a}=n;const s=[];const o=Object.keys(a).map((e=>parseNodeName(e)[0])).map((t=>e.nodes[t]));const i=e.initNodes;o.forEach((e=>{if(r.has(e.name)){s.push(e)}}));e.weights.forEach((e=>{if(r.has(e.name)){s.push(e)}}));if(i!=null){i.forEach((e=>{if(r.has(e.name)){s.push(e)}}))}const u=new Set;const l=[];while(s.length>0){const e=s.pop();u.add(e.name);if(!t[e.name]){l.push(e)}e.children.forEach((e=>{if(!u.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>u.has(e.name)))){s.push(e)}}))}return l}const CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"];const DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];const HASH_TABLE_OPS=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function isControlFlow(e){return CONTROL_FLOW_OPS.indexOf(e.op)>=0}function isDynamicShape(e){return DYNAMIC_SHAPE_OPS.indexOf(e.op)>=0}function isHashTable(e){return HASH_TABLE_OPS.indexOf(e.op)>=0}class GraphExecutor{constructor(e,t){this.graph=e;this.parent=t;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this.intermediateTensors={};this.keepTensorForDebug=false;this._outputs=e.outputs;this._inputs=e.inputs;this._initNodes=e.initNodes;this._signature=e.signature;this._functions=e.functions;if(e.functions!=null){Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new GraphExecutor(e.functions[t],this)}))}}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t);this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:undefined,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:undefined})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams["shape"]?e.attrParams["shape"].value:undefined,dtype:e.attrParams["dtype"]?e.attrParams["dtype"].value:undefined})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>{e[t]=this._functions[t].signature;return e}),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort();const r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=getExecutionSubgraph(e,t,this.weightMap,this._initNodes);const{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(a!=null){throw new Error(`This execution contains the node '${a.name}', which has `+`the dynamic op '${a.op}'. Please use `+`model.executeAsync() instead. Alternatively, to avoid the `+`dynamic ops, specify the inputs [${s}]`)}if(r.length>0){const n=t.map((e=>e.name));const a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs `+`[${a}]. Missing the following inputs: [${r}]`)}return getNodesInTopologicalOrder(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e);this.checkInputShapeAndType(e);t=this.mapOutputs(t);this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[parseNodeName(e)[0]]));const a=t.map((e=>parseNodeName(e)[0]));let s=a.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors();if(s.length===0){s=this._outputs}const o=this.getCompilationKey(r,s);let i=this.compiledMap.get(o);if(i==null){i=this.compile(e,s);this.compiledMap.set(o,i)}const u={};const l={};return tidy((()=>{const n=new ExecutionContext(this.weightMap,u,l,this.functionExecutorMap);const r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=parseNodeName(t);const s=[];s[a]=e[t];r[n]=s}));const s=this.getFrozenTensorIds(r);const o={};for(let e=0;e<i.length;e++){const t=i[e];if(!r[t.name]){const e=executeOp(t,r,n,this._resourceManager);if(isPromise(e)){throw new Error(`The execution of the op '${t.op}' returned a promise. `+`Please use model.executeAsync() instead.`)}r[t.name]=e;this.checkTensorForDisposal(t.name,t,r,n,s,a,o)}}if(this.parent==null){n.dispose(s)}return t.map((e=>getTensor(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,o){if(t.category==="control"||s.indexOf(e)!==-1){return}n[e].forEach((e=>{if(e!=null){o[e.id]=(o[e.id]||0)+t.children.length}}));t.inputs.forEach((e=>{if(e.category!=="control"){const s=getTensorsForCurrentContenxt(e.name,n,r);if(s!=null){s.forEach((e=>{if(e&&!e.kept&&!a.has(e.id)){const n=o[e.id];if(n===1){if(!this.keepTensorForDebug){e.dispose()}else{const[n,a]=getNodeNameAndIndex(t.name,r);if(this.intermediateTensors[n]){this.intermediateTensors[n][a]=e}else{this.intermediateTensors[n]=[];this.intermediateTensors[n][a]=e}}delete o[e.id]}else if(n!=null){o[e.id]--}}}))}}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){if(!this.intermediateTensors){return}Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose()))));this.disposeTensorsMap()}disposeTensorsMap(){if(!this.tensorsMap){return}Object.keys(this.tensorsMap).forEach((e=>{const t=this.tensorsMap[e];t.forEach((e=>{if(e&&!e.kept&&!e.isDisposed&&!this.keepIds.has(e.id)){e.dispose()}}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors){this.intermediateTensors[e].forEach((e=>e.dispose()));delete this.intermediateTensors[e]}}async _executeAsync(e,t,n=false,r={},a={}){if(!n){e=this.mapInputs(e);this.checkInputs(e);this.checkInputShapeAndType(e);t=this.mapOutputs(t);this.checkOutputs(t)}try{this.keepTensorForDebug=env().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){console.warn(e.message)}this.resetIntermediateTensors();const s=new ExecutionContext(this.weightMap,r,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);const o=t.map((e=>getTensor(e,this.tensorsMap,s)));const i=o.map((e=>e.id));const u=Object.keys(e).map((t=>e[t].id));this.keepIds=new Set([...i,...u,...this.weightIds]);if(!this.keepTensorForDebug){this.disposeTensorsMap()}if(this.parent==null){s.dispose(this.keepIds)}return o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>{e[this.inputs[n].name]=t;return e}),{});return this._executeAsync(r,this.outputNodes,true,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e);const s=a.map((e=>this.graph.nodes[parseNodeName(e)[0]]));const o=n.map((e=>parseNodeName(e)[0]));let i=o.map((e=>this.graph.nodes[e]));if(i.length===0){i=this._outputs}const{usedNodes:u,missingInputs:l,dynamicNode:c,syncInputs:p}=getExecutionSubgraph(e,i,this.weightMap,this._initNodes);const m=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext})));const d=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=parseNodeName(t);const a=[];a[r]=e[t];d[n]=a}));const h={};const f=this.getFrozenTensorIds(d);const g={};while(m.length>0){const e=this.processStack(s,m,t,d,g,f,o,h,u);await Promise.all(e)}if(c==null&&!r){console.warn(`This model execution did not contain any nodes with control flow `+`or dynamic output shapes. You can use model.execute() instead.`)}const y=i.filter((e=>!isControlFlow(e)&&!getTensor(e.name,d,t))).map((e=>e.name));if(y.length>0){let e="";if(c!=null){e=`Alternatively, to avoid the dynamic ops, use model.execute() `+`and specify the inputs [${p}]`}throw new Error(`Cannot compute the outputs [${y}] from the provided `+`inputs [${a}]. Consider providing the following inputs: `+`[${l}]. ${e}`)}return d}processStack(e,t,n,r,a,s,o,i,u){const l=[];while(t.length>0){const e=t.pop();n.currentContext=e.contexts;let c="";if(e.node.op==="Enter"&&getParamValue("isConstant",e.node,r,n)){[c]=getNodeNameAndIndex(e.node.name,n)}if(r[e.node.name]==null){const p=executeOp(e.node,r,n,this._resourceManager);if(!c){[c]=getNodeNameAndIndex(e.node.name,n)}const m=n.currentContext;if(isPromise(p)){l.push(p.then((l=>{r[c]=l;n.currentContext=m;this.checkTensorForDisposal(c,e.node,r,n,s,o,i);this.processChildNodes(e.node,t,n,r,a,u);return l})))}else{r[c]=p;this.checkTensorForDisposal(c,e.node,r,n,s,o,i);this.processChildNodes(e.node,t,n,r,a,u)}}else{this.processChildNodes(e.node,t,n,r,a,u)}}return l}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{const[o]=getNodeNameAndIndex(e.name,n);if(a[o]||!s.has(e.name)){return}if(e.op==="Merge"){if(e.inputNames.some((e=>!!getTensor(e,r,n)))){a[o]=true;t.push({contexts:n.currentContext,node:e})}}else if(e.inputNames.every((e=>!!getTensor(e,r,n)))){a[o]=true;t.push({contexts:n.currentContext,node:e})}}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t];const[r]=parseNodeName(t);const a=this.graph.nodes[r];if(a.attrParams["shape"]&&a.attrParams["shape"].value){const e=a.attrParams["shape"].value;const t=e.length===n.shape.length&&n.shape.every(((t,n)=>e[n]===-1||e[n]===t));assert(t,(()=>`The shape of dict['${a.name}'] provided in `+`model.execute(dict) must be [${e}], but was `+`[${n.shape}]`))}if(a.attrParams["dtype"]&&a.attrParams["dtype"].value){assert(n.dtype===a.attrParams["dtype"].value,(()=>`The dtype of dict['${a.name}'] provided in `+`model.execute(dict) must be `+`${a.attrParams["dtype"].value}, but was ${n.dtype}`))}}))}mapInputs(e){const t={};for(const n in e){if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){const r=this._signature.inputs[n];t[r.name]=e[n]}else{t[n]=e[n]}}return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=parseNodeName(e);return this.graph.nodes[t]==null}));if(t.length>0){throw new Error(`The dict provided in model.execute(dict) has `+`keys: [${t}] that are not part of graph`)}}mapOutputs(e){return e.map((e=>{if(this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null){const t=this._signature.outputs[e];return t.name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=parseNodeName(e);if(!this.graph.nodes[t]){throw new Error(`The output '${e}' is not found in the graph`)}}))}}class ResourceManager{constructor(e={},t={}){this.hashTableNameToHandle=e;this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle;this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap){this.hashTableMap[e].clearAndClose();delete this.hashTableMap[e]}for(const e in this.hashTableNameToHandle){this.hashTableNameToHandle[e].dispose();delete this.hashTableNameToHandle[e]}}}class GraphModel{constructor(e,t={},n=io){this.modelUrl=e;this.loadOptions=t;this.version="n/a";this.io=n;if(t==null){this.loadOptions={}}this.resourceManager=new ResourceManager}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null){this.handler=e}else if(this.loadOptions.requestInit!=null){this.handler=this.io.browserHTTPRequest(e,this.loadOptions)}else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0){t.push(this.io.browserHTTPRequest(e,this.loadOptions))}else if(t.length>1){throw new Error(`Found more than one (${t.length}) load handlers for `+`URL '${[e]}'`)}this.handler=t[0]}}load(){this.findIOHandler();if(this.handler.load==null){throw new Error("Cannot proceed with model loading because the IOHandler provided "+"does not have the `load` method implemented.")}const e=this.handler.load();if(isPromise(e)){return e.then((e=>this.loadSync(e)))}return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const e=this.artifacts.userDefinedMetadata;if(e.signature!=null){n=e.signature}if(e.structuredOutputKeys!=null){this.structuredOutputKeys=e.structuredOutputKeys}}this.signature=n;this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(t,this.signature));this.executor.weightMap=this.convertTensorMapToTensorsMap(r);this.executor.resourceManager=this.resourceManager;if(e.modelInitializer!=null&&e.modelInitializer.node!=null){const t=OperationMapper.Instance.transformGraph(e.modelInitializer);this.initializer=new GraphExecutor(t);this.initializer.weightMap=this.executor.weightMap;this.initializer.resourceManager=this.resourceManager;this.initializer.executeAsync({},[])}return true}async save(e,t){if(typeof e==="string"){const t=this.io.getSaveHandlers(e);if(t.length===0){throw new Error(`Cannot find any save handlers for URL '${e}'`)}else if(t.length>1){throw new Error(`Found more than one (${t.length}) save handlers for `+`URL '${e}'`)}e=t[0]}if(e.save==null){throw new Error("GraphModel.save() cannot proceed because the IOHandler "+"provided does not have the `save` attribute defined.")}return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e=n instanceof Tensor?[n]:n;const t={};e.forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e));return t}return n}normalizeInputs(e){if(!(e instanceof Tensor)&&!Array.isArray(e)){return e}e=Array.isArray(e)?e:[e];if(e.length!==this.inputNodes.length){throw new Error("Input tensor count mismatch,"+`the graph model has ${this.inputNodes.length} placeholders, `+`while there are ${e.length} input tensors.`)}return this.inputNodes.reduce(((t,n,r)=>{t[n]=e[r];return t}),{})}normalizeOutputs(e){e=e||this.outputNodes;return!Array.isArray(e)?[e]:e}execute(e,t){e=this.normalizeInputs(e);t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e);t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>{t[n]=[e[n]];return t}),{})}dispose(){this.executor.dispose();if(this.initializer){this.initializer.dispose()}this.resourceManager.dispose()}}async function loadGraphModel(e,t={},n=io){if(e==null){throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url "+"or an IOHandler that loads the model")}if(t==null){t={}}if(t.fromTFHub&&typeof e==="string"){e=getTFHubUrl(e)}const r=new GraphModel(e,t,n);await r.load();return r}getGlobalTensorClass().prototype.pad=function(e,t){this.throwIfDisposed();return pad(this,e,t)};getGlobalTensorClass().prototype.where=function(e,t){this.throwIfDisposed();return where(e,this,t)};getGlobalTensorClass().prototype.mul=function(e){this.throwIfDisposed();return mul(this,e)};getGlobalTensorClass().prototype.dot=function(e){this.throwIfDisposed();return dot(this,e)};getGlobalTensorClass().prototype.add=function(e){this.throwIfDisposed();return add(this,e)};const contexts={};const WEBGL_ATTRIBUTES={alpha:false,antialias:false,premultipliedAlpha:false,preserveDrawingBuffer:false,depth:false,stencil:false,failIfMajorPerformanceCaveat:true};function setWebGLContext(e,t){contexts[e]=t}function getWebGLContext(e,t){if(!(e in contexts)||t!=null){const n=getWebGLRenderingContext(e,t);if(n!==null){contexts[e]=n}else{console.log("Could not get context for WebGL version",e);return null}}const n=contexts[e];if(n==null||n.isContextLost()){delete contexts[e];return getWebGLContext(e)}n.disable(n.DEPTH_TEST);n.disable(n.STENCIL_TEST);n.disable(n.BLEND);n.disable(n.DITHER);n.disable(n.POLYGON_OFFSET_FILL);n.disable(n.SAMPLE_COVERAGE);n.enable(n.SCISSOR_TEST);n.enable(n.CULL_FACE);n.cullFace(n.BACK);return contexts[e]}function createCanvas(e){if(typeof OffscreenCanvas!=="undefined"&&e===2){return new OffscreenCanvas(300,150)}else if(typeof document!=="undefined"){return document.createElement("canvas")}else{throw new Error("Cannot create a canvas in this context")}}function getWebGLRenderingContext(e,t){if(e!==1&&e!==2){throw new Error("Cannot get WebGL rendering context, WebGL is disabled.")}const n=t==null?createCanvas(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault();delete contexts[e]}),false);if(e===1){return n.getContext("webgl",WEBGL_ATTRIBUTES)||n.getContext("experimental-webgl",WEBGL_ATTRIBUTES)}return n.getContext("webgl2",WEBGL_ATTRIBUTES)}var PackingScheme;(function(e){e[e["DENSE"]=0]="DENSE";e[e["SHARED_BATCH"]=1]="SHARED_BATCH"})(PackingScheme||(PackingScheme={}));var TextureUsage;(function(e){e[e["RENDER"]=0]="RENDER";e[e["UPLOAD"]=1]="UPLOAD";e[e["PIXELS"]=2]="PIXELS";e[e["DOWNLOAD"]=3]="DOWNLOAD"})(TextureUsage||(TextureUsage={}));var PhysicalTextureType;(function(e){e[e["UNPACKED_FLOAT16"]=0]="UNPACKED_FLOAT16";e[e["UNPACKED_FLOAT32"]=1]="UNPACKED_FLOAT32";e[e["PACKED_4X1_UNSIGNED_BYTE"]=2]="PACKED_4X1_UNSIGNED_BYTE";e[e["PACKED_2X2_FLOAT32"]=3]="PACKED_2X2_FLOAT32";e[e["PACKED_2X2_FLOAT16"]=4]="PACKED_2X2_FLOAT16"})(PhysicalTextureType||(PhysicalTextureType={}));function getUnpackedMatrixTextureShapeWidthHeight(e,t){return[t,e]}function getDenseTexShape(e){const t=sizeFromShape(e);const n=Math.ceil(t/4);return sizeToSquarishShape(n)}function getPackedMatrixTextureShapeWidthHeight(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function getTextureConfig(e,t){const n=e;let r;let a;let s;let o;let i;let u;let l;let c;let p;let m;if(env().getNumber("WEBGL_VERSION")===2){r=n.R32F;a=n.R16F;s=n.RGBA16F;o=n.RGBA32F;i=n.RED;l=4;c=1;p=n.HALF_FLOAT;m=n.FLOAT;u=n.RGBA8}else{r=e.RGBA;a=e.RGBA;s=e.RGBA;o=n.RGBA;i=e.RGBA;l=4;c=4;p=t!=null?t.HALF_FLOAT_OES:null;m=e.FLOAT;u=e.RGBA}return{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function callAndCheck(e,t){const n=t();if(env().getBool("DEBUG")){checkWebGLError(e)}return n}function createVertexShader$1(e,t){const n=throwIfNull(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");callAndCheck(e,(()=>e.shaderSource(n,t)));callAndCheck(e,(()=>e.compileShader(n)));if(e.getShaderParameter(n,e.COMPILE_STATUS)===false){console.log(e.getShaderInfoLog(n));throw new Error("Failed to compile vertex shader.")}return n}function createFragmentShader(e,t){const n=throwIfNull(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");callAndCheck(e,(()=>e.shaderSource(n,t)));callAndCheck(e,(()=>e.compileShader(n)));if(env().get("ENGINE_COMPILE_ONLY")){return n}if(e.getShaderParameter(n,e.COMPILE_STATUS)===false){logShaderSourceAndInfoLog(t,e.getShaderInfoLog(n));throw new Error("Failed to compile fragment shader.")}return n}function createProgram(e){return throwIfNull(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function linkProgram(e,t){callAndCheck(e,(()=>e.linkProgram(t)));if(env().get("ENGINE_COMPILE_ONLY")){return}if(e.getProgramParameter(t,e.LINK_STATUS)===false){console.log(e.getProgramInfoLog(t));throw new Error("Failed to link vertex and fragment shaders.")}}function createStaticVertexBuffer(e,t){const n=throwIfNull(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));callAndCheck(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)));return n}function createStaticIndexBuffer(e,t){const n=throwIfNull(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)));callAndCheck(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)));return n}function createTexture(e){return throwIfNull(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function validateTextureSize(e,t){const n=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`;const a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function createFramebuffer(e){return throwIfNull(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(e,t,n,r,a,s,o){const i=e.getAttribLocation(t,n);if(i===-1){return false}callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r)));callAndCheck(e,(()=>e.vertexAttribPointer(i,a,e.FLOAT,false,s,o)));callAndCheck(e,(()=>e.enableVertexAttribArray(i)));return true}function bindTextureUnit(e,t,n){validateTextureUnit(e,n);callAndCheck(e,(()=>e.activeTexture(e.TEXTURE0+n)));callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function getProgramUniformLocation(e,t,n){return e.getUniformLocation(t,n)}function bindTextureToProgramUniformSampler(e,t,n,r){callAndCheck(e,(()=>bindTextureUnit(e,t,r)));callAndCheck(e,(()=>e.uniform1i(n,r)))}function bindColorTextureToFramebuffer(e,t,n){callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n)));callAndCheck(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function throwIfNull(e,t,n){const r=callAndCheck(e,(()=>t()));if(r==null){throw new Error(n)}return r}function validateTextureUnit(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1;const r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function getBatchDim(e,t=2){return sizeFromShape(e.slice(0,e.length-t))}function getRowsCols(e){if(e.length===0){throw Error("Cannot get rows and columns of an empty shape array.")}return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function getShapeAs3D(e){let t=[1,1,1];const n=e.length===0||e.length===1&&e[0]===1;if(!n){t=[getBatchDim(e),...getRowsCols(e)]}return t}function getTextureShapeFromLogicalShape(e,t=false){let n=env().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t){n=n*2;e=e.map(((t,n)=>n>=e.length-2?nearestLargerEven(e[n]):e[n]));if(e.length===1){e=[2,e[0]]}}if(e.length!==2){const t=squeezeShape(e);e=t.newShape}let r=sizeFromShape(e);if(e.length<=1&&r<=n){return[1,r]}else if(e.length===2&&e[0]<=n&&e[1]<=n){return e}else if(e.length===3&&e[0]*e[1]<=n&&e[2]<=n){return[e[0]*e[1],e[2]]}else if(e.length===3&&e[0]<=n&&e[1]*e[2]<=n){return[e[0],e[1]*e[2]]}else if(e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n){return[e[0]*e[1]*e[2],e[3]]}else if(e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n){return[e[0],e[1]*e[2]*e[3]]}else{if(t){const t=getBatchDim(e);let n=2,a=2;if(e.length){[n,a]=getRowsCols(e)}r=t*(n/2)*(a/2);return sizeToSquarishShape(r).map((e=>e*2))}return sizeToSquarishShape(r)}}function isEven(e){return e%2===0}function isReshapeFree(e,t){e=e.slice(-2);t=t.slice(-2);if(arraysEqual(e,t)){return true}if(!e.length||!t.length){return true}if(e[0]===0||e[1]===0||t[0]===0||t[1]===0){return true}if(e.length!==t.length){const n=e.slice(-1)[0];const r=t.slice(-1)[0];if(n===r){return true}if(isEven(n)&&isEven(r)&&(e[0]===1||t[0]===1)){return true}}return e[1]===t[1]&&isEven(e[0])&&isEven(t[0])}let MAX_TEXTURE_SIZE;let MAX_TEXTURES_IN_SHADER;function getWebGLMaxTextureSize(e){if(MAX_TEXTURE_SIZE==null){const t=getWebGLContext(e);MAX_TEXTURE_SIZE=t.getParameter(t.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function getMaxTexturesInShader(e){if(MAX_TEXTURES_IN_SHADER==null){const t=getWebGLContext(e);MAX_TEXTURES_IN_SHADER=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,MAX_TEXTURES_IN_SHADER)}function hasExtension(e,t){const n=e.getExtension(t);return n!=null}function isWebGLVersionEnabled(e){try{const t=getWebGLContext(e);if(t!=null){return true}}catch(e){console.log("Error when getting WebGL context: ",e);return false}return false}function isCapableOfRenderingToFloatTexture(e){if(e===0){return false}const t=getWebGLContext(e);if(e===1){if(!hasExtension(t,"OES_texture_float")){return false}}else{if(!hasExtension(t,"EXT_color_buffer_float")){return false}}const n=createFloatTextureAndBindToFramebuffer(t);return n}function createFloatTextureAndBindToFramebuffer(e){const t=getTextureConfig(e);const n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1;const a=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,a,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s);e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;e.bindTexture(e.TEXTURE_2D,null);e.bindFramebuffer(e.FRAMEBUFFER,null);e.deleteTexture(n);e.deleteFramebuffer(s);return o}function isWebGLFenceEnabled(e){if(e!==2){return false}const t=getWebGLContext(e);const n=t.fenceSync!=null;return n}const ENV=env();ENV.registerFlag("HAS_WEBGL",(()=>ENV.getNumber("WEBGL_VERSION")>0));ENV.registerFlag("WEBGL_VERSION",(()=>{if(isWebGLVersionEnabled(2)){return 2}else if(isWebGLVersionEnabled(1)){return 1}return 0}));ENV.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>false));ENV.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>ENV.get("WEBGL_VERSION")===2));ENV.registerFlag("WEBGL_CPU_FORWARD",(()=>true));ENV.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>false));ENV.registerFlag("WEBGL_PACK",(()=>ENV.getBool("HAS_WEBGL")));ENV.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_CLIP",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_PACK_REDUCE",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_LAZILY_UNPACK",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_CONV_IM2COL",(()=>ENV.getBool("WEBGL_PACK")));ENV.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>getWebGLMaxTextureSize(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>getMaxTexturesInShader(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=ENV.getNumber("WEBGL_VERSION");if(e===0){return 0}return getWebGLDisjointQueryTimerVersion(e)}));ENV.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>ENV.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!isMobile()));ENV.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>isCapableOfRenderingToFloatTexture(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>ENV.getBool("WEBGL_FORCE_F16_TEXTURES")?false:ENV.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")));ENV.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>isDownloadFloatTextureEnabled(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>isWebGLFenceEnabled(ENV.getNumber("WEBGL_VERSION"))));ENV.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>{const e=ENV.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return e?4:0}));ENV.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&e!==-1){throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never `+`delete) or at least 0, but got ${e}.`)}}));ENV.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>isMobile()?1:-1),(e=>{if(e<0&&e!==-1){throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never `+`manual flush) or at least 0, but got ${e}.`)}}));ENV.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128));ENV.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>false));ENV.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5));ENV.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));function getGlslDifferences(){let e;let t;let n;let r;let a;let s;let o;let i;let u;let l;if(env().getNumber("WEBGL_VERSION")===2){e="#version 300 es";t="in";n="out";r="in";a="texture";s="outputColor";o="out vec4 outputColor;";i=`\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;u=``;l=`\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `}else{e="";t="attribute";n="varying";r="varying";a="texture2D";s="gl_FragColor";o="";i=`\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;u=`\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;l=`\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `}return{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function getLogicalCoordinatesFromFlatIndex(e,t,n="index"){const r=computeStrides(t);return r.map(((t,a)=>{const s=`int ${e[a]} = ${n} / ${t}`;const o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${o};`})).join("")}function getOutputLogicalCoordinatesFromFlatIndexByUniform(e,t,n="index"){const r=computeStrides(t);return r.map(((t,a)=>{const s=`int ${e[a]} = ${n} / outShapeStrides[${a}]`;const o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${o};`})).join("")}function symbolicallyComputeStrides(e,t){const n=e.length;const r=e.map((e=>`${t}[${e}]`));const a=new Array(n-1);a[n-2]=r[n-1];for(let e=n-3;e>=0;--e){a[e]=`(${a[e+1]} * ${r[e+1]})`}return a}function getLogicalCoordinatesFromFlatIndexByUniform(e,t,n="index"){const r=e.map(((e,t)=>t));const a=symbolicallyComputeStrides(r,t);return a.map(((t,r)=>{const s=`int ${e[r]} = ${n} / ${a[r]}`;const o=r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`;return`${s}; ${o};`})).join("")}function getFlatIndexFrom3D(e){const t=computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function getFlatIndexFrom3DOutput(){return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n`}const ENCODE_FLOAT_SNIPPET=`\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;const{getBroadcastDims:getBroadcastDims}=backend_util;function makeShader(e,t,n){const r=[];e.forEach((e=>{const t=sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform){r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`)}else{r.push(`uniform sampler2D ${e.name};`);r.push(`uniform int offset${e.name};`)}if(n.enableShapeUniforms){const{uniformShape:t}=getUniformInfoFromShape(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break}r.push(`uniform ivec2 ${e.name}TexShape;`)}}));if(n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push(`uniform int outShape;`);break;case 2:r.push(`uniform ivec2 outShape;`);r.push(`uniform int outShapeStrides;`);break;case 3:r.push(`uniform ivec3 outShape;`);r.push(`uniform ivec2 outShapeStrides;`);break;case 4:r.push(`uniform ivec4 outShape;`);r.push(`uniform ivec3 outShapeStrides;`);break}r.push(`uniform ivec2 outTexShape;`)}if(n.customUniforms){n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}))}const a=r.join("\n");const s=e.map((e=>getInputSamplingSnippet(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n");const o=t.texShape;const i=getGlslDifferences();const u=getFloatTextureSampleSnippet(i);let l;let c;let p=getShaderPrefix(i);if(t.isPacked){l=getPackedOutputSamplingSnippet(t.logicalShape,o,n.enableShapeUniforms);c=getFloatTextureSetRGBASnippet(i)}else{l=getOutputSamplingSnippet(t.logicalShape,o,n.enableShapeUniforms);c=getFloatTextureSetRSnippet(i)}if(n.packedInputs){p+=SHADER_PACKED_PREFIX}const m=[p,u,c,a,l,s,n.userCode].join("\n");return m}function getSamplerFromInInfo(e,t=false){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return getSamplerScalar(e,t);case 1:return getSampler1D(e,t);case 2:return getSampler2D(e,t);case 3:return getSampler3D(e,t);case 4:return getSampler4D(e,t);case 5:return getSampler5D(e);case 6:return getSampler6D(e);default:throw new Error(`${n.length}-D input sampling`+` is not yet supported`)}}function getPackedSamplerFromInInfo(e,t){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return getPackedSamplerScalar(e);case 1:return getPackedSampler1D(e,t);case 2:return getPackedSampler2D(e,t);case 3:return getPackedSampler3D(e,t);default:return getPackedSamplerND(e,t)}}function getInputSamplingSnippet(e,t,n=false,r){let a="";if(n){a+=getPackedSamplerFromInInfo(e,r)}else{a+=getSamplerFromInInfo(e,r)}const s=e.shapeInfo.logicalShape;const o=t.logicalShape;if(s.length<=o.length){if(n){a+=getPackedSamplerAtOutputCoords(e,t)}else{a+=getSamplerAtOutputCoords(e,t)}}return a}function getPackedOutputSamplingSnippet(e,t,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(e,t,n);case 2:return getOutputPacked2DCoords(e,t,n);case 3:return getOutputPacked3DCoords(e,t,n);default:return getOutputPackedNDCoords(e,t,n)}}function getOutputSamplingSnippet(e,t,n){switch(e.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(e,t,n);case 2:return getOutput2DCoords(e,t,n);case 3:return getOutput3DCoords(e,t,n);case 4:return getOutput4DCoords(e,t,n);case 5:return getOutput5DCoords(e,t);case 6:return getOutput6DCoords(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function getFloatTextureSampleSnippet(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function getFloatTextureSetRSnippet(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function getFloatTextureSetRGBASnippet(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function getShaderPrefix(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;return t}const SAMPLE_1D_SNIPPET=`\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const SAMPLE_2D_SNIPPET=`\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const SAMPLE_3D_SNIPPET=`\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;const SHADER_PACKED_PREFIX=`\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;function getOutputPacked3DCoords(e,t,n){if(n){return`\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];const a=Math.ceil(e[2]/2);const s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function getOutputPackedNDCoords(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  `}const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];const a=Math.ceil(e[e.length-1]/2);const s=a*Math.ceil(e[e.length-2]/2);let o=s;let i=``;let u="b, r, c";for(let t=2;t<e.length-1;t++){o*=e[e.length-t-1];i=`\n      int b${t} = index / ${o};\n      index -= b${t} * ${o};\n    `+i;u=`b${t}, `+u}return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}function getOutputPacked2DCoords(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(arraysEqual(e,t)){if(n){return`\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `}const a=Math.ceil(e[1]/2);if(n){return`\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  `}return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function getOutput2DCoords(e,t,n){if(arraysEqual(e,t)){if(n){return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `}if(e[1]===1){if(n){return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `}if(e[0]===1){if(n){return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `}if(n){return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  `}return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function getFlatOffsetUniformName(e){return`offset${e}`}function getPackedSampler1D(e,t){const n=e.name;const r="get"+n.charAt(0).toUpperCase()+n.slice(1);const a=e.shapeInfo.texShape;const s=getGlslDifferences();if(t){return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function getSampler1D(e,t){const n=e.name;const r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform){return`\n      float ${r}(int index) {\n        ${getUniformSampler(e)}\n      }\n    `}const a=e.shapeInfo.texShape;const s=a[0];const o=a[1];if(o===1&&s===1){return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `}const i=getFlatOffsetUniformName(n);if(o===1){if(t){return`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `}return`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `}if(s===1){if(t){return`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `}return`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `}if(t){return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function getPackedSampler2D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const a="get"+r.charAt(0).toUpperCase()+r.slice(1);const s=e.shapeInfo.texShape;const o=s[0];const i=s[1];const u=getGlslDifferences();if(s!=null&&arraysEqual(n,s)){if(t){return`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `}return`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${u.texture2D}(${r}, uv);\n      }\n    `}if(t){return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];const c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}function getSampler2D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const a="get"+r.charAt(0).toUpperCase()+r.slice(1);const s=e.shapeInfo.texShape;if(s!=null&&arraysEqual(n,s)){if(t){return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `}const e=s[0];const n=s[1];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:o,keptDims:i}=squeezeShape(n);const u=o;if(u.length<n.length){const n=squeezeInputInfo(e,u);const r=["row","col"];return`\n      ${getSamplerFromInInfo(n,t)}\n      float ${a}(int row, int col) {\n        return ${a}(${getSqueezedParams(r,i)});\n      }\n    `}if(e.shapeInfo.isUniform){return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `}const l=s[0];const c=s[1];const p=getFlatOffsetUniformName(r);if(c===1){if(t){return`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `}return`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}if(l===1){if(t){return`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `}return`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `}if(t){return`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `}return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${l}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function getPackedSampler3D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const a="get"+r.charAt(0).toUpperCase()+r.slice(1);const s=e.shapeInfo.texShape;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){const r=n.slice(1);const s=[1,2];const o=squeezeInputInfo(e,r);const i=["b","row","col"];return`\n        ${getPackedSamplerFromInInfo(o,t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${getSqueezedParams(i,s)});\n        }\n      `}const i=getGlslDifferences();if(t){return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}const u=o[0];const l=o[1];const c=Math.ceil(n[2]/2);const p=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${l}, ${p}, ${c}, b, row, col);\n      return ${i.texture2D}(${r}, uv);\n    }\n  `}function getSampler3D(e,t){const n=e.shapeInfo.logicalShape;const r=e.name;const a="get"+r.charAt(0).toUpperCase()+r.slice(1);const s=n[1]*n[2];const o=n[2];const{newShape:i,keptDims:u}=squeezeShape(n);const l=i;if(l.length<n.length){const n=squeezeInputInfo(e,l);const r=["row","col","depth"];return`\n        ${getSamplerFromInInfo(n,t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${getSqueezedParams(r,u)});\n        }\n      `}if(e.shapeInfo.isUniform){return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${getUniformSampler(e)}\n      }\n    `}const c=e.shapeInfo.texShape;const p=c[0];const m=c[1];const d=e.shapeInfo.flatOffset;if(m===s&&d==null){if(t){return`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `}return`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${m}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `}if(m===o&&d==null){if(t){return`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `}return`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const h=getFlatOffsetUniformName(r);if(t){return`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${o} + depth + ${h};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `}return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${h};\n        vec2 uv = uvFromFlat(${p}, ${m}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function getPackedSamplerND(e,t){const n=e.name;const r="get"+n.charAt(0).toUpperCase()+n.slice(1);const a=getGlslDifferences();if(t){return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `}const s=e.shapeInfo.logicalShape;const o=s.length;const i=e.shapeInfo.texShape;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];const l=u[0];const c=u[1];const p=Math.ceil(s[o-1]/2);let m=p*Math.ceil(s[o-2]/2);let d=`int b, int row, int col`;let h=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let e=2;e<o-1;e++){d=`int b${e}, `+d;m*=s[o-e-1];h=`b${e} * ${m} + `+h}return`\n    vec4 ${r}(${d}) {\n      int index = ${h};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function getPackedSamplerAtOutputCoords(e,t){const n=e.name;const r=n.charAt(0).toUpperCase()+n.slice(1);const a="get"+r+"AtOutCoords";const s=e.shapeInfo.logicalShape.length;const o=t.logicalShape.length;const i=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape);const u=getCoordsDataType(o);const l=o-s;let c;const p=["x","y","z","w","u","v"];if(s===0){c=""}else if(o<2&&i.length>=1){c="coords = 0;"}else{c=i.map((e=>`coords.${p[e+l]} = 0;`)).join("\n")}let m="";if(o<2&&s>0){m="coords"}else{m=e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+l]}`)).join(", ")}let d=`return outputValue;`;const h=sizeFromShape(e.shapeInfo.logicalShape);const f=h===1;const g=sizeFromShape(t.logicalShape);const y=g===1;if(s===1&&!f&&!y){d=`\n      return vec4(outputValue.xy, outputValue.xy);\n    `}else if(f&&!y){if(o===1){d=`\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `}else{d=`\n        return vec4(outputValue.x);\n      `}}else if(i.length){const e=s-2;const t=s-1;if(i.indexOf(e)>-1&&i.indexOf(t)>-1){d=`return vec4(outputValue.x);`}else if(i.indexOf(e)>-1){d=`return vec4(outputValue.x, outputValue.y, `+`outputValue.x, outputValue.y);`}else if(i.indexOf(t)>-1){d=`return vec4(outputValue.xx, outputValue.zz);`}}return`\n    vec4 ${a}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${m});\n      ${d}\n    }\n  `}function getSamplerAtOutputCoords(e,t){const n=e.name;const r=n.charAt(0).toUpperCase()+n.slice(1);const a="get"+r+"AtOutCoords";const s=t.texShape;const o=e.shapeInfo.texShape;const i=e.shapeInfo.logicalShape.length;const u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===u&&e.shapeInfo.flatOffset==null&&arraysEqual(o,s)){return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `}const l=getCoordsDataType(u);const c=getBroadcastDims(e.shapeInfo.logicalShape,t.logicalShape);const p=u-i;let m;const d=["x","y","z","w","u","v"];if(i===0){m=""}else if(u<2&&c.length>=1){m="coords = 0;"}else{m=c.map((e=>`coords.${d[e+p]} = 0;`)).join("\n")}let h="";if(u<2&&i>0){h="coords"}else{h=e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+p]}`)).join(", ")}return`\n    float ${a}() {\n      ${l} coords = getOutputCoords();\n      ${m}\n      return get${r}(${h});\n    }\n  `}function getCoordsDataType(e){if(e<=1){return"int"}else if(e===2){return"ivec2"}else if(e===3){return"ivec3"}else if(e===4){return"ivec4"}else if(e===5){return"ivec5"}else if(e===6){return"ivec6"}else{throw Error(`GPU for rank ${e} is not yet supported`)}}function getUniformInfoFromShape(e,t,n){const{newShape:r,keptDims:a}=squeezeShape(t);const s=t.length;const o=e&&s===3&&t[0]===1;const i=o?t.slice(1):r;const u=!e&&s>1&&!arraysEqual(t,n)&&r.length<s||o;const l=u?i:t;return{useSqueezeShape:u,uniformShape:l,keptDims:a}}function squeezeInputInfo(e,t){const n=JSON.parse(JSON.stringify(e));n.shapeInfo.logicalShape=t;return n}function getSqueezedParams(e,t){return t.map((t=>e[t])).join(", ")}function compileProgram(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:e.isUniform?false:e.texData.isPacked,flatOffset:null};if(e.texData!=null&&e.texData.slice!=null&&e.texData.slice.flatOffset>0){r.flatOffset=e.texData.slice.flatOffset}return{name:t.variableNames[n],shapeInfo:r}}));const s=a.map((e=>e.shapeInfo));const o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:false,isPacked:r.texData.isPacked,flatOffset:null};const i=makeShader(a,o,t);const u=createFragmentShader(e.gl,i);const l=e.createProgram(u);if(!env().get("ENGINE_COMPILE_ONLY")){return Object.assign({program:t,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o},getUniformLocations(e,t,l))}else{return{program:t,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}}}function getUniformLocations(e,t,n){const r={};const a={};const s={};const o=[];let i;let u;let l;let c=null;let p=null;p=e.getUniformLocation(n,"NAN",false);if(env().getNumber("WEBGL_VERSION")===1){c=e.getUniformLocation(n,"INFINITY",false)}const m=false;for(let o=0;o<t.variableNames.length;o++){const i=t.variableNames[o];r[i]=e.getUniformLocation(n,i,m);r[`offset${i}`]=e.getUniformLocation(n,`offset${i}`,m);if(t.enableShapeUniforms){a[`${i}Shape`]=e.getUniformLocation(n,`${i}Shape`,m);s[`${i}TexShape`]=e.getUniformLocation(n,`${i}TexShape`,m)}}if(t.enableShapeUniforms){i=e.getUniformLocation(n,"outShape",m);l=e.getUniformLocation(n,"outShapeStrides",m);u=e.getUniformLocation(n,"outTexShape",m)}if(t.customUniforms){t.customUniforms.forEach(((t,r)=>{o[r]=e.getUniformLocation(n,t.name,m)}))}return{uniformLocations:r,customUniformLocations:o,infLoc:c,nanLoc:p,inShapesLocations:a,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}}function validateBinaryAndProgram(e,t){if(e.length!==t.length){throw Error(`Binary was compiled with ${e.length} inputs, but `+`was executed with ${t.length} inputs`)}e.forEach(((e,n)=>{const r=e.logicalShape;const a=t[n];const s=a.shape;if(!arraysEqual(r,s)){throw Error(`Binary was compiled with different shapes than `+`the current args. Shapes ${r} and ${s} must match`)}if(e.isUniform&&a.isUniform){return}const o=e.texShape;const i=a.isUniform?null:a.texData.texShape;if(!arraysEqual(o,i)){throw Error(`Binary was compiled with different texture shapes than the`+` current args. Shape ${o} and ${i} must match`)}}))}function runProgram(e,t,n,r,a){if(!t.program.enableShapeUniforms){validateBinaryAndProgram(t.inShapeInfos,n);validateBinaryAndProgram([t.outShapeInfo],[r])}const s=r.texData.texture;const o=r.texData.texShape;if(r.texData.isPacked){e.setOutputPackedMatrixTexture(s.texture,o[0],o[1])}else{e.setOutputMatrixTexture(s.texture,o[0],o[1])}e.setProgram(t.webGLProgram);if(env().getNumber("WEBGL_VERSION")===1){if(t.infLoc!==null){e.gl.uniform1f(t.infLoc,Infinity)}}if(t.nanLoc!==null){e.gl.uniform1f(t.nanLoc,NaN)}n.forEach(((n,r)=>{const a=t.program.variableNames[r];const s=t.uniformLocations[a];const o=t.uniformLocations[`offset${a}`];const i=t.inShapesLocations[`${a}Shape`];const u=t.inTexShapesLocations[`${a}TexShape`];if(i){const{uniformShape:r}=getUniformInfoFromShape(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(i,new Int32Array(r));break;case 2:e.gl.uniform2iv(i,new Int32Array(r));break;case 3:e.gl.uniform3iv(i,new Int32Array(r));break;case 4:e.gl.uniform4iv(i,new Int32Array(r));break}}if(u){e.gl.uniform2i(u,n.texData.texShape[0],n.texData.texShape[1])}if(s==null){return}if(n.isUniform){if(sizeFromShape(n.shape)<2){e.gl.uniform1f(s,n.uniformValues[0])}else{let t=n.uniformValues;if(!(t instanceof Float32Array)){t=new Float32Array(t)}e.gl.uniform1fv(s,t)}return}if(n.texData.slice!=null&&o!=null){e.gl.uniform1i(o,n.texData.slice.flatOffset)}e.setInputMatrixTexture(n.texData.texture.texture,s,r)}));const i=t.outShapeLocation;if(i){switch(r.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(r.shape));break}}if(t.outShapeStridesLocation){const n=computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break}}if(t.outTexShapeLocation){e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1])}if(t.program.customUniforms&&a){t.program.customUniforms.forEach(((n,r)=>{const s=t.customUniformLocations[r];const o=a[r];if(n.type==="float"){e.gl.uniform1fv(s,o)}else if(n.type==="vec2"){e.gl.uniform2fv(s,o)}else if(n.type==="vec3"){e.gl.uniform3fv(s,o)}else if(n.type==="vec4"){e.gl.uniform4fv(s,o)}else if(n.type==="int"){e.gl.uniform1iv(s,o)}else if(n.type==="ivec2"){e.gl.uniform2iv(s,o)}else if(n.type==="ivec3"){e.gl.uniform3iv(s,o)}else if(n.type==="ivec4"){e.gl.uniform4iv(s,o)}else{throw Error(`uniform type ${n.type} is not supported yet.`)}}))}e.executeProgram()}function makeShaderKey(e,t,n){let r="";t.concat(n).forEach((t=>{const a=t.texData!=null&&t.texData.slice!=null&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape;const{useSqueezeShape:o,uniformShape:i,keptDims:u}=getUniformInfoFromShape(e.packedInputs,t.shape,s);let l="",c="",p="";if(i.length===1&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(i.length===2&&!e.packedInputs){c=`${i[0]>1}_${i[1]>1}`}else if(i.length>2&&!e.packedInputs){const e=computeStrides(i);p=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}const m=t.shape.length;const d=i.length===2&&arraysEqual(t.shape,s);const h=sizeFromShape(t.shape)===1;const f=getBroadcastDims$1(t.shape,n.shape);const g=!e.packedInputs&&m===n.shape.length&&arraysEqual(s,n.texData.texShape);const y=e.packedInputs||i.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${m}_${g}_${o?u:""}_${i.length}_${h}_${f}_${d}_${l}_${c}_${p}_${y}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;s+="_"+r+"_"+a+`${env().getNumber("WEBGL_VERSION")}`;return s}function useShapeUniforms(e){return env().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class DecodeMatrixProgram{constructor(e){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outPackingScheme=PackingScheme.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class DecodeMatrixPackedProgram{constructor(e){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outPackingScheme=PackingScheme.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class EncodeFloatProgram{constructor(e){this.variableNames=["A"];this.outTexUsage=TextureUsage.DOWNLOAD;const t=getGlslDifferences();this.outputShape=e;this.userCode=`\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class EncodeFloatPackedProgram{constructor(e){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outTexUsage=TextureUsage.DOWNLOAD;const t=getGlslDifferences();this.outputShape=e;this.userCode=`\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class EncodeMatrixProgram{constructor(e,t=false){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let r=`result`;if(t){r=`floor(result * 255. + 0.5)`}this.userCode=`\n      ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}class EncodeMatrixPackedProgram{constructor(e,t=false){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=getGlslDifferences();this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let r="";let a="result";if(t){a="floor(result * 255. + 0.5)"}for(let t=0;t<=1;t++){for(let a=0;a<=1;a++){const s=t*2+a;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}}this.userCode=`\n        ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}function createVertexShader(e){const t=getGlslDifferences();const n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return createVertexShader$1(e,n)}function createVertexBuffer(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return createStaticVertexBuffer(e,t)}function createIndexBuffer(e){const t=new Uint16Array([0,1,2,2,1,3]);return createStaticIndexBuffer(e,t)}function createAndConfigureTexture(e,t,n,r,a,s){validateTextureSize(t,n);const o=createTexture(e);const i=e.TEXTURE_2D;callAndCheck(e,(()=>e.bindTexture(i,o)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST)));callAndCheck(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST)));if(env().getNumber("WEBGL_VERSION")===1){callAndCheck(e,(()=>e.texImage2D(i,0,r,t,n,0,a,s,null)))}else{callAndCheck(e,(()=>e.texStorage2D(i,1,r,t,n)))}callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)));return{texture:o,texShape:[n,t]}}function getInternalFormatForFloat32MatrixTexture(e){return e.internalFormatFloat}function createFloat32MatrixTexture(e,t,n,r){const[a,s]=getUnpackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,a,s,getInternalFormatForFloat32MatrixTexture(r),r.textureFormatFloat,e.FLOAT)}function getInternalFormatForPackedMatrixTexture(e){return e.internalFormatPackedFloat}function createPackedMatrixTexture(e,t,n,r){const[a,s]=getPackedMatrixTextureShapeWidthHeight(t,n);return createAndConfigureTexture(e,a,s,getInternalFormatForPackedMatrixTexture(r),e.RGBA,e.FLOAT)}function bindVertexProgramAttributeStreams(e,t,n){const r=0;const a=3*4;const s=3*4+2*4;callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n)));const o=bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",n,3,s,r);return o&&bindVertexBufferToProgramAttribute(e,t,"uv",n,2,s,a)}function uploadDenseMatrixToTexture(e,t,n,r,a,s){callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,t)));let o,i,u;if(a instanceof Uint8Array){o=new Uint8Array(n*r*4);i=e.UNSIGNED_BYTE;u=e.RGBA}else{o=new Float32Array(n*r*4);i=e.FLOAT;u=s.internalFormatPackedFloat}o.set(a);if(env().getNumber("WEBGL_VERSION")===2){callAndCheck(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,i,o)))}else{callAndCheck(e,(()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,i,o)))}callAndCheck(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function createBufferFromOutputTexture(e,t,n,r){const a=e.createBuffer();callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));const s=4;const o=4;const i=s*o*t*n;callAndCheck(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)));callAndCheck(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)));callAndCheck(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)));return a}function downloadFloat32MatrixFromBuffer(e,t,n){const r=e;const a=new Float32Array(n);r.bindBuffer(r.PIXEL_PACK_BUFFER,t);r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a);r.bindBuffer(r.PIXEL_PACK_BUFFER,null);return a}class GPGPUContext{constructor(e){this.outputTexture=null;this.program=null;this.disposed=false;this.vertexAttrsAreBound=false;this.itemsToPoll=[];const t=env().getNumber("WEBGL_VERSION");if(e!=null){this.gl=e;setWebGLContext(t,e)}else{this.gl=getWebGLContext(t)}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile");if(env().getNumber("WEBGL_VERSION")===1){const e="OES_texture_float";const t="OES_texture_half_float";this.textureFloatExtension=getExtensionOrThrow(this.gl,e);if(hasExtension(this.gl,t)){this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,t)}else if(env().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support half float textures, yet the "+"environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}this.colorBufferFloatExtension=this.gl.getExtension(n);if(hasExtension(this.gl,r)){this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,r)}else if(env().get("WEBGL_FORCE_F16_TEXTURES")){throw new Error("GL context does not support color renderable half floats, yet "+"the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}}else{n="EXT_color_buffer_float";if(hasExtension(this.gl,n)){this.colorBufferFloatExtension=this.gl.getExtension(n)}else if(hasExtension(this.gl,r)){this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}else{throw new Error("GL context does not support color renderable floats")}}this.vertexBuffer=createVertexBuffer(this.gl);this.indexBuffer=createIndexBuffer(this.gl);this.framebuffer=createFramebuffer(this.gl);this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}get debug(){return env().getBool("DEBUG")}dispose(){if(this.disposed){return}if(this.program!=null){console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram."+" This is probably a resource leak, delete the program with "+"GPGPUContext.deleteProgram before disposing.")}if(this.outputTexture!=null){console.warn("Disposing a GPGPUContext that still has a bound output matrix "+"texture.  This is probably a resource leak, delete the output "+"matrix texture with GPGPUContext.deleteMatrixTexture before "+"disposing.")}const e=this.gl;callAndCheck(e,(()=>e.finish()));callAndCheck(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null)));callAndCheck(e,(()=>e.deleteFramebuffer(this.framebuffer)));callAndCheck(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null)));callAndCheck(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)));callAndCheck(e,(()=>e.deleteBuffer(this.indexBuffer)));this.disposed=true}createFloat32MatrixTexture(e,t){this.throwIfDisposed();return createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){this.throwIfDisposed();return createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){this.throwIfDisposed();return createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed();uploadPixelDataToTexture(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed();uploadDenseMatrixToTexture(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){this.throwIfDisposed();return createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){this.throwIfDisposed();return createPackedMatrixTexture(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed();if(this.outputTexture===e){unbindColorTextureFromFramebuffer(this.gl,this.framebuffer);this.outputTexture=null}callAndCheck(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return downloadPackedMatrixFromBuffer(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return downloadFloat32MatrixFromBuffer(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=createBufferFromOutputTexture(this.gl,t,n,this.textureConfig);this.unbindTextureToFrameBuffer();return r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;let n;if(env().getBool("WEBGL_FENCE_API_ENABLED")){const r=e;const a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush();n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED};t=a}else if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0){t=this.beginQuery();this.endQuery();n=()=>this.isQueryAvailable(t,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}else{n=()=>true}return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>downloadMatrixFromPackedOutputTexture(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;if(this.vertexShader==null){this.vertexShader=createVertexShader(t)}const n=createProgram(t);callAndCheck(t,(()=>t.attachShader(n,this.vertexShader)));callAndCheck(t,(()=>t.attachShader(n,e)));linkProgram(t,n);if(this.debug){validateProgram(t,n)}if(!this.vertexAttrsAreBound){this.setProgram(n);this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(t,this.program,this.vertexBuffer)}return n}deleteProgram(e){this.throwIfDisposed();if(e===this.program){this.program=null}if(e!=null){callAndCheck(this.gl,(()=>this.gl.deleteProgram(e)))}}setProgram(e){this.throwIfDisposed();this.program=e;if(this.program!=null&&this.debug){validateProgram(this.gl,this.program)}callAndCheck(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=true){this.throwIfDisposed();if(n){return getProgramUniformLocationOrThrow(this.gl,e,t)}else{return getProgramUniformLocation(this.gl,e,t)}}getAttributeLocation(e,t){this.throwIfDisposed();return callAndCheck(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){this.throwIfDisposed();return this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed();this.throwIfNoProgram();bindTextureToProgramUniformSampler(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=getPackedMatrixTextureShapeWidthHeight(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){if(this.program!=null){validateProgram(this.gl,this.program)}validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed();this.throwIfNoProgram();const e=this.gl;if(this.debug){this.debugValidate()}callAndCheck(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed();callAndCheck(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){if(this.disjointQueryTimerExtension==null){this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")}return this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl;const t=this.getQueryTimerExtensionWebGL2();const n=e.createQuery();e.beginQuery(t.TIME_ELAPSED_EXT,n);return n}const e=this.getQueryTimerExtensionWebGL1();const t=e.createQueryEXT();e.beginQueryEXT(e.TIME_ELAPSED_EXT,t);return t}endQuery(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl;const t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){await repeatedTry((()=>this.disposed||this.isQueryAvailable(e,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))));return this.getQueryTime(e,env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0){return null}if(t===2){const t=this.gl;const n=t.getQueryParameter(e,t.QUERY_RESULT);return n/1e6}else{const t=this.getQueryTimerExtensionWebGL1();const n=t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT);return n/1e6}}isQueryAvailable(e,t){if(t===0){return true}if(t===2){const t=this.gl;const n=this.getQueryTimerExtensionWebGL2();const r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);if(this.disjoint==null){this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)}return r&&!this.disjoint}else{const t=this.getQueryTimerExtensionWebGL1();const n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);if(this.disjoint==null){this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)}return n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=linearSearchLastTrue(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t});if(this.itemsToPoll.length>1){return}repeatedTry((()=>{this.pollItems();return this.itemsToPoll.length===0}))}bindTextureToFrameBuffer(e){this.throwIfDisposed();bindColorTextureToFramebuffer(this.gl,e,this.framebuffer);if(this.debug){validateFramebuffer(this.gl)}}unbindTextureToFrameBuffer(){if(this.outputTexture!=null){bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer);if(this.debug){validateFramebuffer(this.gl)}}else{unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();this.unbindTextureToFrameBuffer();return n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;bindColorTextureToFramebuffer(r,e,this.framebuffer);if(this.debug){validateFramebuffer(r)}this.outputTexture=e;callAndCheck(r,(()=>r.viewport(0,0,t,n)));callAndCheck(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed();callAndCheck(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed){throw new Error("Attempted to use disposed GPGPUContext.")}}throwIfNoProgram(){if(this.program==null){throw new Error("No GPU program is currently set.")}}}function linearSearchLastTrue(e){let t=0;for(;t<e.length;++t){const n=e[t]();if(!n){break}}return t-1}function createSimpleBinaryKernelImpl(e){return(t,n,r,a,s)=>{const o=assertAndGetBroadcastShape(t,n);const i=o.length;const u=computeStrides(o);const l=sizeFromShape(o);const c=getTypedArrayFromDType(s,l);const p=t.length;const m=n.length;const d=computeStrides(t);const h=computeStrides(n);const f=getBroadcastDims$1(t,o);const g=getBroadcastDims$1(n,o);if(f.length+g.length===0){for(let t=0;t<c.length;++t){c[t]=e(r[t%r.length],a[t%a.length])}}else{for(let t=0;t<c.length;++t){const n=indexToLoc(t,i,u);const s=n.slice(-p);f.forEach((e=>s[e]=0));const o=locToIndex(s,p,d);const l=n.slice(-m);g.forEach((e=>l[e]=0));const y=locToIndex(l,m,h);c[t]=e(r[o],a[y])}}return[c,o]}}const addImpl=createSimpleBinaryKernelImpl(((e,t)=>e+t));function bincountImpl(e,t,n,r,a){const s=sizeFromShape(r);const o=makeZerosTypedArray(a,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0){throw new Error("Input x must be non-negative!")}if(r>=a){continue}if(s>0){o[r]+=t[n]}else{o[r]+=1}}return o}function createSimpleUnaryImpl(e){return(t,n,r)=>{const a=getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n){a[n]=e(t[n],r)}return a}}const ceilImpl=createSimpleUnaryImpl((e=>Math.ceil(e)));function concatImpl$1(e,t,n,r){const a=getArrayFromDType(n,sizeFromShape(t));if(r&&n!=="string"){let t=0;e.forEach((e=>{const n=sizeFromShape(e.shape);a.set(e.vals,t);t+=n}))}else{let r=0;e.forEach((e=>{const s=n==="string"?fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+r;for(let t=0;t<e.shape[1];++t){a[i+t]=s[o++]}}r+=e.shape[1]}))}return a}const equalImpl=createSimpleBinaryKernelImpl(((e,t)=>e===t?1:0));const expImpl=createSimpleUnaryImpl((e=>Math.exp(e)));const expm1Impl=createSimpleUnaryImpl((e=>Math.expm1(e)));const floorImpl=createSimpleUnaryImpl((e=>Math.floor(e)));function gatherV2Impl(e,t,n){const r=buffer(n,e.dtype);for(let n=0;n<r.size;++n){const a=r.indexToLoc(n);const s=a.slice();const o=s[0];const i=s[2];const u=t.locToIndex([o,i]);s[2]=t.values[u];const l=e.locToIndex(s);if(0<=l&&l<e.values.length){r.values[n]=e.values[l]}}return r}const greaterImpl=createSimpleBinaryKernelImpl(((e,t)=>e>t?1:0));const greaterEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e>=t?1:0));const lessImpl=createSimpleBinaryKernelImpl(((e,t)=>e<t?1:0));const lessEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e<=t?1:0));const logImpl=createSimpleUnaryImpl((e=>Math.log(e)));function maxImpl(e,t,n,r){const a=getTypedArrayFromDType(r,sizeFromShape(n));for(let n=0;n<a.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];if(Number.isNaN(t)||t>s){s=t}}a[n]=s}return a}const maximumImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.max(e,t)));const minimumImpl=createSimpleBinaryKernelImpl(((e,t)=>Math.min(e,t)));const multiplyImpl=createSimpleBinaryKernelImpl(((e,t)=>e*t));function negImpl(e,t,n){const r=createScalarValue(-1,n);return multiplyImpl([],t,r,e,n)}const notEqualImpl=createSimpleBinaryKernelImpl(((e,t)=>e!==t?1:0));function transposeImpl$1(e,t,n,r,a){const s=t.length;const o=sizeFromShape(t);const i=computeStrides(t);const u=computeStrides(a);const l=getTypedArrayFromDType(n,sizeFromShape(a));for(let t=0;t<o;++t){const n=indexToLoc(t,s,i);const a=new Array(n.length);for(let e=0;e<a.length;e++){a[e]=n[r[e]]}const o=locToIndex(a,s,u);l[o]=e[t]}return l}function prodImpl(e,t,n,r){const[a,s]=computeOutAndReduceShapes(e,r);const o=upcastType(t,"int32");const i=makeZerosTypedArray(sizeFromShape(a),o);const u=sizeFromShape(s);for(let e=0;e<i.length;++e){const t=e*u;let r=1;for(let e=0;e<u;++e){r*=n[t+e]}i[e]=r}return{outVals:i,outShape:a,outDtype:o}}function rangeImpl(e,t,n,r){const a=e===t;const s=e<t&&n<0;const o=t<e&&n>1;if(a||s||o){return makeZerosTypedArray(0,r)}const i=Math.abs(Math.ceil((t-e)/n));const u=makeZerosTypedArray(i,r);if(t<e&&n===1){n=-1}u[0]=e;for(let e=1;e<u.length;e++){u[e]=u[e-1]+n}return u}const rsqrtImpl=createSimpleUnaryImpl((e=>1/Math.sqrt(e)));function scatterImpl(e,t,n,r,a,s,o,i,u,l){const c=[r/a,a];const p=e.values;const m=t.values;if(r===0){return buffer(n,t.dtype)}const d=buffer(c,t.dtype);if(typeof u==="string"){d.values.fill(u)}else if(typeof u==="number"){d.values.fill(u)}else if(typeof u==="boolean"){d.values.fill(+u)}for(let e=0;e<s;e++){const s=[];let u=0;for(let t=0;t<o;t++){const n=p[e*o+t];s.push(n);u+=n*i[t]}if(u<0||u>=r/a){throw new Error(`Invalid indices: ${s} does not index into ${n}`)}for(let n=0;n<a;n++){if(l){d.values[u*a+n]+=m[e*a+n]}else{d.values[u*a+n]=t.rank===0?m[0]:m[e*a+n]}}}return d}const sigmoidImpl=createSimpleUnaryImpl((e=>1/(1+Math.exp(-e))));function sliceImpl(e,t,n,r,a){const s=isSliceContinous(r,t,n);const o=sizeFromShape(n);const i=computeStrides(r);if(s){const n=computeFlatOffset(t,i);if(a==="string"){return e.slice(n,n+o)}return e.subarray(n,n+o)}const u=a==="string"?fromUint8ToStringArray(e):e;const l=buffer(r,a,u);const c=buffer(n,a);for(let e=0;e<c.size;++e){const n=c.indexToLoc(e);const r=n.map(((e,n)=>e+t[n]));c.set(l.get(...r),...n)}if(a==="string"){return fromStringArrayToUint8(c.values)}return c.values}const sqrtImpl=createSimpleUnaryImpl((e=>Math.sqrt(e)));const squaredDifferenceImpl=createSimpleBinaryKernelImpl(((e,t)=>{const n=e-t;return n*n}));const subImpl=createSimpleBinaryKernelImpl(((e,t)=>e-t));var shared=Object.freeze({__proto__:null,simpleAbsImpl:()=>{},addImpl:addImpl,bincountImpl:bincountImpl,bincountReduceImpl:()=>{},ceilImpl:ceilImpl,concatImpl:concatImpl$1,equalImpl:equalImpl,expImpl:expImpl,expm1Impl:expm1Impl,floorImpl:floorImpl,gatherNdImpl:()=>{},gatherV2Impl:gatherV2Impl,greaterImpl:greaterImpl,greaterEqualImpl:greaterEqualImpl,lessImpl:lessImpl,lessEqualImpl:lessEqualImpl,linSpaceImpl:()=>{},logImpl:logImpl,maxImpl:maxImpl,maximumImpl:maximumImpl,minimumImpl:minimumImpl,multiplyImpl:multiplyImpl,negImpl:negImpl,notEqualImpl:notEqualImpl,prodImpl:prodImpl,rangeImpl:rangeImpl,rsqrtImpl:rsqrtImpl,scatterImpl:scatterImpl,sigmoidImpl:sigmoidImpl,sliceImpl:sliceImpl,sparseFillEmptyRowsImpl:()=>{},sparseReshapeImpl:()=>{},sparseSegmentReductionImpl:()=>{},sqrtImpl:sqrtImpl,squaredDifferenceImpl:squaredDifferenceImpl,stridedSliceImpl:()=>{},stringNGramsImpl:()=>{},stringSplitImpl:()=>{},stringToHashBucketFastImpl:()=>{},subImpl:subImpl,tileImpl:()=>{},topKImpl:()=>{},transposeImpl:transposeImpl$1,uniqueImpl:()=>{}});const{addImpl:addImplCPU,bincountImpl:bincountImplCPU,bincountReduceImpl:bincountReduceImplCPU,ceilImpl:ceilImplCPU,concatImpl:concatImplCPU,equalImpl:equalImplCPU,expImpl:expImplCPU,expm1Impl:expm1ImplCPU,floorImpl:floorImplCPU,gatherNdImpl:gatherNdImplCPU,gatherV2Impl:gatherV2ImplCPU,greaterImpl:greaterImplCPU,greaterEqualImpl:greaterEqualImplCPU,lessImpl:lessImplCPU,lessEqualImpl:lessEqualImplCPU,linSpaceImpl:linSpaceImplCPU,logImpl:logImplCPU,maxImpl:maxImplCPU,maximumImpl:maximumImplCPU,minimumImpl:minimumImplCPU,multiplyImpl:multiplyImplCPU,negImpl:negImplCPU,notEqualImpl:notEqualImplCPU,prodImpl:prodImplCPU,rangeImpl:rangeImplCPU,rsqrtImpl:rsqrtImplCPU,scatterImpl:scatterImplCPU,sigmoidImpl:sigmoidImplCPU,simpleAbsImpl:simpleAbsImplCPU,sliceImpl:sliceImplCPU,sparseFillEmptyRowsImpl:sparseFillEmptyRowsImplCPU,sparseReshapeImpl:sparseReshapeImplCPU,sparseSegmentReductionImpl:sparseSegmentReductionImplCPU,sqrtImpl:sqrtImplCPU,stridedSliceImpl:stridedSliceImplCPU,stringNGramsImpl:stringNGramsImplCPU,stringSplitImpl:stringSplitImplCPU,stringToHashBucketFastImpl:stringToHashBucketFastImplCPU,subImpl:subImplCPU,tileImpl:tileImplCPU,topKImpl:topKImplCPU,transposeImpl:transposeImplCPU,uniqueImpl:uniqueImplCPU}=shared;function getVecChannels(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function getChannels(e,t){if(t===1){return[e]}return getVecChannels(e,t)}function getSourceCoords$1(e,t){if(e===1){return"rc"}let n="";for(let r=0;r<e;r++){n+=t[r];if(r<e-1){n+=","}}return n}class PackProgram{constructor(e){this.variableNames=["A"];this.packedInputs=false;this.packedOutput=true;this.outputShape=e;this.rank=e.length;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);if(this.rank===0){this.userCode=`\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `}else{const e=getChannels("rc",this.rank);const t=getCoordsDataType(this.rank);const n=this.getOutOfBoundsCondition(e);const r=this.getSetup(e);const a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++){for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let t=2;t<this.rank;t++){a=`${e[e.length-1-t]},`+a}t.push(a)}}return t}getOutOfBoundsCondition(e){if(this.rank===1){return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`}let t="";for(let n=this.rank-2;n<this.rank;n++){t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`;if(n<this.rank-1){t+="||"}}return t}getSetup(e){if(this.rank===1){return""}const t=e.slice(-2);const n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1];const r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(this.rank===1){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${e} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class ReshapePackedProgram{constructor(e,t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);let n=``;for(let e=0;e<4;e++){let t=`thisRC = rc;`;if(e%2===1){t+=`thisRC.z += 1;`}if(e>1){t+=`thisRC.y += 1;`}n+=`\n        ${t}\n        ${e>0?`if(thisRC.y < rows && thisRC.z < cols){`:""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}this.userCode=`\n      ${getReshapedInputCoords(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?getFlatIndexFrom3DOutput():getFlatIndexFrom3D(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}function getReshapedInputCoords(e,t){const n=t?getLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],"inputShape"):getLogicalCoordinatesFromFlatIndex(["r","c","d"],e);return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}class TextureManager{constructor(e){this.gpgpu=e;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.logEnabled=false;this.usedTextures={}}acquireTexture(e,t,n){const r=getPhysicalFromLogicalTextureType(t,n);const a=getKeyFromTextureShape(e,r,n);if(!(a in this.freeTextures)){this.freeTextures[a]=[]}if(!(a in this.usedTextures)){this.usedTextures[a]=[]}const s=computeBytes(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--;this.numUsedTextures++;this._numBytesFree-=s;this.log();const e=this.freeTextures[a].shift();this.usedTextures[a].push(e);return e}let o;if(r===PhysicalTextureType.PACKED_2X2_FLOAT32){o=this.gpgpu.createPackedMatrixTexture(e[0],e[1])}else if(r===PhysicalTextureType.PACKED_2X2_FLOAT16){o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1])}else if(r===PhysicalTextureType.UNPACKED_FLOAT32){o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1])}else if(r===PhysicalTextureType.UNPACKED_FLOAT16){o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1])}else if(r===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE){o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])}this.usedTextures[a].push(o);this.numUsedTextures++;this._numBytesAllocated+=s;this.log();return o}releaseTexture(e,t,n,r){if(this.freeTextures==null){return}const a=getPhysicalFromLogicalTextureType(n,r);const s=getKeyFromTextureShape(t,a,r);if(!(s in this.freeTextures)){this.freeTextures[s]=[]}const o=computeBytes(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r);const i=env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");if(i!==-1&&this._numBytesAllocated>i){this.gpgpu.deleteMatrixTexture(e.texture);this._numBytesAllocated-=o}else{this.freeTextures[s].push(e);this.numFreeTextures++;this._numBytesFree+=o}this.numUsedTextures--;const u=this.usedTextures[s];const l=u.indexOf(e);if(l<0){throw new Error("Cannot release a texture that was never provided by this "+"texture manager")}u.splice(l,1);this.log()}log(){if(!this.logEnabled){return}const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`);console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures==null){return}for(const e in this.freeTextures){this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}))}for(const e in this.usedTextures){this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}))}this.freeTextures=null;this.usedTextures=null;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0}}function numBytesForInternalFormat(e,t){const n=e;if(t===n.R32F){return 4}else if(t===n.R16F){return 2}else if(t===n.RGBA32F){return 16}else if(t===e.RGBA){return 16}else if(t===n.RGBA16F){return 8}else if(t===n.RGBA8){return 4}throw new Error(`Unknown internal format ${t}`)}function computeBytes(e,t,n,r,a){const s=internalFormatForPhysicalTexType(t,r);let o;if(a){const[t,n]=getPackedMatrixTextureShapeWidthHeight(e[0],e[1]);o=t*n}else{const[t,n]=getUnpackedMatrixTextureShapeWidthHeight(e[0],e[1]);o=t*n}const i=numBytesForInternalFormat(n,s);return o*i}function internalFormatForPhysicalTexType(e,t){switch(e){case PhysicalTextureType.PACKED_2X2_FLOAT32:return getInternalFormatForPackedMatrixTexture(t);case PhysicalTextureType.PACKED_2X2_FLOAT16:return getInternalFormatForFloat16PackedMatrixTexture(t);case PhysicalTextureType.UNPACKED_FLOAT32:return getInternalFormatForFloat32MatrixTexture(t);case PhysicalTextureType.UNPACKED_FLOAT16:return getInternalFormatForFloat16MatrixTexture(t);case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:return getInternalFormatForUnsignedBytesMatrixTexture(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function getPhysicalTextureForRendering(e){if(env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")){if(e){return PhysicalTextureType.PACKED_2X2_FLOAT32}return PhysicalTextureType.UNPACKED_FLOAT32}if(e){return PhysicalTextureType.PACKED_2X2_FLOAT16}return PhysicalTextureType.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(e,t){if(e===TextureUsage.UPLOAD){return PhysicalTextureType.PACKED_2X2_FLOAT32}else if(e===TextureUsage.RENDER||e==null){return getPhysicalTextureForRendering(t)}else if(e===TextureUsage.DOWNLOAD||e===TextureUsage.PIXELS){return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE}throw new Error(`Unknown logical texture type ${e}`)}function getKeyFromTextureShape(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class UnaryOpProgram{constructor(e,t){this.variableNames=["A"];this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const CHECK_NAN_SNIPPET$1=`if (isnan(x)) return x;`;const LINEAR$1=`return x;`;const ABS=`return abs(x);`;const ELU$1=`return (x >= 0.0) ? x : (exp(x) - 1.0);`;const RELU$2=CHECK_NAN_SNIPPET$1+`\n  return (x < 0.0) ? 0.0 : x;\n`;const RELU6$1=CHECK_NAN_SNIPPET$1+`\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;const CLONE="return x;";const SIGMOID$2=`return 1.0 / (1.0 + exp(-1.0 * x));`;const LINEAR=`return x;`;const ELU=`\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;const RELU$1=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const RELU6=`\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const SIGMOID$1=`return 1.0 / (1.0 + exp(-1.0 * x));`;class UnaryOpPackedProgram{constructor(e,t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class UnpackProgram{constructor(e){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=false;this.outputShape=e;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const t=e.length;const n=getChannels("rc",t);const r=getCoordsDataType(t);const a=getSourceCoords$1(t,n);const s=n.slice(-2);const o=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const EPSILON_FLOAT32=1e-7;const EPSILON_FLOAT16=1e-4;const binaryCaches={};function getBinaryCache(e){if(e in binaryCaches){return binaryCaches[e]}binaryCaches[e]={};return binaryCaches[e]}const CPU_HANDOFF_SIZE_THRESHOLD=env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");const BEFORE_PAGING_CONSTANT=600;function numMBBeforeWarning(){if(env().global.screen==null){return 1024}return env().global.screen.height*env().global.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT/1024/1024}class MathBackendWebGL extends KernelBackend{constructor(e){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=false;this.pendingDeletes=0;this.disposed=false;if(!env().getBool("HAS_WEBGL")){throw new Error("WebGL is not supported on this device")}let t;if(e!=null){if(e instanceof GPGPUContext){t=e}else{const n=getWebGLContext(env().getNumber("WEBGL_VERSION"),e);t=new GPGPUContext(n)}this.binaryCache={};this.gpgpuCreatedLocally=false}else{const e=getWebGLContext(env().getNumber("WEBGL_VERSION"));t=new GPGPUContext(e);this.binaryCache=getBinaryCache(env().getNumber("WEBGL_VERSION"));this.gpgpuCreatedLocally=true}this.gpgpu=t;this.canvas=this.gpgpu.gl.canvas;this.textureManager=new TextureManager(this.gpgpu);this.numMBBeforeWarning=numMBBeforeWarning();this.texData=new DataStorage(this,engine())}nextDataId(){return MathBackendWebGL.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if(env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||env().getBool("DEBUG")){this.checkNumericalProblems(e)}if(n==="complex64"&&e!=null){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}const r={id:this.nextDataId()};this.texData.set(r,{shape:t,dtype:n,values:e,usage:TextureUsage.UPLOAD,refCount:1});return r}refCount(e){if(this.texData.has(e)){const t=this.texData.get(e);return t.refCount}return 0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(env().getBool("DEBUG")){this.checkNumericalProblems(t)}if(r==="complex64"){throw new Error(`Cannot write to a complex64 dtype. `+`Please use tf.complex(real, imag).`)}this.texData.set(e,{shape:n,dtype:r,values:t,usage:TextureUsage.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e);const{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:o,isPacked:i}=t;if(s!=null){let t;if(i){t=new UnaryOpPackedProgram(o,CLONE)}else{t=new UnaryOpProgram(o,CLONE)}const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r);const a=this.readSync(n.dataId);this.disposeIntermediateTensorInfo(n);return a}if(n!=null){return this.convertAndCacheOnCPU(e)}if(r==="string"){return n}const u=this.activeTimers!=null;let l;if(u){l=now()}let c;if(r==="complex64"){const e=this.readSync(a.real.dataId);const t=this.readSync(a.imag.dataId);c=mergeRealAndImagArrays(e,t)}else{c=this.getValuesFromTexture(e)}if(u){this.downloadWaitMs+=now()-l}return this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e);const{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(a!=null){let t;if(i){t=new UnaryOpPackedProgram(r,CLONE)}else{t=new UnaryOpProgram(r,CLONE)}const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s);const a=this.read(n.dataId);this.disposeIntermediateTensorInfo(n);return a}if(n!=null){return this.convertAndCacheOnCPU(e)}if(env().getBool("DEBUG")){if(!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&env().getNumber("WEBGL_VERSION")===2){throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and `+`WEBGL_VERSION=2 not yet supported.`)}}let u=null;let l;if(s!=="complex64"&&env().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...getDenseTexShape(r))}this.pendingRead.set(e,[]);if(s!=="complex64"){await this.gpgpu.createAndWaitForFence()}let c;if(s==="complex64"){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);const t=e[0];const n=e[1];c=mergeRealAndImagArrays(t,n)}else if(u==null){c=this.getValuesFromTexture(e)}else{const e=sizeFromShape(r);c=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(l!=null){this.disposeIntermediateTensorInfo(l)}if(u!=null){const e=this.gpgpu.gl;callAndCheck(e,(()=>e.deleteBuffer(u)))}const p=this.convertAndCacheOnCPU(e,c);const m=this.pendingRead.get(e);this.pendingRead.delete(e);m.forEach((e=>e(p)));if(this.pendingDisposal.has(e)){this.pendingDisposal.delete(e);if(this.disposeData(e)){engine().removeDataId(e,this)}this.pendingDeletes--}return p}readToGPU(e,t={}){const n=this.texData.get(e);const{values:r,shape:a,slice:s,dtype:o,isPacked:i,texture:u}=n;if(o==="complex64"){throw new Error("Does not support reading texture for complex64 dtype.")}if(s!=null){let n;if(i){n=new UnaryOpPackedProgram(a,CLONE)}else{n=new UnaryOpProgram(a,CLONE)}const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:o}],o);const s=this.readToGPU(r,t);this.disposeIntermediateTensorInfo(r);return s}if(u==null){if(r!=null){throw new Error("Data is not on GPU but on CPU.")}else{throw new Error("There is no data on GPU or CPU.")}}const l=this.decode(e,t.customTexShape);const c=engine().makeTensorFromTensorInfo(l);const p=this.texData.get(l.dataId);return Object.assign({tensorRef:c},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string"){try{const n=t.map((e=>decodeString(e)));return buffer(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}}return buffer(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e==null){return}for(let t=0;t<e.length;t++){const n=e[t];if(!canBeRepresented(n)){if(env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")){throw Error(`The value ${n} cannot be represented with your `+`current settings. Consider enabling float32 rendering: `+`'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`)}throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e);const a=sizeFromShape(t);if(env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e);const r=this.texData.get(n.dataId);const s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...getDenseTexShape(t)).subarray(0,a);this.disposeIntermediateTensorInfo(n);return s}const s=env().getBool("WEBGL_PACK")&&r===true;const o=s?getShapeAs3D(t):t;const i=s?new EncodeFloatPackedProgram(o):new EncodeFloatProgram(o);const u=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32");const l=this.texData.get(u.dataId);const c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,a);this.disposeIntermediateTensorInfo(u);return c}timerAvailable(){return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers;const n=[];let r=false;if(this.programTimersStack==null){this.programTimersStack=n;r=true}else{this.activeTimers.push(n)}this.activeTimers=n;e();const a=flatten(this.activeTimers.map((e=>e.query))).filter((e=>e!=null));const s=flatten(this.activeTimers.map((e=>e.name))).filter((e=>e!=null));this.activeTimers=t;if(r){this.programTimersStack=null}const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);o["kernelMs"]=sum$2(e);o["getExtraProfileInfo"]=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else{o["kernelMs"]={error:"WebGL query timers are not supported in this environment."}}this.uploadWaitMs=0;this.downloadWaitMs=0;return o})()}memory(){return{unreliable:false,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.beginQuery()}return{startMs:now(),endMs:null}}endTimer(e){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){this.gpgpu.endQuery();return e}e.endMs=now();return e}async getQueryTime(e){if(env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){return this.gpgpu.waitForQueryAndGetTime(e)}const t=e;return t.endMs-t.startMs}disposeData(e,t=false){if(this.pendingDisposal.has(e)){return false}if(!this.texData.has(e)){return true}if(t){this.texData.get(e).refCount=0}else{this.texData.get(e).refCount--}if(!t&&this.texData.get(e).refCount>0){return false}if(this.pendingRead.has(e)){this.pendingDisposal.add(e);this.pendingDeletes++;return false}this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);if(n!=null){this.disposeData(n.real.dataId,t);this.disposeData(n.imag.dataId,t)}this.texData.delete(e);return true}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:o}=this.texData.get(e);const i=o&&o.origDataId||e;const u=this.dataRefCount.get(i);if(u>1){this.dataRefCount.set(i,u-1)}else{this.dataRefCount.delete(i);if(t!=null){this.numBytesInGPU-=this.computeBytes(r,n);this.textureManager.releaseTexture(t,r,a,s)}}const l=this.texData.get(e);l.texture=null;l.texShape=null;l.isPacked=false;l.slice=null}getTexture(e){this.uploadToGPU(e);return this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=CPU_HANDOFF_SIZE_THRESHOLD){return env().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>this.texData.get(e.dataId).texture==null&&sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){warn("tf.where() in webgl locks the UI thread. "+"Call tf.whereAsync() instead");const t=e.dataSync();return whereImpl(e.shape,t)}packedUnaryOp(e,t,n){const r=new UnaryOpPackedProgram(e.shape,t);const a=this.compileAndRun(r,[e],n);return engine().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const t=simpleAbsImplCPU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(env().getBool("WEBGL_PACK_UNARY_OPERATIONS")){return this.packedUnaryOp(e,ABS,e.dtype)}const t=new UnaryOpProgram(e.shape,ABS);const n=this.compileAndRun(t,[e]);return engine().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t==="string"&&n!=null&&n.length>0&&isString(n[0])){const a=n.map((e=>encodeString(e)));r=this.write(a,e,t)}else{r=this.write(n,e,t)}this.texData.get(r).usage=null;return{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return engine().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new UnpackProgram(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new PackProgram(e.shape);const n=true;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){const n=[getBatchDim(e.shape),...getRowsCols(e.shape)];const r={dtype:e.dtype,shape:n,dataId:e.dataId};const a=[getBatchDim(t),...getRowsCols(t)];const s=new ReshapePackedProgram(a,n);const o=true;const i=[n];const u=this.runWebGLProgram(s,[r],e.dtype,i,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const n=this.texData.get(e);const{isPacked:r,shape:a,dtype:s}=n;if(t!=null){const e=sizeFromShape(a);const n=t[0]*t[1]*4;assert(e<=n,(()=>"customTexShape is too small. "+"Row * Column * 4 should be equal or larger than the "+"size of the tensor data."))}const o=getShapeAs3D(a);let i;if(r){i=new DecodeMatrixPackedProgram(o)}else{i=new DecodeMatrixProgram(o)}const u=true;const l=[t!=null?t:getDenseTexShape(o)];const c=this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,l,u,t);return{dtype:s,shape:a,dataId:c.dataId}}runWebGLProgram(e,t,n,r,a=false,s){const o=this.makeTensorInfo(e.outputShape,n);const i=this.texData.get(o.dataId);if(e.packedOutput){i.isPacked=true}if(e.outPackingScheme===PackingScheme.DENSE){const t=s!=null?s:getDenseTexShape(e.outputShape);i.texShape=t.map((e=>e*2))}if(e.outTexUsage!=null){i.usage=e.outTexUsage}if(sizeFromShape(o.shape)===0){i.values=getTypedArrayFromDType(o.dtype,0);return o}const u=[];const l=t.map((t=>{if(t.dtype==="complex64"){throw new Error(`GPGPUProgram does not support complex64 input. For complex64 `+`dtypes, please separate the program into real and imaginary `+`parts.`)}let n=this.texData.get(t.dataId);if(n.texture==null){if(!e.packedInputs&&sizeFromShape(t.shape)<=env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")){return{shape:t.shape,texData:null,isUniform:true,uniformValues:n.values}}if(e.packedInputs){n.isPacked=true;n.shape=t.shape}}this.uploadToGPU(t.dataId);if(!!n.isPacked!==!!e.packedInputs){t=n.isPacked?this.unpackTensor(t):this.packTensor(t);u.push(t);n=this.texData.get(t.dataId)}else if(n.isPacked&&!isReshapeFree(n.shape,t.shape)){const e=t;const r=t.shape;t.shape=n.shape;t=this.packedReshape(t,r);u.push(t);n=this.texData.get(t.dataId);e.shape=r}return{shape:t.shape,texData:n,isUniform:false}}));this.uploadToGPU(o.dataId);const c={shape:o.shape,texData:i,isUniform:false};const p=makeShaderKey(e,l,c);const m=this.getAndSaveBinary(p,(()=>compileProgram(this.gpgpu,e,l,c)));const d=this.activeTimers!=null;let h;if(d){h=this.startTimer()}if(!env().get("ENGINE_COMPILE_ONLY")){runProgram(this.gpgpu,m,l,c,r)}u.forEach((e=>this.disposeIntermediateTensorInfo(e)));if(d){h=this.endTimer(h);this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)})}const f=env().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=now();if(e-this.lastGlFlushTime>f){this.gpgpu.gl.flush();this.lastGlFlushTime=e}}if(!env().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&a===false){const e=this.unpackTensor(o);this.disposeIntermediateTensorInfo(o);return e}return o}compileAndRun(e,t,n,r,a=false){n=n||t[0].dtype;const s=this.runWebGLProgram(e,t,n,r,a);return s}getAndSaveBinary(e,t){if(!(e in this.binaryCache)){this.binaryCache[e]=t()}return this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(this.disposed){return}if(!env().getBool("IS_TEST")){const e=Object.keys(this.binaryCache);e.forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);delete this.binaryCache[e]}))}this.textureManager.dispose();if(this.canvas!=null&&(typeof HTMLCanvasElement!=="undefined"&&this.canvas instanceof HTMLCanvasElement)){this.canvas.remove()}else{this.canvas=null}if(this.gpgpuCreatedLocally){this.gpgpu.program=null;this.gpgpu.dispose()}this.disposed=true}floatPrecision(){if(this.floatPrecisionValue==null){this.floatPrecisionValue=tidy((()=>{if(!env().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=env().getBool("DEBUG");env().set("DEBUG",false);const t=this.abs(scalar(1e-8)).dataSync()[0];env().set("DEBUG",e);if(t>0){return 32}}return 16}))}return this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32:EPSILON_FLOAT16}uploadToGPU(e){const t=this.texData.get(e);const{shape:n,dtype:r,values:a,texture:s,usage:o,isPacked:i}=t;if(s!=null){return}const u=this.activeTimers!=null;let l;if(u){l=now()}let c=t.texShape;if(c==null){c=getTextureShapeFromLogicalShape(n,i);t.texShape=c}if(a!=null){const e=getShapeAs3D(n);let s;let o=c[1],p=c[0];const m=a instanceof Uint8Array||a instanceof Uint8ClampedArray;if(i||!m){[o,p]=getPackedMatrixTextureShapeWidthHeight(c[0],c[1])}if(i){s=new EncodeMatrixPackedProgram(e,m)}else{s=new EncodeMatrixProgram(e,m)}const d=m?[p,o]:c;const h=this.makeTensorInfo(d,r);const f=this.texData.get(h.dataId);if(m){f.usage=TextureUsage.PIXELS}else{f.usage=TextureUsage.UPLOAD}f.texShape=d;this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(h.dataId),o,p,a);const g=[[p,o]];const y=true;const x=this.runWebGLProgram(s,[h],r,g,y);const T=this.texData.get(x.dataId);t.texShape=T.texShape;t.isPacked=T.isPacked;t.usage=T.usage;if(!env().get("ENGINE_COMPILE_ONLY")){t.texture=T.texture;t.values=null;this.texData.delete(x.dataId)}else{this.disposeData(x.dataId)}this.disposeIntermediateTensorInfo(h);if(u){this.uploadWaitMs+=now()-l}}else{const e=this.acquireTexture(c,o,r,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e);const{dtype:r}=n;this.releaseGPUData(e);if(t!=null){n.values=float32ToTypedArray(t,r)}return n.values}acquireTexture(e,t,n,r){this.numBytesInGPU+=this.computeBytes(e,n);if(!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=true;console.warn(`High memory usage in GPU: ${e} MB, `+`most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache)){this.checkCompletion_(e)}}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache)){e.push(this.checkCompletionAsync_(t))}return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t);e(true)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)){return this.checkCompletion_(e)}else{await nextFrame();return this.checkCompletionAsync_(e)}}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===false){console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram));if(this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===false){logShaderSourceAndInfoLog(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader));throw new Error("Failed to compile fragment shader.")}throw new Error("Failed to link vertex and fragment shaders.")}return true}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:l}=getUniformLocations(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t;e.customUniformLocations=n;e.infLoc=r;e.nanLoc=a;e.inShapesLocations=s;e.inTexShapesLocations=o;e.outShapeLocation=i;e.outShapeStridesLocation=u;e.outTexShapeLocation=l}}}MathBackendWebGL.nextDataId=0;function float32ToTypedArray(e,t){if(t==="float32"||t==="complex64"){return e}else if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t){n[t]=Math.round(e[t])}return n}else{throw new Error(`Unknown dtype ${t}`)}}if(isBrowser()){registerBackend("webgl",(()=>new MathBackendWebGL),2)}class BinaryOpProgram{constructor(e,t,n){this.variableNames=["A","B"];this.outputShape=assertAndGetBroadcastShape(t,n);this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const CHECK_NAN_SNIPPET=`\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;class BinaryOpPackedProgram{constructor(e,t,n,r=false){this.variableNames=["A","B"];this.supportsBroadcasting=true;this.packedInputs=true;this.packedOutput=true;this.outputShape=assertAndGetBroadcastShape(t,n);const a=this.outputShape.length;this.enableShapeUniforms=useShapeUniforms(a);let s="";if(r){if(a===0||sizeFromShape(this.outputShape)===1){s=`\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `}else{const e=getCoordsDataType(a);s=`\n          ${e} coords = getOutputCoords();\n        `;if(a===1){if(this.enableShapeUniforms){s+=`\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `}else{s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `}}else{const e=getChannels("coords",a);if(this.enableShapeUniforms){s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}else{s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function identity(e){const{inputs:t,backend:n}=e;const{x:r}=t;n.incRef(r.dataId);return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const identityConfig={kernelName:Identity,backendName:"webgl",kernelFunc:identity};function complex(e){const{inputs:t,backend:n}=e;const{real:r,imag:a}=t;const s=n.makeTensorInfo(r.shape,"complex64");const o=n.texData.get(s.dataId);const i=identity({inputs:{x:r},backend:n});const u=identity({inputs:{x:a},backend:n});o.complexTensorInfos={real:i,imag:u};return s}const LEAKYRELU=`return (a < 0.) ? b * a : a;`;const LEAKYRELU_PACKED=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;const PRELU=`return (a < 0.) ? b * a : a;`;const PRELU_PACKED=`\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n`;const CHECK_NAN_SNIPPET_UNARY=`if (isnan(x)) return x;`;function unaryKernelFunc({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{const{x:o}=a;const i=s;const u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&n!=null){const e=i.texData.get(o.dataId);const t=n(e.values,u);return i.makeTensorInfo(o.shape,u,t)}const l=env().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let c;if(l){c=new UnaryOpPackedProgram(o.shape,t)}else{c=new UnaryOpProgram(o.shape,e)}return i.runWebGLProgram(c,[o],u)}}function binaryKernelFunc({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=false,supportsComplex:r=false,cpuKernelImpl:a,dtype:s}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o;const c=i;if(r&&u.dtype==="complex64"){const t=c.texData.get(u.dataId);const n=c.texData.get(l.dataId);const[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t;const a={dataId:n.dataId,dtype:n.dtype,shape:u.shape};const s={dataId:r.dataId,dtype:r.dtype,shape:l.shape};const o=new BinaryOpProgram(e,u.shape,l.shape);return c.runWebGLProgram(o,[a,s],upcastType(n.dtype,r.dtype))}));const s=complex({inputs:{real:r,imag:a},backend:c});c.disposeIntermediateTensorInfo(r);c.disposeIntermediateTensorInfo(a);return s}const p=s||upcastType(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&a!=null){const e=c.texData.get(u.dataId).values;const t=c.texData.get(l.dataId).values;const n=u.dtype==="string"?fromUint8ToStringArray(e):e;const r=u.dtype==="string"?fromUint8ToStringArray(t):t;const[s,o]=a(u.shape,l.shape,n,r,p);const i=c.makeTensorInfo(o,p);const m=c.texData.get(i.dataId);m.values=s;return i}const m=env().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let d;if(m){d=new BinaryOpPackedProgram(t,u.shape,l.shape,n)}else{d=new BinaryOpProgram(e,u.shape,l.shape)}return c.runWebGLProgram(d,[u,l],p)}}function mapActivationToShaderProgram(e,t=false){if(e==="linear"){if(t){return LINEAR}return LINEAR$1}else if(e==="relu"){if(t){return RELU$1}return RELU$2}else if(e==="elu"){if(t){return ELU}return ELU$1}else if(e==="relu6"){if(t){return RELU6}return RELU6$1}else if(e==="prelu"){if(t){return PRELU_PACKED}return PRELU}else if(e==="leakyrelu"){if(t){return LEAKYRELU_PACKED}return LEAKYRELU}else if(e==="sigmoid"){if(t){return SIGMOID$1}return SIGMOID$2}throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}const ADD="return a + b;";const addKernelFunc=binaryKernelFunc({opSnippet:ADD,packedOpSnippet:ADD,supportsComplex:true,cpuKernelImpl:addImplCPU});const addConfig={kernelName:Add,backendName:"webgl",kernelFunc:addKernelFunc};class MeanProgram{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const o=Math.floor(n/4)*4;const i=n%4;let u=`sumValue += dot(values, ones);`;if(t!=null){const e=1/t;u=`sumValue += dot(values * ${isInt(e)?e.toPrecision(2):e}, ones);`}let l="";if(a%n>0){l=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `}this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${i===1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${i===2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${i===3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class ReduceProgram{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let o="0.0";let i=``;if(t==="prod"){o="1.0"}else if(t==="min"){o="1.0 / 1e-20";i=`min`}else if(t==="max"){o="-1.0 / 1e-20";i=`max`}let u=`${t}(${t}(${t}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";if(t==="sum"){u=`sumValue`}else if(t==="prod"){u=`prodValue`}else if(t==="all"){u=`allValue`}else if(t==="any"){u=`anyValue`}const l=Math.floor(n/4)*4;const c=n%4;let p=`\n      if (${t==="sum"}) {\n        sumValue += dot(values, ones);\n      } else if (${t==="prod"}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${i}(values, minMaxValue);\n        if (${t==="min"} || ${t==="max"}) {\n          minMaxValue = ${i}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `;let m=`vec4`;if(t==="all"){o="1.0";p=`\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;m=`bvec4`}else if(t==="any"){o="0.0";p=`\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;m=`bvec4`}let d="";if(a%n>0){d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `}this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${c===1}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${c===2}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${c===3}) {\n          ${m} values = ${m}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${p}\n        }\n        setOutput(${u});\n      }\n    `}}function getReductionStages(e){const t=[];while(t.length===0||t[t.length-1].outSize!==1){const n=t.length?t[t.length-1].outSize:e[1];const r=computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function reduce(e,t,n,r){const a=getReductionStages(e.shape);let s=e;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:u,outSize:l}=a[o];let c;let p;if(n==="mean"){c=o===0?new MeanProgram({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},i):new MeanProgram({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l})}else{c=new ReduceProgram({windowSize:u,inSize:i,batchSize:e.shape[0],outSize:l},n)}p=s;s=r.runWebGLProgram(c,[s],t);if(p.dataId!==e.dataId){r.disposeIntermediateTensorInfo(p)}}return s}function packedReshape(e,t,n){const r=[getBatchDim(e.shape),...getRowsCols(e.shape)];const a={dtype:e.dtype,shape:r,dataId:e.dataId};const s=[getBatchDim(t),...getRowsCols(t)];const o=new ReshapePackedProgram(s,r);const i=true;const u=[r];const l=n.runWebGLProgram(o,[a],e.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function reshape(e){const{inputs:t,backend:n,attrs:r}=e;const{x:a}=t;const{shape:s}=r;const o=n;const i=sizeFromShape(a.shape);const u=inferFromImplicitShape(s,i);const l=sizeFromShape(u);assert(i===l,(()=>`The new shape (${u}) has ${l} elements and the old `+`shape (${a.shape}) has ${i} elements. The new shape and old `+`shape must have the same number of elements.`));const c=o.texData.get(a.dataId);if(c.isPacked&&!isReshapeFree(a.shape,u)&&!(c.texture!==null&&isReshapeFree(c.shape,u))){return packedReshape(a,u,o)}o.incRef(a.dataId);return{dataId:a.dataId,shape:u,dtype:a.dtype}}const reshapeConfig={kernelName:Reshape,backendName:"webgl",kernelFunc:reshape};class TransposeProgram{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++){n[r]=e[t[r]]}this.outputShape=n;this.rank=n.length;const r=getCoordsDataType(this.rank);const a=getSwitchedCoords(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}function getSwitchedCoords(e){const t=e.length;if(t>6){throw Error(`Transpose for rank ${t} is not yet supported`)}const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"];const r=new Array(t);for(let t=0;t<e.length;t++){r[e[t]]=n[t]}return r.join()}class TransposePackedProgram{constructor(e,t){this.variableNames=["A"];this.packedInputs=true;this.packedOutput=true;const n=new Array(e.length);for(let r=0;r<n.length;r++){n[r]=e[t[r]]}this.outputShape=n;this.rank=n.length;if(this.rank>6){throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`)}const r=getCoordsDataType(this.rank);const a=getVecChannels("rc",this.rank);const s=new Array(this.rank);for(let e=0;e<t.length;e++){s[t[e]]=a[e]}const o=`vec2(${s.slice(-2).join()})`;const i=`++${a[this.rank-1]} < ${n[this.rank-1]}`;const u=`getChannel(getA(${s.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${i}) {\n        result[1] = ${u};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${i}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function transposeImpl(e,t,n){const r=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(e.shape,t):new TransposeProgram(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function sumImpl(e,t,n,r){const a=t;const s=e.shape.length;const o=parseAxisParam(a,e.shape);let i=o;const u=getAxesPermutation(i,s);const l=u!=null;let c=e;if(l){c=transposeImpl(e,u,r);i=getInnerMostAxes(i.length,s)}assertAxesAreInnerMostDims("sum",i,s);const[p,m]=computeOutAndReduceShapes(c.shape,i);let d=p;if(n){d=expandShapeToKeepDim(p,o)}const h=sizeFromShape(m);const f=sizeFromShape(e.shape);const g=f/h;const y=reshape({inputs:{x:c},attrs:{shape:[g,h]},backend:r});const x=sumOutType(e.dtype);const T=reduce(y,x,"sum",r);const E=reshape({inputs:{x:T},attrs:{shape:d},backend:r});r.disposeIntermediateTensorInfo(y);r.disposeIntermediateTensorInfo(T);if(l){r.disposeIntermediateTensorInfo(c)}return E}function sum(e){const{inputs:t,backend:n,attrs:r}=e;const{x:a}=t;const{axis:s,keepDims:o}=r;return sumImpl(a,s,o,n)}const sumConfig={kernelName:Sum,backendName:"webgl",kernelFunc:sum};const POW=`\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n`;const POW_PACKED=`\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  `+CHECK_NAN_SNIPPET+`\n  return result;\n`;const pow=binaryKernelFunc({opSnippet:POW,packedOpSnippet:POW_PACKED});const powConfig={kernelName:Pow,backendName:"webgl",kernelFunc:pow};class ConcatProgram{constructor(e){this.outputShape=[];this.outputShape=computeOutShape$1(e,1);this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++){t[n]=t[n-1]+e[n][1]}const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) `+`setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length;const a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`);this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ConcatPackedProgram{constructor(e,t){this.packedInputs=true;this.packedOutput=true;this.outputShape=[];this.outputShape=computeOutShape$1(e,t);const n=this.outputShape;const r=n.length;const a=getCoordsDataType(r);const s=getChannels("coords",r);const o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const i=new Array(e.length-1);i[0]=e[0][t];for(let n=1;n<i.length;n++){i[n]=i[n-1]+e[n][t]}const u=o[t];const l=o.slice(-2);const c=o.join();let p=`if (${u} < ${i[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let e=1;e<i.length;e++){const t=i[e-1];p+=`\n        if (${u} < ${i[e]}  && ${u} >= ${i[e-1]}) {\n          return getChannel(\n            getT${e}(${shiftedChannels(o,u,t)}),\n            vec2(${shiftedChannels(l,u,t)}));\n        }`}const m=i.length;const d=i[i.length-1];p+=`\n        return getChannel(\n          getT${m}(${shiftedChannels(o,u,d)}),\n          vec2(${shiftedChannels(l,u,d)}));`;this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${p}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function shiftedChannels(e,t,n){const r=e.indexOf(t);const a=e.map(((e,t)=>{if(t===r){return`${e} - ${n}`}else{return e}}));return a.join()}function real(e){const{inputs:t,backend:n}=e;const{input:r}=t;const a=n.texData.get(r.dataId);return identity({inputs:{x:a.complexTensorInfos.real},backend:n})}function concatImpl(e,t,n){const r=e[0].dtype;if(r==="complex64"){const r=e.map((e=>real({inputs:{input:e},backend:n})));const a=e.map((e=>imag({inputs:{input:e},backend:n})));const s=concatImpl(r,t,n);const o=concatImpl(a,t,n);const i=complex({inputs:{real:s,imag:o},backend:n});r.forEach((e=>n.disposeIntermediateTensorInfo(e)));a.forEach((e=>n.disposeIntermediateTensorInfo(e)));n.disposeIntermediateTensorInfo(s);n.disposeIntermediateTensorInfo(o);return i}let a=n.shouldExecuteOnCPU(e);if(r==="string"){a=true}if(a){const a=e.map((e=>{const r=sizeFromShape(e.shape.slice(t));const a=[-1,r];return reshape({inputs:{x:e},backend:n,attrs:{shape:a}})}));const s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));const o=computeOutShape$1(a.map((e=>e.shape)),1);const i=a[0].shape[0]===1;const u=concatImplCPU(s,o,r,i);const l=computeOutShape$1(e.map((e=>e.shape)),t);const c=n.makeTensorInfo(l,r,u);a.forEach((e=>n.disposeIntermediateTensorInfo(e)));return c}const s=env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>s){const r=[];for(let a=0;a<e.length;a+=s){const o=e.slice(a,a+s);r.push(concatImpl(o,t,n))}const a=concatImpl(r,t,n);for(const e of r){n.disposeIntermediateTensorInfo(e)}return a}if(env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const a=new ConcatPackedProgram(e.map((e=>e.shape)),t);return n.runWebGLProgram(a,e,r)}const{tensors2D:o,outShape:i}=computeTensors2D(e,t,n);const u=new ConcatProgram(o.map((e=>e.shape)));const l=n.runWebGLProgram(u,o,r);o.forEach((e=>n.disposeIntermediateTensorInfo(e)));const c=reshape({inputs:{x:l},attrs:{shape:i},backend:n});n.disposeIntermediateTensorInfo(l);return c}function concat(e){const{inputs:t,backend:n,attrs:r}=e;const{axis:a}=r;const s=parseAxisParam(a,t[0].shape)[0];const o=computeOutShape$1(t.map((e=>e.shape)),s);if(sizeFromShape(o)===0){return n.makeTensorInfo(o,t[0].dtype,[])}const i=t.filter((e=>sizeFromShape(e.shape)>0));if(i.length===1){return identity({inputs:{x:i[0]},backend:n})}const u=i.map((e=>e.shape));assertParamsConsistent(u,s);return concatImpl(i,s,n)}const concatConfig={kernelName:Concat,backendName:"webgl",kernelFunc:concat};function expandDims(e){const{inputs:t,attrs:n,backend:r}=e;const{dim:a}=n;const{input:s}=t;const o=s.shape.length;const i=s.shape.slice();let u=a;if(a<0){assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`));u=o+a+1}i.splice(u,0,1);return reshape({inputs:{x:s},backend:r,attrs:{shape:i}})}function pack(e){const{inputs:t,backend:n,attrs:r}=e;const{axis:a}=r;if(t.length===1){return expandDims({inputs:{input:t[0]},backend:n,attrs:{dim:a}})}const s=t[0].shape;const o=t[0].dtype;t.forEach((e=>{assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes");assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[];const u=t.map((e=>{const t=expandDims({inputs:{input:e},backend:n,attrs:{dim:a}});i.push(t);return t}));const l=concat({inputs:u,backend:n,attrs:{axis:a}});i.forEach((e=>n.disposeIntermediateTensorInfo(e)));return l}const packConfig={kernelName:Pack,backendName:"webgl",kernelFunc:pack};const NOT_EQUAL=`return float(a != b);`;const notEqual=binaryKernelFunc({opSnippet:NOT_EQUAL,cpuKernelImpl:notEqualImplCPU,dtype:"bool"});function cast(e){const{inputs:t,backend:n,attrs:r}=e;const{x:a}=t;const{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64"){return identity({inputs:{x:a},backend:n})}const e=zeros$1(a.shape);const t=cast({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});const r=complex({inputs:{real:t,imag:e},backend:n});e.dispose();n.disposeIntermediateTensorInfo(t);return r}if(a.dtype==="complex64"){const e=real({inputs:{input:a},backend:n});const t=cast({inputs:{x:e},backend:n,attrs:{dtype:s}});n.disposeIntermediateTensorInfo(e);return t}if(!hasEncodingLoss(a.dtype,s)){const e=identity({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if(s==="int32"){return int(a,n)}if(s==="bool"){const e=n.makeTensorInfo([],"bool",getTypedArrayFromDType("bool",1));const t={a:a,b:e};const r=notEqual({inputs:t,backend:n});n.disposeIntermediateTensorInfo(e);return r}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}const castConfig={kernelName:Cast,backendName:"webgl",kernelFunc:cast};const RELU=CHECK_NAN_SNIPPET$1+`\n  return (x < 0.0) ? 0.0 : x;\n`;const RELU_PACKED=`\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const relu=unaryKernelFunc({opSnippet:RELU,packedOpSnippet:RELU_PACKED});const reluConfig={kernelName:Relu,backendName:"webgl",kernelFunc:relu};function meanImpl(e,t,n,r){const a=sizeFromShape(t);const s=sizeFromShape(e.shape);const o=s/a;const i=reshape({inputs:{x:e},attrs:{shape:[o,a]},backend:r});const u=reduce(i,"float32","mean",r);const l=reshape({inputs:{x:u},attrs:{shape:n},backend:r});r.disposeIntermediateTensorInfo(i);r.disposeIntermediateTensorInfo(u);return l}const meanConfig={kernelName:Mean,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e;const{keepDims:a,axis:s}=t;const o=n;const i=r.shape.length;const u=parseAxisParam(s,r.shape);let l=u;const c=getAxesPermutation(l,i);const p=c!=null;const m=o.shouldExecuteOnCPU([r]);const d=[];let h=r;if(p){if(m){const e=o.texData.get(h.dataId);const t=e.values;const n=new Array(i);for(let e=0;e<n.length;e++){n[e]=r.shape[c[e]]}const a=transposeImplCPU(t,r.shape,r.dtype,c,n);h=o.makeTensorInfo(n,r.dtype);const s=o.texData.get(h.dataId);s.values=a}else{h=transposeImpl(r,c,o)}d.push(h);l=getInnerMostAxes(l.length,i)}assertAxesAreInnerMostDims("sum",l,i);const[f,g]=computeOutAndReduceShapes(h.shape,l);let y=f;if(a){y=expandShapeToKeepDim(f,u)}const x=meanImpl(h,g,y,o);for(const e of d){o.disposeIntermediateTensorInfo(e)}return x}};function prod(e){const{inputs:t,backend:n,attrs:r}=e;const{x:a}=t;const{axis:s,keepDims:o}=r;const i=a.shape.length;const u=[];const l=parseAxisParam(s,a.shape);let c=l;const p=getAxesPermutation(c,i);let m=a;if(p!=null){m=transpose({inputs:{x:a},backend:n,attrs:{perm:p}});c=getInnerMostAxes(c.length,i);u.push(m)}assertAxesAreInnerMostDims("prod",c,i);let d;if(n.shouldExecuteOnCPU([m])){const e=n.texData.get(m.dataId).values;const{outVals:t,outShape:r,outDtype:a}=prodImplCPU(m.shape,m.dtype,e,c);d=n.makeTensorInfo(r,a,t)}else{const[e,t]=computeOutAndReduceShapes(m.shape,c);const r=sizeFromShape(t);const s=reshape({inputs:{x:m},backend:n,attrs:{shape:[-1,r]}});const o=sumOutType(a.dtype);const i=reduce(s,o,"prod",n);d=reshape({inputs:{x:i},backend:n,attrs:{shape:e}});u.push(s);u.push(i)}if(o){u.push(d);const e=expandShapeToKeepDim(d.shape,l);d=reshape({inputs:{x:d},backend:n,attrs:{shape:e}})}u.forEach((e=>n.disposeIntermediateTensorInfo(e)));return d}const prodConfig={kernelName:Prod,backendName:"webgl",kernelFunc:prod};class PadProgram{constructor(e,t,n){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length;const a=getCoordsDataType(r);const s=t.map((e=>e[0])).join(",");const o=t.map(((t,n)=>t[0]+e[n])).join(",");const i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`\n        int start = ${s};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;return}this.userCode=`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `}}class PadPackedProgram{constructor(e,t,n){this.variableNames=["x"];this.packedInputs=true;this.packedOutput=true;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length;const a=getCoordsDataType(r);const s=t.map((e=>e[0])).join(",");const o=t.map(((t,n)=>t[0]+e[n])).join(",");const i=getChannels("rc",r);const u=getChannels("source",r);const l=`${i[r-1]} < ${this.outputShape[r-1]}`;const c=r===1?"source":`vec2(${u.slice(-2).join()})`;const p=[`${a} rc = outputLoc;`,`${i[r-1]} += 1;\n       if(${l}) {\n      `,r===1?"":`}\n       rc = outputLoc;\n       ${i[r-2]} += 1;\n       if(${i[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${i[r-1]} += 1;\n         if(${l}) {`];const m=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let d="";for(let e=0,t=r===1?2:4;e<t;e++){d+=`\n        ${p[e]}\n        if (${m}) {\n          result[${e}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${e}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}d+=r===1?`} `:`}}`;this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const padV2=e=>{const{inputs:t,backend:n,attrs:r}=e;const{x:a}=t;const{paddings:s,constantValue:o}=r;if(sizeFromShape(a.shape)===0){const e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return fill({backend:n,attrs:{shape:e,value:o,dtype:a.dtype}})}const i=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(a.shape,s,o):new PadProgram(a.shape,s,o);const u=[[o]];return n.runWebGLProgram(i,[a],a.dtype,u)};const padV2Config={kernelName:PadV2,backendName:"webgl",kernelFunc:padV2};class SliceProgram{constructor(e){this.variableNames=["source"];this.outputShape=e;this.rank=e.length;const t=getCoordsDataType(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=getCoords(this.rank);let r;const a=e.map(((e,t)=>`sourceLoc.${coords[t]} = start[${t}] + coords.${coords[t]};`));r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${a.join("\n")}\n      `;this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const coords=["x","y","z","w","u","v"];function getCoords(e){if(e===1){return"sourceLoc"}else if(e<=6){return coords.slice(0,e).map((e=>"sourceLoc."+e)).join(",")}else{throw Error(`Slicing for rank ${e} is not yet supported`)}}class SlicePackedProgram{constructor(e){this.variableNames=["source"];this.packedInputs=true;this.packedOutput=true;this.outputShape=e;this.rank=e.length;this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=getCoordsDataType(this.rank);const n=getChannels("coords",this.rank);const r=getChannels("sourceLoc",this.rank);const a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`;const s=`getChannel(getSource(${r.join()}), ${a})`;const o=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `;const i=this.rank===1?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `;const u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${o}\n        ${i}\n        setOutput(result);\n      }\n    `}}function slice(e){const{inputs:t,backend:n,attrs:r}=e;const{x:a}=t;const{begin:s,size:o}=r;const[i,u]=parseSliceParams(a,s,o);assertParamsValid(a,i,u);if(sizeFromShape(u)===0){return n.makeTensorInfo(u,a.dtype,[])}if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){const e=n.texData.get(a.dataId);const t=sliceImplCPU(e.values,i,u,a.shape,a.dtype);return n.makeTensorInfo(u,a.dtype,t)}const{isPacked:l}=n.texData.get(a.dataId);const c=isSliceContinous(a.shape,i,u);if(l||!c){const e=env().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(u):new SliceProgram(u);const t=[i];return n.runWebGLProgram(e,[a],a.dtype,t)}n.uploadToGPU(a.dataId);return shallowSlice(a,i,u,n)}function unpack(e){const{inputs:t,backend:n,attrs:r}=e;const{value:a}=t;let{axis:s}=r;if(s<0){s+=a.shape.length}const o=a;const i=o.shape.length;const u=a.shape[s];const l=new Array(i-1);let c=0;for(let e=0;e<i;e++){if(e!==s){l[c++]=o.shape[e]}}const p=[];const m=new Array(i).fill(0);const d=o.shape.slice();d[s]=1;const h=new Array(u);for(let e=0;e<h.length;e++){m[s]=e;const t=slice({inputs:{x:o},backend:n,attrs:{begin:m,size:d}});const r=reshape({inputs:{x:t},backend:n,attrs:{shape:l}});h[e]=r;p.push(t)}p.forEach((e=>n.disposeIntermediateTensorInfo(e)));return h}const unpackConfig={kernelName:Unpack,backendName:"webgl",kernelFunc:unpack};const IS_FINITE=`return float(!isnan(x) && !isinf(x));`;const isFinite$1=unaryKernelFunc({opSnippet:IS_FINITE,dtype:"bool"});const isFiniteConfig={kernelName:IsFinite,backendName:"webgl",kernelFunc:isFinite$1};class SelectProgram{constructor(e,t,n){this.variableNames=["c","a","b"];this.outputShape=t;let r;let a;if(n>4){throw Error(`Where for rank ${n} is not yet supported`)}if(n===1){a=`resRC`;r=`resRC`}else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"];const s=[];const o=[];for(let r=0;r<t.length;r++){o.push(`${n[r]}`);if(r<e){s.push(`${n[r]}`)}}r=s.join();a=o.join()}const s=getCoordsDataType(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}function select(e){const{inputs:t,backend:n}=e;const{condition:r,t:a,e:s}=t;const o=new SelectProgram(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,s],upcastType(a.dtype,s.dtype))}const selectConfig={kernelName:Select,backendName:"webgl",kernelFunc:select};const COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class BinaryOpComplexProgram{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=assertAndGetBroadcastShape(t,n);this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const MUL="return a * b;";function multiply(e){const{inputs:t,backend:n}=e;const{a:r,b:a}=t;const s=upcastType(r.dtype,a.dtype);if(r.dtype==="complex64"){const e=n.texData.get(r.dataId);const t=n.texData.get(a.dataId);const s=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,r.shape,a.shape);const o=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,r.shape,a.shape);const i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}];const u=n.runWebGLProgram(s,i,"float32");const l=n.runWebGLProgram(o,i,"float32");const c=complex({inputs:{real:u,imag:l},backend:n});n.disposeIntermediateTensorInfo(u);n.disposeIntermediateTensorInfo(l);return c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId);const t=n.texData.get(a.dataId);const[o,i]=multiplyImplCPU(r.shape,a.shape,e.values,t.values,s);const u=n.makeTensorInfo(i,s);const l=n.texData.get(u.dataId);l.values=o;return u}let o;if(env().getBool("WEBGL_PACK_BINARY_OPERATIONS")){o=new BinaryOpPackedProgram(MUL,r.shape,a.shape)}else{o=new BinaryOpProgram(MUL,r.shape,a.shape)}return n.runWebGLProgram(o,[r,a],s)}const multiplyConfig={kernelName:Multiply,backendName:"webgl",kernelFunc:multiply};class MatMulPackedProgram{constructor(e,t,n,r=false,a=false,s=false,o=null,i=false,u=false){this.variableNames=["matrixA","matrixB"];this.packedInputs=true;this.packedOutput=true;this.outputShape=n;this.enableShapeUniforms=useShapeUniforms(this.outputShape.length);const l=r?e[1]:e[2];const c=Math.ceil(l/2);const p=r?"i * 2, rc.y":"rc.y, i * 2";const m=a?"rc.z, i * 2":"i * 2, rc.z";const d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"];const h=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",g="";if(o){if(i){f=`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`}else if(u){f=`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`}else{f=`vec4 activation(vec4 x) {\n          ${o}\n        }`}g=`result = activation(result);`}const y=s?"result += getBiasAtOutCoords();":"";if(s){this.variableNames.push("bias")}if(i){this.variableNames.push("preluActivationWeights")}if(u){this.variableNames.push("leakyreluAlpha")}let x="rc.x";let T="rc.x";if(e[0]<t[0]){x=`int(min(float(rc.x), ${e[0]-1}.))`}else if(t[0]<e[0]){T=`int(min(float(rc.x), ${t[0]-1}.))`}this.userCode=`\n      ${f}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${x};\n          int batchB = ${T};\n          vec4 a = getMatrixA(batchA, ${p});\n          vec4 b = getMatrixB(batchB, ${m});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${h[0]});\n          result += (${d[1]} * ${h[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const MATMUL_SHARED_DIM_THRESHOLD=1e3;function batchMatMulImpl({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=e.shape.length;const c=t.shape.length;const p=n?e.shape[l-2]:e.shape[l-1];const m=r?t.shape[c-1]:t.shape[c-2];const d=n?e.shape[l-1]:e.shape[l-2];const h=r?t.shape[c-2]:t.shape[c-1];const f=e.shape.slice(0,-2);const g=t.shape.slice(0,-2);const y=sizeFromShape(f);const x=sizeFromShape(g);const T=assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2));const E=T.concat([d,h]);assert(p===m,(()=>`Error in matMul: inner shapes (${p}) and (`+`${m}) of Tensors with shapes ${e.shape} and `+`${t.shape} and transposeA=${n}`+` and transposeB=${r} must match.`));const N=n?[y,p,d]:[y,d,p];const S=r?[x,h,m]:[x,m,h];const b=reshape({inputs:{x:e},backend:a,attrs:{shape:N}});const _=reshape({inputs:{x:t},backend:a,attrs:{shape:S}});const I=[b,_];const v=Math.max(y,x);const P=n?b.shape[1]:b.shape[2];const w=s!=null;const A=o!=null;const O=u==="leakyrelu";const $=u!=null?mapActivationToShaderProgram(u,true):null;const k=w||A||O||$!=null;let C;if((d===1||h===1)&&P>MATMUL_SHARED_DIM_THRESHOLD&&k===false){let e=b;let t=_;if(n){e=transpose({inputs:{x:b},backend:a,attrs:{perm:[0,2,1]}});I.push(e)}if(r){t=transpose({inputs:{x:_},backend:a,attrs:{perm:[0,2,1]}});I.push(t)}const s=h!==1;const o=h===1;let i=e;if(s){i=reshape({inputs:{x:e},backend:a,attrs:{shape:[v,P,1]}});I.push(i)}const u=h===1?2:1;let l=t;if(o){l=reshape({inputs:{x:t},backend:a,attrs:{shape:[v,1,P]}});I.push(l)}const c=multiply({inputs:{a:i,b:l},backend:a});C=sum({inputs:{x:c},backend:a,attrs:{axis:u,keepDims:true}});I.push(c)}else{const u=upcastType(e.dtype,t.dtype);const l=new MatMulPackedProgram(N,S,[v,d,h],n,r,w,$,A,O);const c=[b,_];if(s!=null){c.push(s)}if(A){c.push(o)}if(O){const e=a.makeTensorInfo([],"float32",createScalarValue(i,"float32"));c.push(e);I.push(e)}C=a.runWebGLProgram(l,c,u)}const R=reshape({inputs:{x:C},backend:a,attrs:{shape:E}});I.push(C);for(const e of I){a.disposeIntermediateTensorInfo(e)}return R}function batchMatMul(e){const{inputs:t,backend:n,attrs:r}=e;const{a:a,b:s}=t;const{transposeA:o,transposeB:i}=r;return batchMatMulImpl({a:a,b:s,transposeA:o,transposeB:i,backend:n})}const batchMatMulConfig={kernelName:BatchMatMul,backendName:"webgl",kernelFunc:batchMatMul};class GatherProgram{constructor(e,t){this.variableNames=["A","indices"];this.outputShape=t;this.rank=t.length;const n=getCoordsDataType(this.rank);const r=getSourceCoords(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function getSourceCoords(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"];const r=[];for(let t=0;t<e.length;t++){if(t===2){r.push("index")}else{r.push(`${n[t]}`)}}return r.join()}function gatherV2(e){const{inputs:t,backend:n,attrs:r}=e;const{x:a,indices:s}=t;const{axis:o,batchDims:i}=r;const u=parseAxisParam(o,a.shape)[0];if(env().get("DEBUG")){const e=n.readSync(s.dataId);const t=a.shape[u];for(let n=0;n<e.length;++n){const r=e[n];assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const l=collectGatherOpShapeInfo(a,s,u,i);const c=sizeFromShape(s.shape);const p=[];const m=reshape({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}});const d=reshape({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(m);p.push(d);const h=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([a,s])||a.dtype==="string"){const e=n.bufferSync(d);const t=n.bufferSync(m);const r=gatherV2ImplCPU(t,e,h);p.forEach((e=>n.disposeIntermediateTensorInfo(e)));return n.makeTensorInfo(l.outputShape,r.dtype,r.values)}const f=new GatherProgram(m.shape,h);const g=n.runWebGLProgram(f,[m,d],m.dtype);p.push(g);const y=reshape({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});p.forEach((e=>n.disposeIntermediateTensorInfo(e)));return y}const gatherV2Config={kernelName:GatherV2,backendName:"webgl",kernelFunc:gatherV2};const SIGMOID=CHECK_NAN_SNIPPET_UNARY+`\n  return 1.0 / (1.0 + exp(-1.0 * x));\n`;const SIGMOID_PACKED=`\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;const sigmoid=unaryKernelFunc({opSnippet:SIGMOID,packedOpSnippet:SIGMOID_PACKED,cpuKernelImpl:sigmoidImplCPU});const sigmoidConfig={kernelName:Sigmoid,backendName:"webgl",kernelFunc:sigmoid};function _fusedMatMul(e){const{inputs:t,backend:n,attrs:r}=e;const{a:a,b:s,bias:o,preluActivationWeights:i}=t;const{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=r;return batchMatMulImpl({a:a,b:s,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:p,activation:c})}const _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"webgl",kernelFunc:_fusedMatMul};for(let e of[addConfig,sumConfig,powConfig,packConfig,castConfig,reluConfig,meanConfig,prodConfig,padV2Config,unpackConfig,reshapeConfig,isFiniteConfig,identityConfig,selectConfig,multiplyConfig,batchMatMulConfig,gatherV2Config,concatConfig,sigmoidConfig,_fusedMatMulConfig])registerKernel(e);var tfjs=Object.freeze({__proto__:null,cast:cast$1,enableProdMode:enableProdMode,env:env,loadGraphModel:loadGraphModel,oneHot:oneHot,stack:stack,sum:sum$1,tensor:tensor,tidy:tidy,unstack:unstack,zeros:zeros$1});const WHITESPACE_PATTERN=/\s+/g;const PUNCTUATION_PATTERN=/[\xA0!"\\'()*,-./:;?&[\]^_`{|}~]/g;const RGB_PATTERN=/rgb\((\d+), (\d+), (\d+)\)/;const RGBA_PATTERN=/rgba\((\d+), (\d+), (\d+), (\d+)\)/;const ORIGIN_PATTERN=/(\d*?\.?\d*)px (\d*?\.?\d*)px/;const PIXEL_PATTERN=/(\d*?\.?\d*)px/;const DOT_PATTERN=/\./g;const BRACKETS_PATTERN=/^\[|\]$/g;const SLASH_PATTERN=/\//g;const WORD_INDEX=Object.fromEntries([..." abcdefghijklmnopqrstuvwxyz1234567890:;/?!=+.,()[]-`*_|~"].map(((e,t)=>[e,t+1])));class FeatureNormalizer{constructor(e){this.normalizers=[];e.forEach((e=>{if(Array.isArray(e)){let[t,n]=e;this.normalizers.push(new t(n))}else{this.normalizers.push(new e)}}))}normalize(e,t){this.normalizers.forEach((n=>{e=n.normalize(e,t)}));return e}}class StringNormalizer{normalize(e){throw new Error("Not implemented.")}}class Lowercase extends StringNormalizer{normalize(e){return e.toLowerCase()}}class StripWhitespace extends StringNormalizer{normalize(e){return e.trim()}}class CollapseWhitespace extends StringNormalizer{normalize(e){return e.replace(WHITESPACE_PATTERN," ")}}class StripAndCollapseWhitespace extends StringNormalizer{normalize(e){return e.replace(WHITESPACE_PATTERN," ").trim()}}class RemovePunctuation extends StringNormalizer{normalize(e){return e.replace(PUNCTUATION_PATTERN,"")}}class ReplacePunctuation extends StringNormalizer{normalize(e){return e.replace(PUNCTUATION_PATTERN," ")}}class ReplaceStr extends StringNormalizer{constructor(e){super();this.pairs=e}normalize(e){if(e){this.pairs.forEach((t=>{e=e.split(t[0]).join(t[1])}))}return e}}class LastCSSClassNormalizer extends StringNormalizer{normalize(e){return e.split(" ").pop()}}class VectorNormalizer{normalize(e){throw new Error("Not implemented.")}}class FloatNormalizer extends VectorNormalizer{normalize(e){return[parseFloat(e)||0]}}class SequenceNormalizer extends VectorNormalizer{constructor(e){super();this.maxLen=e}normalize(e){let t=[...e.toLowerCase()].slice(-this.maxLen).map((e=>e in WORD_INDEX?WORD_INDEX[e]:1));return t.length>=this.maxLen?t:t.concat(new Array(this.maxLen-t.length).fill(0))}}class OneHotVectorNormalizer extends VectorNormalizer{constructor(e){super();const t=e.length;this.empty=new Array(t).fill(0);let n=0;this.categoryMap=e.reduce(((e,t)=>{let r=[...this.empty];r[n++]=1;e[t]=r;return e}),{})}normalize(e){return this.categoryMap[e]||this.empty}}class FontSizeNormalizer extends VectorNormalizer{normalize(e){return[parseFloat(e)||0]}}class ColorNormalizer extends VectorNormalizer{constructor(e){super();this.maxLen=e}normalize(e){let t=[0,0,0,0];const n=e.match(RGB_PATTERN);if(n){n.shift();t=n.map((e=>parseFloat(e)||0));t.push(0)}else{const n=e.match(RGBA_PATTERN);if(n){n.shift();t=n.map((e=>parseFloat(e)||0))}}return t.slice(0,this.maxLen)}}class PixelNormalizer extends VectorNormalizer{normalize(e){const t=e.match(PIXEL_PATTERN);if(t)return[parseFloat(t[1])||0];return[0]}}class OriginNormalizer extends VectorNormalizer{normalize(e){const t=e.match(ORIGIN_PATTERN);if(t){t.shift();return t.map((e=>parseFloat(e)||0))}return[0,0]}}class NodeChildrenLenNormalizer{normalize(e){if(Array.isArray(e))return[e.length];return[0]}}const URL_MARKERS=["http","data","blob","ftp:"];class MetaURLPartsNormalizer{normalize(e,t){if(!e)return[0,0,0,0,0,0,0,0,0];const n=1;const r=URL_MARKERS.includes(e.slice(0,4).toLowerCase())?1:0;if(!r)return[n,r,0,0,e.length,0,0,0,0];let a;try{a=new URL(e)}catch(t){return[n,r,0,0,e.length,0,0,0,0]}const s=a.hostname.includes(t["domain"])?0:1;const o=a.username+a.password+a.hostname+(a.port?a.port:"");const i=a.pathname==="/"?"":a.pathname;const u=Array.from(a.searchParams);const l=o.length;const c=i.length;const p=u.flat().join("").length;const m=o?a.hostname.split(".").length:0;const d=i.split("/").filter(Boolean).length;const h=u.length;return[n,r,s,l,c,p,m,d,h]}}class URLPartsNormalizer{constructor(e){this.maxLen=e;this.maxPartsLen=this.maxLen/3;this.replacePunctuation=new ReplacePunctuation}normalize(e,t){let n;const r=URL_MARKERS.includes(e.slice(0,4).toLowerCase())?1:0;if(!r)return e.substring(0,this.maxLen).trim();try{n=new URL(e)}catch(t){return e.substring(0,this.maxLen).trim()}const a=n.hostname.replace(BRACKETS_PATTERN,"");const s=[n.username,n.password,a.replace(DOT_PATTERN," "),n.port].filter(Boolean).join(" ").slice(0,this.maxPartsLen).trim();const o=n.pathname.replace(SLASH_PATTERN," ").slice(0,2*this.maxPartsLen-s.length).trim();const i=n.search.substring(1).split("&").map((e=>e.split("=")[0].trim())).join(" ").slice(0,3*this.maxPartsLen-s.length-o.length).trim();return[[s,o].join(" ").trim(),i].join(" ").trim()}}class MetaContentNormalizer{normalize(e,t){let n=0;let r=0;if(e){n=e.length;r=e.split(" ").length}return[n,r]}}class FeaturePreProcessor{constructor(e){this.preprocesors=[];for(let t of e)this.preprocesors.push(new t)}process(e,t){this.preprocesors.forEach((t=>e=t.process(e)));return e}}class EmptyPreProcessor{process(e,t){if(!e)return new Map;return e}}class CSSSelectorPreProcessor{process(e,t){if(!e||!(typeof e==="string"||e instanceof String))return new Map;return e.split(";").reduce(((e,t)=>{const[n,r]=t.split(":");if(n&&r&&!(n in e))e[n.trim()]=r.trim();return e}),{})}}function createFeatureGroups(e){let t=[];let n=[];for(let t of e)t.groupName=Object.keys(t)[2];for(let r of e){if(r.scope==="graph"&&r.include)t.push(new FeatureGroup(r.groupName,r[r.groupName]));else if(r.scope==="node"&&r.include)n.push(new FeatureGroup(r.groupName,r[r.groupName]))}return[n,t]}const Preprocessor2Class={empty:EmptyPreProcessor,css_selector:CSSSelectorPreProcessor};const Normalizers2Class={lower:Lowercase,strip_whitespace:StripWhitespace,collapse_whitespace:CollapseWhitespace,strip_and_collapse_whitespace:StripAndCollapseWhitespace,remove_punctuation:RemovePunctuation,replace_punctuation:ReplacePunctuation,sequence:SequenceNormalizer,one_hot_vector:OneHotVectorNormalizer,font_size:FontSizeNormalizer,color:ColorNormalizer,pixel:PixelNormalizer,origin:OriginNormalizer,children_len:NodeChildrenLenNormalizer,replace_str:ReplaceStr,meta_url:MetaURLPartsNormalizer,url_parts:URLPartsNormalizer,meta_content:MetaContentNormalizer,css_class:LastCSSClassNormalizer,float:FloatNormalizer};const splitWithEmpty=(e,t)=>{const n=e.split(t);if(n[0]===""&&n.length===1)return[];return n};class Feature{constructor(e,t){this.name=e;this.dim=t.dim;this.altNames=splitWithEmpty(e,"^");this.path=[];if(t.path)this.path=splitWithEmpty(t.path,"^");let n=[];if(!Object.prototype.hasOwnProperty.call(t,"normalizers")){n.push(Normalizers2Class.empty)}else{for(const e in t.normalizers){const r=t.normalizers[e];if(typeof r==="string"||r instanceof String){n.push(Normalizers2Class[r])}else if(typeof r==="object"&&r!==null){const e=Object.keys(r)[0];n.push([Normalizers2Class[e],Object.values(r[e])[0]])}}}this.normalizer=new FeatureNormalizer(n)}getName(e){if(this.altNames&&Object.keys(e).length>0){for(let t of this.altNames){if(t in e)return t}}return this.name}extractValues(e,t){let n=e;this.path.forEach((e=>{if(e in n)n=n[e]}));const r=this.getName(n);const a=r in n?n[r]:"";const s=this.normalizer.normalize(a||"",t);if(s.length!==this.dim)throw new Error("Feature dimensionality mismatch");return s}}class FeatureGroup{constructor(e,t){this.name=e;this.path=splitWithEmpty(t.path,"/");this.prep=this.initPreprocessing(t);this.features=this.initFeatures(t.features)}initPreprocessing(e){let t=[];if(!Object.prototype.hasOwnProperty.call(e,"prep")){t.push(Preprocessor2Class.empty)}else{for(let n of e.prep)t.push(Preprocessor2Class[n])}return new FeaturePreProcessor(t)}initFeatures(e){let t=[];for(const n of e){const e=Object.keys(n)[0];const r=n[e];if(!Object.prototype.hasOwnProperty.call(r,"names")){t.push(new Feature(e,r));continue}for(const e of r.names)t.push(new Feature(e,r))}return t}extractValues(e,t){let n=e;this.path.forEach((e=>{if(e in n)n=n[e]}));n=this.prep.process(n,t);if(typeof n!=="object"||Array.isArray(n)||n===null){throw new Error(`path ${this.path}, value ${n}, expected ${typeof{}}, got ${n}`)}let r=[];this.features.forEach((e=>r.push(...e.extractValues(n,t))));return r}}const URL_DATA_ATTRS=["src","href","xlink:href"];const zeros=(e,t,n=0)=>Array.from(new Array(t),(t=>Array(e).fill(n)));const get=(e,t,n)=>t in e?e[t]:n;class Graph{constructor(e){this.numNodes=0;this.root=e["obj"]["graph"];this.domain=e["obj"]["domain"];this.graphAttributes={domain:e["obj"]["domain"]};this.featureGroups=e["nodeFeatureGroups"];this.graphFeatureGroups=e["graphFeatureGroups"];this.cutoff=e["cutoff"]}getData(){this.setNodeAttributes();let e=zeros(this.numNodes,this.numNodes);let t=[];let n=[];let r=[[this.root,{}]];let a=this.cutoff;while(r.length&&--a>=0){let n;let[a,s]=r.pop();this._updateFeatures(a,this.featureGroups,t);if(s&&Object.keys(s).length>0)this._updateEdges(a,s,e);[s,n]=[a,a["children"]];for(let e=n.length-1;e>=0;e--)r.push([n[e],s])}this._updateFeatures(this.graphAttributes,this.graphFeatureGroups,n);return this._formatData(e,t,n)}setNodeAttributes(){let e=[[this.root,{}]];let t=this.cutoff;while(e.length&&--t>=0){let t;let[n,r]=e.pop();this._setNodeAttributes(n,r);[r,t]=[n,n["children"]];for(let n=t.length-1;n>=0;n--)e.push([t[n],r])}}_setNodeAttributes(e,t){e["node_id"]=this.numNodes++;e["dom"]=this.domain;e["parent_id"]=get(t,"node_id",0);e["siblings"]=get(t,"children",[]).length;e["level"]=get(t,"level",-1)+1;let n=get(e,"attributes",{});let r=get(t,"attributes",{});URL_DATA_ATTRS.forEach((a=>{let s=`${a}_level`;if(this._hasAttribute(a,n)){e["attributes"][s]=0}else if(this._hasAttribute(a,r)){e["attributes"][a]=r[a];e["attributes"][s]=r[s]+1;if("requestType"in t)e["requestType"]=t["requestType"]}}))}_hasAttribute(e,t){return e in t&&t[e]}_updateFeatures(e,t,n){let r=[];t.forEach((t=>r.push(...t.extractValues(e,{domain:this.domain}).map((e=>Math.round(e*100)/100||0)))));n.push(r)}_updateEdges(e,t,n){n[t["node_id"]][e["node_id"]]=1;n[e["node_id"]][t["node_id"]]=1}_formatData(e,t,n){if(e.length>t.length)this._cutEdges(e,t.length);if(this.graphFeatureGroups.length>0)return[e,t,n];return[e,t]}_cutEdges(e,t){e=e.slice(0,t);e.forEach(((e,n,r)=>{r[n]=e.slice(0,t)}))}}class ML{constructor(e){this.tfjs=e;this._preprocessingFunctions=new Map([["cast",e.cast],["stack",e.stack],["unstack",e.unstack],["localPooling",this._localPoolingMap.bind(this)],["padAdjacency",this._padTensorAdjacency.bind(this)],["padFeatures",this._padTensorFeatures.bind(this)]])}_padTensorAdjacency(e,t){return e.pad([[0,0],[0,t-e.shape[1]],[0,t-e.shape[2]]])}_localPoolingMap(e){return e.map((e=>this._localPooling(e)))}_localPooling(e){let t=e.add(this.tfjs.eye(e.shape[0]));let n=this.tfjs.pow(this.tfjs.sum(t,1),-.5);n=n.where(this.tfjs.isFinite(n),this.tfjs.zeros(n.shape));let r=n.mul(this.tfjs.eye(t.shape[0]));let a=r.dot(t).dot(r);return a}_padTensorFeatures(e,t){return e.pad([[0,0],[0,t-e.shape[1]],[0,0]])}createTensors(e,t){let[n,r]=e;let a=[{data:[n],preprocess:[{funcName:"padAdjacency",args:t}]},{data:[r],preprocess:[{funcName:"padFeatures",args:t}]}];let s=this.tfjs.tidy((()=>a.map((e=>{let t=this.tfjs.tensor(e.data);if(e.preprocess){for(let n of e.preprocess){t=this._preprocessingFunctions.get(n.funcName)(t,n.args)}}return t}))));return s}}const DEFAULT_GRAPH_CUTOFF=500;async function preprocessGraph(e,t,n="."){return new Promise(((r,a)=>{if(!e||!t)return a();let s=e.config;let o=s.cutoff||e.topology.graphml.nodes||DEFAULT_GRAPH_CUTOFF;let[i,u]=createFeatureGroups(s);let l={nodeFeatureGroups:i,graphFeatureGroups:u,obj:{domain:n,graph:t},cutoff:o};let c=new Graph(l);let p=c.getData();r(p)}))}async function predict(e,t,n,r){return new Promise(((a,s)=>{if(!n||!e||!t||!r)return s();let o=n.config;let i=o.cutoff||n.topology.graphml.nodes||DEFAULT_GRAPH_CUTOFF;let u=new ML(e);let l=u.createTensors(r,i);let c=t.execute(l);c.data().then((e=>{a(e)})).catch((e=>{s(e)})).finally((()=>{c.dispose();for(let e of l)e.dispose()}))}))}async function digestPrediction(e){return new Promise(((t,n)=>{e=Array.from(e);if(!e||!Array.isArray(e)||!e.some((e=>e>0))||e.length<2)return n();let r=e.reduce(((e,t)=>e+t),0);e=e.map((e=>e/r));t(e[1]>e[0])}))}async function loadBundledModel(e,t){if(!t)return Promise.reject("model not found");return e.loadGraphModel({load(){let e={modelTopology:t.topology.modelTopology||{},signature:t.topology.signature||{},weightsManifest:t.topology.weightsManifest||[],weightSpecs:t.topology.weightsManifest.map((e=>e.weights))[0]||[],weightData:concatWeights(t.weights.map((e=>Uint8Array.from(atob(e.shard),(e=>e.charCodeAt(0))))))||[]};return e}})}function concatWeights(e){let t=0;e.forEach((e=>{t+=e.byteLength}));let n=new Uint8Array(t);let r=0;e.forEach((e=>{n.set(new Uint8Array(e),r);r+=e.byteLength}));return n.buffer}let mode=false;function print(e,t=false,...n){if(mode){console.log("%cMLDBG  %c| %s%c |","color:cyan",t?"color:red":"color:inherit",e,"color:inherit",...n)}}function toggle(e){mode=!!e}let settings={};settings.set=e=>{if(!e||typeof e!=="object")return;settings=Object.assign(settings,e)};var settings$1=settings;let modelDataCache;let deviceDataCache;function parsePrediction(e){try{let{rawPrediction:t,prediction:n}=e;return{...t&&typeof t==="object"?{confidenceScore:Array.from(t)}:[],...typeof n==="boolean"?{classLabel:n?"ad":"non-ad"}:{}}}catch(e){}}function parseInputs(e){let t;try{let{bundle:n,preprocessedGraph:r}=e||{};let{reportConfig:a}=n||{};let{featureReportProbability:s}=settings$1&&settings$1.featureReportProbability?settings$1:a||{};if(!mode&&(settings$1.telemetryOptOut||!s||isNaN(s)||s<=Math.random()))return Promise.resolve();if(!r||!Array.isArray(r)||r.length<2)return Promise.resolve();for(let e of r){if(!Array.isArray(e)||!e.length||!Array.isArray(e[0])||!e[0].length||isNaN(e[0][0]))return Promise.resolve()}let o;if(n&&n.topology&&n.topology.graphml&&n.topology.graphml.nodes)o=n.topology.graphml.nodes;t=[compressAdjacencyMatrix(r[0],o)];for(let e of r.slice(1))t.push(compressFeatureMatrix(e));return gzipAndBase64Encode(t)}catch(e){if(t&&Array.isArray(t))return Promise.resolve(t);return Promise.resolve()}}function parseProfilingData(e){try{let{modelColdStart:t,modelBootupTime:n,preprocessingTime:r,inferenceTime:a,digestTime:s,startTime:o}=e;return{...typeof t==="boolean"?{modelColdStart:t}:{},...!isNaN(n)&&!isNaN(o)?{modelBootupTime:n-o}:{},...!isNaN(r)&&!isNaN(n)?{preprocessingTime:r-n}:{},...!isNaN(a)&&!isNaN(r)?{inferenceTime:a-r}:{},...!isNaN(s)&&!isNaN(a)?{predictionDigestionTime:s-a}:{}}}catch(e){}}function parseModelMetadata(e){try{let{modelName:t,bundle:n}=e||{};if(modelDataCache&&modelDataCache.has(t))return modelDataCache.get(t);let r={...t&&typeof t==="string"?{modelName:t.split("-").slice(0,-1).join("-")||t}:{},...t&&typeof t==="string"&&t.includes("-")?{modelVersion:t.split("-").slice(-1).join("")}:{},...n&&n.weights&&Array.isArray(n.weights)&&n.weights[0]&&n.weights[0].shard?{modelSize:n.weights[0].shard.length}:{}};if(!modelDataCache)modelDataCache=new Map;modelDataCache.set(t,r);return r}catch(e){}}function parseDeviceData(){try{if(deviceDataCache)return deviceDataCache;let e=detectPlatformType();let t=detectBrowser();let n=detectBrowserVersion();let r=detectOsInformation();let a=detectLanguage();let s=detectAvailableMemory();return deviceDataCache={...e?{type:e}:{},...t?{browserName:t}:{},...n?{browserVersion:n}:{},...r?{OSInformation:r}:{},...a?{language:a}:{},...s?{availableMemory:s}:{}}}catch(e){}}function parseWebsiteMetadata(e){let{sender:t}=e||{};if(!t||!t.tab||!t.tab.id||!chrome||!chrome.tabs)return Promise.resolve();return new Promise((e=>{try{chrome.tabs.get(t.tab.id,(t=>{if(chrome.runtime.lastError||!t||!t.url)return e();let n=new URL(t.url);e({url:n.origin+n.pathname,domainName:n.hostname})}))}catch(t){e()}}))}function detectOs(){try{let{userAgent:e}=navigator||{};if(!e)return;switch(true){case/Android/.test(e):return"Android";case/Windows/.test(e):return"Windows";case/Mac OS X/.test(e):return"Mac";case/Linux/.test(e):return"Linux"}}catch(e){}}function detectOsVersion(){try{let{userAgent:e}=navigator||{};if(!e)return;let t=detectOs();let n;if(t==="Android")n="Android";else if(t==="Windows")n=/Phone/.test(e)?/Windows Phone (?:OS )?/:"Windows NT";else if(t==="Mac")n="Mac OS X ";if(n){let t=e.split(n)[1].trim().split(/[^\w.]/)[0];return t.split(/[._]/).slice(0,3).join(".")}}catch(e){}}function detectOsInformation(){try{let e=detectOs();let t=detectOsVersion();let n;if(e){n=e;if(t)n+=` ${t}`}return n}catch(e){}}function detectPlatformType(){try{let e=chrome&&chrome.runtime&&chrome.runtime.getManifest?chrome.runtime.getManifest():null;if(e&&e.short_name){switch(e.short_name){case"AdBlock":return"AdBlock";case"Adblock Plus":return"Adblock Plus";default:return"Extension"}}let t=detectOs();if(t==="Android")return"Mobile"}catch(e){}}function detectBrowser(){try{let{userAgent:e}=navigator||{};if(!e)return;switch(true){case e.includes("Chrome")&&!e.includes("Chromium")&&!e.includes("OPR")&&!e.includes("Edge")&&!e.includes("Edg")&&!e.includes("SamsungBrowser"):return"Chrome";case e.includes("Firefox")&&!e.includes("Seamonkey"):return"Firefox";case e.includes("OPR"):return"Opera";case(e.includes("Edg")||e.includes("Edge"))&&e.includes("Chrome"):return"Edge"}}catch(e){}}function detectBrowserVersion(){try{let{userAgent:e}=navigator||{};if(!e)return;let t=detectBrowser();let n;if(t){if(t==="Opera")t="opera|opr";if(t==="Edge")t="edge|edg";n=e.match(new RegExp(`(${t}(?=\\/))\\/?\\s*(\\d[^\\s|$]*)`,"i"))}if(!n&&!n.length>=2&&!n[2])n=e.match(/(edge|edg|opr|opera|chrome|firefox|version(?=\/))\/?\s*(\d[^\s|$]*)/i);if(n&&n[2])return n[2]}catch(e){}}function detectLanguage(){let{language:e}=navigator||{};if(e)return e}function detectAvailableMemory(){if(window&&window.performance&&window.performance.memory&&window.performance.memory.totalJSHeapSize)return window.performance.memory.totalJSHeapSize}function compressAdjacencyMatrix(e,t){try{if(!Array.isArray(e)||!e.length||!Array.isArray(e[0])||!e[0].length)return;if(t){for(let n of e)n.push(...new Array(Math.max(0,t-n.length)).fill(0))}return e.map((e=>e.reduce(((e,t)=>{if(e.length&&Math.sign(e[e.length-1])===Math.sign(t-.5))e[e.length-1]+=Math.sign(t-.5);else e.push(Math.sign(t-.5));return e}),[])))}catch(e){}}function compressFeatureMatrix(e){try{if(!Array.isArray(e)||!e.length||!Array.isArray(e[0])||!e[0].length)return;return e.map((e=>e.reduce(((e,t)=>{if(t)e.push(t);else if(Array.isArray(e[e.length-1]))e[e.length-1][0]++;else e.push([1]);return e}),[])))}catch(e){}}function gzipAndBase64Encode(e){try{if(!Array.isArray(e)||e.length<2||!Array.isArray(e[0])||!e[0].length||!Array.isArray(e[0][0])||!e[0][0].length||!Array.isArray(e[1][0])||!e[1][0].length)return Promise.resolve();if(typeof CompressionStream==="undefined")return Promise.resolve(e);let t=new ReadableStream({start:t=>t.enqueue((new TextEncoder).encode(JSON.stringify(e))),pull:e=>e.close()});let n=t.pipeThrough(new CompressionStream("gzip"));return new Response(n).arrayBuffer().then((e=>btoa(new Uint8Array(e).reduce(((e,t)=>e+String.fromCharCode(t)),"")))).catch((()=>Promise.resolve(e)))}catch(t){return Promise.resolve(e)}}const QUEUE_DIGESTION_INTERVAL=1e3;const MAX_SEND_ATTEMPT=3;let reportQueue;let digestInterval;function queueReport(e){try{let{bundle:t,sender:n}=e||{};let{reportConfig:r}=t||{};let{reportProbability:a}=settings$1&&settings$1.reportProbability?settings$1:r||{};let s=!!(n&&n.tab&&n.tab.incognito);if(!mode&&(settings$1.telemetryOptOut||s&&!settings$1.privateBrowsingTelemetry||!a||isNaN(a)||a<=Math.random())||e.allowlisted)return Promise.resolve(e);print("Queueing report with raw data",false,e);if(!reportQueue)reportQueue=new Set;reportQueue.add(e);if(!digestInterval)digestInterval=setTimeout(digestQueue,QUEUE_DIGESTION_INTERVAL)}catch(e){print(`Queueing report failed with "${e}"`,true)}return Promise.resolve(e)}function digestQueue(e=false){try{if(!reportQueue||!reportQueue.size){digestInterval=0;return}let[e]=reportQueue;reportQueue.delete(e);if(!e||["bundle","modelName","prediction","preprocessedGraph"].some((t=>!(t in e)||!e.bundle.reportConfig||!e.bundle.reportConfig.reportURL)))return print("Reporting queue digestion failed due to corrupt data",true);let{reportURL:t,reportBearerToken:n}=e.bundle.reportConfig;generateTelemetryData(e).then((e=>sendReport(e,t,n).then((()=>print("Report successfully sent:",false,e))))).catch((t=>{e.failedCounter=(e.failedCounter||0)+1;(t instanceof Response?t.text():Promise.resolve(t)).then((t=>print(`Sending report failed ${e.failedCounter} times with error "${t}" for`,true,e)));if(e.failedCounter<MAX_SEND_ATTEMPT){print("Attempting to resend",false,e);reportQueue.add(e)}else{print(`Abandoning report after ${e.failedCounter} retries`,true,e)}})).then((()=>{digestInterval=setTimeout(digestQueue,QUEUE_DIGESTION_INTERVAL)}))}catch(t){if(e){reportQueue.clear();digestInterval=0}else{digestInterval=setTimeout((()=>digestQueue(true)),QUEUE_DIGESTION_INTERVAL)}print(`Reporting queue digestion failed with "${t}"`,true)}}async function generateTelemetryData(e){try{if(typeof e!=="object")return Promise.reject();let t=parsePrediction(e);let n=parseProfilingData(e);let r=parseModelMetadata(e);let a=parseDeviceData();let s=await parseWebsiteMetadata(e);let o=await parseInputs(e);return{payload:{timestamp:Date.now(),...t?{prediction:t}:{},...n?{profilingData:n}:{},...r?{modelMetadata:r}:{},...a?{device:a}:{},...s?{websiteMetadata:s}:{},...o?{inputs:o}:{}}}}catch(e){print(`Report data calculation failed with "${e}"`,true);return Promise.reject()}}function sendReport(e,t,n){try{print("Sending report",false,e);if(!e||typeof e!=="object"||typeof t!=="string"||!t.trim()||n&&typeof n!=="string")return Promise.reject("Missing data");return fetch(t,{method:"POST",headers:{Accept:"*/*",...n?{Authorization:`Bearer ${n}`}:{},"Content-Type":"application/json"},body:JSON.stringify(e)}).then((e=>!e||!e.ok?Promise.reject(e):e))}catch(e){return Promise.reject(e)}}let databaseRef;let performedMaintenance=false;const DATABASE_NAME="ml";const TABLE_NAME="data";const MODEL_TTL=2592e6;const MODEL_DELETION_TIMEOUT=1e3;const MAINTENANCE_INTERVAL=864e5;const MAINTENANCE_DATABASE_KEY="conf_maintenance_time";function databaseTransaction(e){if(!e.action||e.action!=="keys"&&!e.key||e.action==="put"&&!e.data)return Promise.reject("Missing database transaction options/data.");if(typeof indexedDB==="undefined")return Promise.reject("No IndexedDB support");return openDatabase().then((t=>{let n=t.transaction(TABLE_NAME,"readwrite");let r=n.objectStore(TABLE_NAME);let a;if(e.action==="get")a=r.get(e.key);else if(e.action==="put")a=r.put(e.data,e.key);else if(e.action==="del")a=r.delete(e.key);else if(e.action==="keys")a=r.getAllKeys();else return Promise.reject("Database transaction request not recognized");return new Promise(((t,r)=>{n.onerror=r;a.onerror=r;a.onsuccess=()=>{if(e.action==="put")t(e.data);else if(e.action==="get")t(a.result);else if(e.action==="del")t();else if(e.action==="keys")t(a.result);else r("Database transaction request not recognized")}}))}))}function openDatabase(){if(typeof indexedDB==="undefined")return Promise.reject("No IndexedDB support");if(!databaseRef){databaseRef=new Promise(((e,t)=>{let n=indexedDB.open(DATABASE_NAME,1);n.onsuccess=()=>e(n.result);n.onerror=t;n.onupgradeneeded=()=>n.result.createObjectStore(TABLE_NAME)}))}return databaseRef}function maintenance$1(){if(performedMaintenance)return;performedMaintenance=true;databaseTransaction({action:"get",key:MAINTENANCE_DATABASE_KEY}).then((e=>{if(isNaN(e)||Date.now()-e>MAINTENANCE_INTERVAL){cleanUpDatabase();return databaseTransaction({action:"put",key:MAINTENANCE_DATABASE_KEY,data:Date.now()})}})).catch((e=>print("Maintenance failed",true,e)))}function cleanUpDatabase(){print("Cleaning up database");databaseTransaction({action:"keys"}).then((e=>{e.forEach(((e,t)=>{if(!e||e.startsWith("conf"))return;setTimeout((()=>{databaseTransaction({action:"get",key:e}).then((t=>{if(t&&!isNaN(t.dt)&&Date.now()-t.dt>MODEL_TTL)return databaseTransaction({action:"del",key:e})})).catch((t=>print(`Database cleanup for ${e} failed`,true,t)))}),MODEL_DELETION_TIMEOUT*t)}))})).catch((e=>print("Database cleanup failed",true,e)))}const BACKEND_URL="https://easylist-downloads.adblockplus.org/models/";const BACKEND_TIMEOUT=1e4;const BACKEND_RETRIES=1;let cache=new Map;function getModelInstance(e){if(!e)return Promise.reject("No model name provided");if(!cache.has(e)){let t=getModel(e);let n=t.then(loadModel);t.catch((()=>{}));n.catch((()=>{}));cache.set(e,{bundle:t,instance:n})}let t=cache.get(e);if(!t.bundle||!t.instance){cache.delete(e);return Promise.reject("Model corrupted")}return Promise.resolve(t)}function loadModel(e){return loadBundledModel(tfjs,e)}function getModel(e){return fetchModelLocal(e).catch(fetchModelRemote.bind(this,e,BACKEND_RETRIES))}function fetchModelLocal(e){if(typeof indexedDB==="undefined")return Promise.reject("No IndexedDB support");return databaseTransaction({action:"get",key:e}).then((t=>{if(!t.config||!t.topology||!t.weights){databaseTransaction({action:"del",key:e}).catch((e=>print("Can't remove corrupted model",true,e)));return Promise.reject("model corrupted")}storeModel(e,t).catch((e=>print("Can't update existing model",true,e)));print(`Loaded model from database: ${e}`);return t}))}function fetchModelRemote(e,t){print(`Attempting to fetch ${e} from remote`);let n=new AbortController;let r=setTimeout(n.abort,BACKEND_TIMEOUT);if(isNaN(t))t=BACKEND_RETRIES;return fetch(`${BACKEND_URL}${e}.json`,{signal:n.signal}).then((e=>e.json())).then((t=>{if(!t.config||!t.topology||!t.weights)return Promise.reject("model corrupted");print(`Loaded model from remote: ${e}`);print(`Storing model in database: ${e}`);return storeModel(e,t).catch((e=>Promise.resolve(t)))})).catch((n=>{if(t>0)return fetchModelRemote(e,--t);print(`Failed to fetch ${e} from remote: offline`,true);return Promise.reject(n)})).finally((()=>clearTimeout(r)))}function deleteModel(e){if(cache.has(e)){print(`Removing model from memory: ${e}`);cache.delete(e)}print(`Removing model from database: ${e}`);return databaseTransaction({action:"del",key:e})}function storeModel(e,t){return databaseTransaction({action:"put",key:e,data:{...t,dt:Date.now()}})}let documentCache;function checkOriginStatus(e,t,n){if(!e||!n||!n.tab||isNaN(n.tab.id)||!chrome||!chrome.tabs||!settings$1||!settings$1.exceptionRules||typeof settings$1.exceptionRules!=="function"){print("Can't determine allowlisting status of current website. Defaulting to not allow-listed.",true);return Promise.reject()}if(!t||!t.topology||!t.topology.graphml||!t.topology.graphml.allowlist){print("Model does not support allowlisting. Defaulting to not allow-listed.");return Promise.resolve(false)}return documentStatusFromCache(n,e).catch((()=>validateDocumentStatus(n))).catch((e=>{print("Can't determine allowlisting status of current website. Defaulting to not allow-listed.",true,e);return Promise.reject()}))}function maintenance(e){if(!e||e.frameId||!e.tab||isNaN(e.tab.id)||!documentCache)return;for(let[t]of documentCache){if(t.startsWith(`${e.tab.id}_`))documentCache.delete(t)}}function documentStatusFromCache(e,t){if(!documentCache)documentCache=new Map;if(!documentCache.has(toCacheId(e)))return Promise.reject();return needsRevalidation(e,t).then((t=>!t?documentCache.get(toCacheId(e)):Promise.reject()))}function validateDocumentStatus(e){let t=e.tab.id;let n=documentCache.has(toCacheId(e));let r=documentCache.get(toCacheId(e))||Promise.resolve(false);let a=new Promise(((a,s)=>{try{let s=s=>{let o=r;for(let r of s){if(!r.frameId&&!n||r.frameId&&!documentCache.has(toCacheId(e,r.frameId))){o=o.then((n=>{if(n)return n;print("Checking content for allowlisting: ",false,e,r.frameId);return settings$1.exceptionRules(t,{frameId:r.frameId,types:["document","elemhide","genericblock","generichide"]}).then((e=>!!e.length)).catch((()=>false))}));if(r.frameId)documentCache.set(toCacheId(e,r.frameId),o)}}a(o)};if(chrome&&chrome.webNavigation&&chrome.webNavigation.getAllFrames)chrome.webNavigation.getAllFrames({tabId:t},s);else s([{frameId:0}])}catch(e){print("Error during allowlisting check.",true,e);s()}}));documentCache.set(toCacheId(e),a);a.finally((()=>{if(documentCache.size>50){let e=documentCache.keys();while(documentCache.size>50)documentCache.delete(e.next().value)}}));return a}function needsRevalidation(e,t){return(documentCache.get(toCacheId(e))||Promise.resolve(false)).then((e=>{if(e)return false;let n=false;let r=50;let a=e=>{if(!e||!e.length)return;for(let t of e){if(r<=0)return;if(t.tag==="IFRAME"||t.tag==="FRAME")return n=true;r--}a(e.map((e=>e&&e.children?e.children:[])).flat())};a([t]);return n}))}function toCacheId(e,t=0){return`${e.tab.id}_${e.tab.url}_${t}`}const MESSAGE_PREFIX="ML:";const MESSAGE_PREPARE_SUFFIX="prepare";const MESSAGE_INFERENCE_SUFFIX="inference";const errors={UNKNOWN_REQUEST:1,MISSING_REQUEST_DATA:2,UNKNOWN_MODEL:3,MISSING_INFERENCE_DATA:4,INFERENCE_FAILED:5,MODEL_INSTANTIATION_FAILED:6,MISSING_ENVIRONMENTAL_SUPPORT:7};const{set:setOptions}=settings$1;const WEBGL_SUPPORT=checkWebGlSupport();enableProdMode();env().set("WEBGL_USE_SHAPES_UNIFORMS",true);function messageListener(e,t,n){if(e&&typeof e.type==="string"&&e.type.startsWith(MESSAGE_PREFIX)){digestMessage(e,t).then(n).catch(n);return true}return false}function digestMessage(e,t){if(!e)return Promise.reject({type:e.type,error:errors.MISSING_REQUEST_DATA});let n=(e.model||"").replace([/[^a-zA-Z0-9._-]/g,""]);if(!e.type||!n||e.type===MESSAGE_PREFIX+MESSAGE_INFERENCE_SUFFIX&&!e.graph)return Promise.reject({type:e.type,error:errors.MISSING_REQUEST_DATA});if(e.debug)toggle(true);print("Digesting request",false,e);if(typeof indexedDB==="undefined"){print("Request aborted due to missing database support",true);return Promise.reject({type:e.type,error:errors.MISSING_ENVIRONMENTAL_SUPPORT})}if(!WEBGL_SUPPORT){print("Request aborted due to missing WebGL support",true);return Promise.reject({type:e.type,error:errors.MISSING_ENVIRONMENTAL_SUPPORT})}maintenance$1();if(e.type===MESSAGE_PREFIX+MESSAGE_PREPARE_SUFFIX){maintenance(t);return digestPrepare(n).then((t=>({type:e.type,config:t.config,cutoff:t.topology.graphml.nodes}))).catch((()=>Promise.reject({type:e.type,error:errors.MODEL_INSTANTIATION_FAILED})))}else if(e.type===MESSAGE_PREFIX+MESSAGE_INFERENCE_SUFFIX){return digestInference(n,e.graph,t).then((e=>queueReport(e))).then((t=>({type:e.type,...mode?t:{},prediction:t.prediction,allowlisted:!!t.allowlisted}))).catch((()=>Promise.reject({type:e.type,error:errors.INFERENCE_FAILED})))}return Promise.reject({type:e.type,error:errors.UNKNOWN_REQUEST})}function digestPrepare(e){return getModelInstance(e).then((e=>e.bundle)).catch((()=>{deleteModel(e);return Promise.reject("Model corrupted")}))}function digestInference(e,t,n){print(`Preparing inference: ${e}`,false,t);let r={modelName:e,sender:n,modelColdStart:!cache.has(e),startTime:Date.now()};return getModelInstance(e).then((e=>Promise.all([e.instance,e.bundle]))).then((([a,s])=>{r.bundle=s;r.modelBootupTime=Date.now();return checkOriginStatus(t,s,n).catch((()=>false)).then((n=>{if(n){print("Website allowlisted. Skipping inference.");r.prediction=false;r.allowlisted=true;return r}print(`Running inference: ${e}`,false,t);return preprocessGraph(s,t,".").then((e=>{r.preprocessingTime=Date.now();r.preprocessedGraph=e;return predict(tfjs,a,s,e)})).then((e=>{r.inferenceTime=Date.now();r.rawPrediction=e;return digestPrediction(e)})).then((e=>{r.digestTime=Date.now();r.prediction=e;return r}))}))})).catch((()=>{deleteModel(e);return Promise.reject("Model corrupted")}))}function checkWebGlSupport(){if(typeof OffscreenCanvas==="undefined")return false;let e=new OffscreenCanvas(0,0);try{if(e.getContext("webgl2"))return true}catch(e){}return false}export{MESSAGE_INFERENCE_SUFFIX,MESSAGE_PREFIX,MESSAGE_PREPARE_SUFFIX,digestMessage,errors,messageListener,setOptions};
